<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wonderland</title>
  
  <subtitle>welcome to wonderland</subtitle>
  <link href="https://wine1.github.io/atom.xml" rel="self"/>
  
  <link href="https://wine1.github.io/"/>
  <updated>2024-08-26T10:57:36.131Z</updated>
  <id>https://wine1.github.io/</id>
  
  <author>
    <name>Rabbit</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>创建一个webpack+react+ts项目</title>
    <link href="https://wine1.github.io/2024/08/26/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAwebpack-react-ts%E9%A1%B9%E7%9B%AE/"/>
    <id>https://wine1.github.io/2024/08/26/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAwebpack-react-ts%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-08-26T10:44:08.000Z</published>
    <updated>2024-08-26T10:57:36.131Z</updated>
    
    <content type="html"><![CDATA[<p>react 官方支持的创建命令为<code>npx create-react-app my-app --template typescript</code><br>官方脚手架集成了 webpack,但是相关配置并没有暴露出来，需要自己借助第三方工具配置。比如 craco 文档为<a href="https://www.npmjs.com/package/@craco/craco%E3%80%82%E4%BD%86%E6%98%AF%E9%80%9A%E8%BF%87%E7%AC%AC%E4%B8%89%E6%96%B9%E9%85%8D%E7%BD%AE%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%EF%BC%8C%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E7%94%A8%E5%9C%A8webpack%E4%B8%AD%E5%88%9B%E5%BB%BAreact%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE">https://www.npmjs.com/package/@craco/craco。但是通过第三方配置比较复杂，接下来我们用在webpack中创建react的形式搭建一个项目</a></p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;react 官方支持的创建命令为&lt;code&gt;npx create-react-app my-app --template typescript&lt;/code&gt;&lt;br&gt;官方脚手架集成了 webpack,但是相关配置并没有暴露出来，需要自己借助第三方工具配置。比如 craco 文档为&lt;a href=&quot;https://www.npmjs.com/package/@craco/craco%E3%80%82%E4%BD%86%E6%98%AF%E9%80%9A%E8%BF%87%E7%AC%AC%E4%B8%89%E6%96%B9%E9%85%8D%E7%BD%AE%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%EF%BC%8C%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%88%91%E4%BB%AC%E7%94%A8%E5%9C%A8webpack%E4%B8%AD%E5%88%9B%E5%BB%BAreact%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE&quot;&gt;https://www.npmjs.com/package/@craco/craco。但是通过第三方配置比较复杂，接下来我们用在webpack中创建react的形式搭建一个项目&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="工程化" scheme="https://wine1.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>算法leetcode1</title>
    <link href="https://wine1.github.io/2024/08/26/%E7%AE%97%E6%B3%95leetcode1/"/>
    <id>https://wine1.github.io/2024/08/26/%E7%AE%97%E6%B3%95leetcode1/</id>
    <published>2024-08-26T01:20:18.000Z</published>
    <updated>2024-08-26T01:20:28.808Z</updated>
    
    
    
    
    
    <category term="算法" scheme="https://wine1.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>自己写一个webpack的plugin</title>
    <link href="https://wine1.github.io/2024/08/25/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAwebpack%E7%9A%84plugin/"/>
    <id>https://wine1.github.io/2024/08/25/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAwebpack%E7%9A%84plugin/</id>
    <published>2024-08-25T12:36:46.000Z</published>
    <updated>2024-08-26T12:57:30.187Z</updated>
    
    <content type="html"><![CDATA[<p>首先来看看 Webpack 官网对 Plugin 的官方解释：</p><p>Webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 Webpack Compiler 调用，并且在整个编译生命周期都可以访问 Compiler 对象。它向第三方开发者提供了 Webpack 引擎中完整的能力。使用阶段式的构建回调，开发者可以在 Webpack 构建流程中引入自定义的行为。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先来看看 Webpack 官网对 Plugin 的官方解释：&lt;/p&gt;
&lt;p&gt;Webpack 插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 Webpack Compiler 调用，并且在整个编译生命周期都可以访问 Compiler 对</summary>
      
    
    
    
    
    <category term="工程化" scheme="https://wine1.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>自己写一个webpack的loader</title>
    <link href="https://wine1.github.io/2024/08/25/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAwebpack%E7%9A%84loader/"/>
    <id>https://wine1.github.io/2024/08/25/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAwebpack%E7%9A%84loader/</id>
    <published>2024-08-25T11:07:41.000Z</published>
    <updated>2024-08-26T12:35:25.682Z</updated>
    
    <content type="html"><![CDATA[<p>雪碧图作为一种之前经常用来做图片性能优化的方案，其缺点也比较明显，就是需要手动标明图片的大小和位置，而且需要手动合并雪碧图。对 UI 和开发人员来说，这样的操作非常繁琐。<br>所以，我们需要一个工具来帮助我们自动生成雪碧图，并且能够自动合并雪碧图。</p><span id="more"></span><p>在项目中的 webpack.config.js 中添加如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">module: &#123;</span><br><span class="line">  rules:[&#123;</span><br><span class="line">  test: /\.css$/,</span><br><span class="line">  use:[</span><br><span class="line">    path.resolve(&#x27;./loader/index&#x27;)</span><br><span class="line">  ]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将本地自定义的 loader 引入到 webpack 中，然后在 loader/index.js 中实现对图片的处理。</p><p>loader 就像一个函数，接受文件内容作为参数，返回处理后的内容或者用 fs 将处理后的内容写入到文件中。</p><p>实现一个把图片处理成雪碧图的 loader 思路：</p><ol><li>收集需要处理的图片</li><li>借助 spritesmith， 参数为收集到的图片，回调函数中返回雪碧图的内容和雪碧图的位置信息<br>spritesmith 的用法：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sprites = [&#x27;fork.png&#x27;, &#x27;github.png&#x27;, &#x27;twitter.png&#x27;];</span><br><span class="line">Spritesmith.run(&#123;src: sprites&#125;, function handleResult (err, result) &#123;</span><br><span class="line">  result.image; // Buffer representation of image</span><br><span class="line">  result.coordinates; // Object mapping filename to &#123;x, y, width, height&#125; of image</span><br><span class="line">  result.properties; // Object with metadata about spritesheet &#123;width, height&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>将雪碧图的内容通过 fs 写入到文件中</p></li><li><p>使用 postcss-value-parser (将 CSS 声明值和规则参数转换为节点树，并提供简单的遍历 API) 解析 CSS 内容，找到所有的背景图片，替换为雪碧图的 URL</p></li><li><p>用 callback 函数将处理后的内容返回给 webpack</p><p>如果是单个处理结果，可以在 同步模式 中直接返回。如果有多个处理结果，则必须调用 this.callback()。在 异步模式 中，必须调用 this.async() 来告知 loader runner 等待异步结果，它会返回 this.callback() 回调函数。随后 loader 必须返回 undefined 并且调用该回调函数。</p></li></ol><p>官方文档中的 loader 相关内容 <a href="https://webpack.docschina.org/loaders/">https://webpack.docschina.org/loaders/</a></p><p>如果需要 options<br>options 里就是传入 loader 的配置参数，下面看看如何在 loader 中使用。<br>获取方法 1：需要引入”loader-utils”库,使用 loaderUtils.getOptions()获取<br>获取方法 2：直接使用 this.getOptions()方法也可</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;雪碧图作为一种之前经常用来做图片性能优化的方案，其缺点也比较明显，就是需要手动标明图片的大小和位置，而且需要手动合并雪碧图。对 UI 和开发人员来说，这样的操作非常繁琐。&lt;br&gt;所以，我们需要一个工具来帮助我们自动生成雪碧图，并且能够自动合并雪碧图。&lt;/p&gt;</summary>
    
    
    
    
    <category term="工程化" scheme="https://wine1.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>TS进阶</title>
    <link href="https://wine1.github.io/2023/09/11/TS%E8%BF%9B%E9%98%B6/"/>
    <id>https://wine1.github.io/2023/09/11/TS%E8%BF%9B%E9%98%B6/</id>
    <published>2023-09-11T14:04:28.000Z</published>
    <updated>2023-09-12T14:08:15.268Z</updated>
    
    <content type="html"><![CDATA[<p>目前项目中对于 typescript 的应用停留在比较基础的层面，并没有充分使用它的功能。通过对 ts 更深入的学习和使用，能避免一些潜在的问题。</p><h2 id="实践-Tips"><a href="#实践-Tips" class="headerlink" title="实践 Tips"></a>实践 Tips</h2><p>尽量不使用 any,在不能确定类型的情况下，用 unknown 会更合适</p><ul><li><p><code>any</code> 任何类型，会忽略语法检查</p></li><li><p><code>unknown</code> 不可预知的类型，不会忽略语法检查</p></li></ul><p>公共的用 interface 实现，不能用 interface 实现的再用 type 实现，即用 interface 描述数据结构，用 type 描述类型关系;</p><span id="more"></span><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>TypeScript 的核心原则之一是对值所具有的<em>结构</em>进行<strong>类型检查</strong>。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，<strong>接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</strong></p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>类型别名，给类型取一个别名，并不会产生新的类型</p><h3 id="type-和-interface-的异同"><a href="#type-和-interface-的异同" class="headerlink" title="type 和 interface 的异同"></a>type 和 interface 的异同</h3><ul><li><p>都可以用来描述一个对象或者函数</p></li><li><p>都可以拓展，并且两者不是相互独立的，但语法不通。也就是说可以<code> interface extends type</code>，也可以 <code>type = type &amp; interface</code> 或者 <code>type=type ｜ interface</code></p></li><li><p>多次声明一个 interface 会自动合并，但 type 不会,type 唯一且不能重复</p></li><li><p>type 只能用于声明右侧，interface 可以用于任何地方</p></li><li><p>type 可以声明基本类型、联合类型<code>A | B</code>、交叉类型 <code>A &amp; B</code>、元组，interface 只能声明对象和函数</p></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IA &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TB = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">c</span>: <span class="built_in">number</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TC = IA | TB <span class="comment">// TC类型的变量的键只需包含ab或bc即可，当然也可以abc都有</span></span><br><span class="line"><span class="keyword">type</span> TD = IA &amp; TB <span class="comment">// TD类型的变量的键必需包含abc</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</p><p>在像 C#和 Java 这样的语言中，可以使用<code>泛型</code>来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p><p>泛型<strong>就像是类型的参数</strong>，和函数一样，可以有默认值。除此之外，还可以用 extends 对参数本身需要满足的条件进行限制。</p><p>在定义一个函数、type、interface、class 时，在名称后面加上&lt;&gt;表示即接受类型参数。而在实际调用时，不一定需要手动传入类型参数，TS 往往能自行推断出来。在 TS 推断不准时，再手动传入参数来纠正。</p><h3 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h3><p>泛型的应用场景：简单来讲就是在定义时无法确定类型，使用时才能确定类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> InterResponse&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">data</span>: T</span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型可以用在<strong>普通类型定义、类定义、函数定义</strong>上</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类型定义</span></span><br><span class="line"><span class="keyword">type</span> Animal&lt;T&gt; = &#123;<span class="attr">name</span>:<span class="built_in">string</span>, <span class="attr">type</span>:T&#125;</span><br><span class="line"><span class="keyword">const</span> sparrow&lt;<span class="built_in">string</span>&gt; = &#123;<span class="attr">name</span>:<span class="string">&#x27;bird&#x27;</span>, <span class="attr">type</span>:<span class="string">&#x27;bird&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="attr">name</span>:<span class="built_in">string</span>,</span><br><span class="line"><span class="attr">age</span>:T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> female:Person&lt;<span class="built_in">number</span>&gt; =<span class="keyword">new</span> Person&lt;<span class="built_in">number</span>&gt;(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFunc</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg:T</span>):<span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a=testFunc&lt;<span class="built_in">string</span>&gt;(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，如果对一个类型名定义了泛型，那么使用此类型名的时候一定要把泛型类型也写上去。</span></span><br><span class="line"><span class="comment">// 而对于变量来说，它的类型可以在调用时推断出来的话，就可以省略泛型书写。</span></span><br></pre></td></tr></table></figure><p><img src="/2023/09/11/TS%E8%BF%9B%E9%98%B6/image%20(1).png"></p><p>一个函数也可以传入多个泛型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFunc2</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;(<span class="params">arg:T[],arg2:U</span>):<span class="title">U</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);</span><br><span class="line">    <span class="keyword">return</span> arg2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFunc3</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;(<span class="params">arg:T,arg2:U</span>):[<span class="title">U</span>,<span class="title">T</span>]</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [arg2,arg];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的testFunc3 除了返回元祖之外，也可以用范型接口来定义返回值</span></span><br><span class="line"><span class="keyword">interface</span> InterParams&lt;N,M&gt; &#123;</span><br><span class="line">    <span class="attr">arg</span>:N;</span><br><span class="line">    arg2:M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFunc4</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;(<span class="params">arg:T,arg2:U</span>):<span class="title">InterParams</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> params:InterParams&lt;T,U&gt;&#123;</span><br><span class="line">        arg,</span><br><span class="line">        arg2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>限定范型 U 是范型 T 的子集</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>&lt;<span class="title">T</span>, <span class="title">U</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/09/11/TS%E8%BF%9B%E9%98%B6/image%20(2).png"></p><p>上图中这种情况，编辑器中提示类型 T 上没有 age 和 name,可以通过 extends 改造一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person&lt;J, K&gt; &#123;</span><br><span class="line">  name: J;</span><br><span class="line">  age: K;</span><br><span class="line">&#125;</span><br><span class="line">const printFun = &lt;T extends Person&lt;string, number&gt;, S&gt;(</span><br><span class="line">  person: T,</span><br><span class="line">  msg: S</span><br><span class="line">): S =&gt; &#123;</span><br><span class="line">  console.log(person.age);</span><br><span class="line">  console.log(person.name);</span><br><span class="line">  return msg;</span><br><span class="line">&#125;;</span><br><span class="line">printFun(&#123; name: &quot;sunny&quot;, age: 18 &#125;, &quot;success&quot;);</span><br></pre></td></tr></table></figure><h3 id="泛型条件"><a href="#泛型条件" class="headerlink" title="泛型条件"></a>泛型条件</h3><p>这里不限制 T 一定要是 U 的子类型，如果是 U 子类型，则将 T 定义为 X 类型，否则定义为 Y 类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> U? X: Y</span><br></pre></td></tr></table></figure><h3 id="泛型推断-infer"><a href="#泛型推断-infer" class="headerlink" title="泛型推断 infer"></a>泛型推断 infer</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParamType&lt;T&gt; = T <span class="keyword">extends</span> (arg: infer P) =&gt; <span class="built_in">any</span> ? P : T</span><br></pre></td></tr></table></figure><p>在这个条件语句 <code>T extends (arg: infer P) =&gt; any ? P : T</code> 中，<code>infer P</code> 表示待推断的函数参数。</p><p>整句表示为：如果 <code>T</code> 能赋值给 <code>(arg: infer P) =&gt; any</code>，则结果是 <code>(arg: infer P) =&gt; any</code> 类型中的参数 <code>P</code>，否则返回为 <code>T</code>。</p><p><strong>需要注意的是，infer 只能在條件類型的 extends 子句中使用，同時 infer 聲明的類型變量只在條件類型的 true 分支中可用。</strong></p><h3 id="常见泛型工具"><a href="#常见泛型工具" class="headerlink" title="常见泛型工具"></a>常见泛型工具</h3><p><code>Partial&lt;T&gt;</code></p><p>它用来将 T 中的所有的属性都变成可选项 ?</p><p><code>Record&lt;K extends keyof any, T&gt; </code></p><p>它用来生成一个属性为 K，类型为 T 的类型集合。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = Record&lt;<span class="string">&#x27;a&#x27;</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">const</span> foo: Foo = &#123; <span class="attr">a</span>: <span class="string">&#x27;1&#x27;</span> &#125; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo: Foo = &#123; <span class="attr">b</span>: <span class="string">&#x27;1&#x27;</span> &#125; <span class="comment">// 错误，因为 key 不为 a</span></span><br><span class="line"><span class="keyword">const</span> foo: Foo = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125; <span class="comment">// 错误，因为 value 的值不是 string 类型</span></span><br></pre></td></tr></table></figure><p><code>Pick&lt;T, K extends keyof T&gt; </code></p><p>将某个类型中的子属性挑出来，变成包含这个类型部分属性的子类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">completed</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Pick&lt;Todo, <span class="string">&#x27;title&#x27;</span> | <span class="string">&#x27;completed&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Clean room&#x27;</span>,</span><br><span class="line">  <span class="attr">completed</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Exclude&lt;T, U&gt; </code></p><p>它的作用是从 <code>T</code> 中<strong>排除</strong>掉所有包含的 <code>U</code> 属性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TFoo = Exclude&lt;<span class="number">1</span> | <span class="number">2</span>, <span class="number">1</span> | <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure><p>如果一个变量被指定为了<code>TFoo</code>类型，它就只能被赋值为 2 了，否则就会报类型检查错误</p><p><code>type Extract&lt;T, U&gt;</code></p><p>它的作用正好和上面的<code>Exclude</code>相反。而是从 <code>T</code> 中提取出所有包含的 <code>U</code> 属性值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TFoo = Extract&lt;<span class="number">1</span> | <span class="number">2</span>, <span class="number">1</span> | <span class="number">3</span>&gt;</span><br></pre></td></tr></table></figure><p><code>TFoo</code>类型最终只会包含 1。这是因为 T 包含 U 中的属性值 1，Extract 会将它提取出来生成一个类型</p><p><code>type Omit&lt;T,K&gt;</code></p><p>用来忽略 T 中的 K 属性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">email</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> UserWithoutEmail = Omit&lt;User, <span class="string">&#x27;email&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="keyword">type</span> UserWithoutEmail = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>type NonNullable&lt;T&gt; </code></p><p>它的作用是去除 T 中包含的 null 或者 undefined。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前项目中对于 typescript 的应用停留在比较基础的层面，并没有充分使用它的功能。通过对 ts 更深入的学习和使用，能避免一些潜在的问题。&lt;/p&gt;
&lt;h2 id=&quot;实践-Tips&quot;&gt;&lt;a href=&quot;#实践-Tips&quot; class=&quot;headerlink&quot; title=&quot;实践 Tips&quot;&gt;&lt;/a&gt;实践 Tips&lt;/h2&gt;&lt;p&gt;尽量不使用 any,在不能确定类型的情况下，用 unknown 会更合适&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;any&lt;/code&gt; 任何类型，会忽略语法检查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;unknown&lt;/code&gt; 不可预知的类型，不会忽略语法检查&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公共的用 interface 实现，不能用 interface 实现的再用 type 实现，即用 interface 描述数据结构，用 type 描述类型关系;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>组件设计规范</title>
    <link href="https://wine1.github.io/2023/09/11/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
    <id>https://wine1.github.io/2023/09/11/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</id>
    <published>2023-09-11T13:58:50.000Z</published>
    <updated>2023-09-12T14:14:19.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为何要进行组件设计"><a href="#为何要进行组件设计" class="headerlink" title="为何要进行组件设计"></a><strong>为何要进行组件设计</strong></h1><p>开发过程中有大量的重复或相似模块，通过对数据和方法的简单封装，可以解决许多代码冗余的问题。特别是随着项目规模和复杂度的增加，良好的组件设计能够节省许多时间精力和开发维护成本。</p><span id="more"></span><h1 id="如何提升组件易用性"><a href="#如何提升组件易用性" class="headerlink" title="如何提升组件易用性"></a><strong>如何提升组件易用性</strong></h1><h2 id="合理的封装组件"><a href="#合理的封装组件" class="headerlink" title="合理的封装组件"></a>合理的封装组件</h2><p>前端组件按照类型可以简单分为<strong>容器组件，功能组件和展示组件</strong>，一个优秀的组件应该保证：功能内聚、样式统一、并且与父元素仅通过 props 通信</p><p>组件的封装粒度并不是越小越好，很多时候一个组件是在其他一个或多个组件的基础上开发的，无法完全以功能点的数量衡量是否遵循单一职责原则，组件开发者需要根据组件功能和目标来确定组件封装粒度：</p><ol><li><strong>当该组件需要承载具体的额外功能时，相较于新增</strong> <strong>API</strong> <strong>，封装成独立的组件是更好的选择</strong></li></ol><p>🌰 当我们在多个地方都要使用选择电池电压的组件时，就不适合在选择器组件的基础上加功能，而是包装成一个新的组件</p><p><img src="/2023/09/11/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/image%20(1).png"></p><ol><li><strong>当组件中存在可能被单独使用、可以承载独立功能的子组件时，可以将其以内部组件的形式提供。</strong></li></ol><p>🌰 如下图的列表卡片本身是一个组件 Card，其中框中的主体部分在其他的地方又有用到，这时候，组件就可以做成类似 Card.Main Card.address 这种形式调用</p><p><img src="/2023/09/11/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/image%20(2).png"></p><h2 id="规范的-API-编写"><a href="#规范的-API-编写" class="headerlink" title="规范的 API 编写"></a>规范的 API 编写</h2><p>一个易用的组件，使用者无需阅读文档或仅快速浏览文档即可上手使用，并且应当在使用过程中给予清晰的注释和代码提示。希望以下 API 编写建议能够给组件开发者一些参考：</p><ol><li><p>减少必填的 API 项，尽可能多地提供默认值，降低组件的使用成本；</p></li><li><p>使用通用且有意义的 API 命名：</p><ol><li><p>onXXX：命名监听/触发方法</p></li><li><p>renderXXX：命名渲染方法</p></li><li><p>beforeXXX/afterXXX：命名前置/后置动作</p></li><li><p>xxxProps：命名子组件属性</p></li><li><p>优先使用常见单词进行命名，如：value、visible、size、disabled、label、type 等等</p></li></ol></li><li><p>单独维护类型文件，并将其打包至组件产物包中，这样使用者在开发过程中能够实时看到对应的类型提示；</p></li><li><p>在类型文件中，为 API 编写注释；</p></li></ol><h2 id="Slot-与-Props-的选择"><a href="#Slot-与-Props-的选择" class="headerlink" title="[Slot] 与 [Props] 的选择"></a>[Slot] 与 [Props] 的选择</h2><p>有的组件中会有大量定制化的场景，这种时候，通过传入类型 props 来判断定制化内容就会让组件看起来非常杂乱，类似这种场景，建议用 slot 替代组件中的定制化内容</p><p><strong>什么是插槽(Slot)？</strong></p><p>Slot 是 Vue 框架提出的概念，可以理解为临时占位，可以用其他组件进行填充，Slot 能够实现父组件向子组件分发内容的功能。Vue 框架中提供了</p><ol><li><p>使用 <code>props.children</code> 获取子组件，若需要区分使用不同子组件，只能通过数组下标读取。</p></li><li><p>使用 Props 传递 ReactNode 元素。</p></li><li><p>将组件划分为多个内部组件，交由开发者自行组装。</p></li></ol><p><img src="/2023/09/11/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/image%20(3).png"></p><h1 id="如何提升组件可扩展性"><a href="#如何提升组件可扩展性" class="headerlink" title="如何提升组件可扩展性"></a><strong>如何提升组件可扩展性</strong></h1><p>开闭原则：对扩展开放，模块的行为可以被扩展；对修改关闭，模块中的源代码不应该被修改</p><h2 id="将-DOM-交予用户接管"><a href="#将-DOM-交予用户接管" class="headerlink" title="将 DOM 交予用户接管"></a>将 DOM 交予用户接管</h2><p>在前端组件中，应该提供对应的 API 属性或方法来支持额外的功能，给予开发者更充分的扩展空间，而不是有部分需求无法满足时放弃使用组件。</p><p>形式上比如 FlatList 中的 renderItem, 使用者可以根据各自的需求来自定义渲染的内容</p><p><img src="/2023/09/11/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/image%20(4).png"></p><p>与此类似的，还有 <code>renderFooter</code>、<code>renderOption</code>、<code>renderFormat</code> 等 API，这些 API 实现难度并不高，一定程度上将 DOM 元素的掌控权交予组件使用者，作为通用组件，为开发者提供了部分功能和样式的可扩展性。我们在设计前端组件时，多多留意组件中能够接管给使用者的渲染逻辑和操作逻辑，并将这些逻辑暴露出去。</p><h2 id="设计可扩展的-API"><a href="#设计可扩展的-API" class="headerlink" title="设计可扩展的 API"></a>设计可扩展的 API</h2><p>组件开发前，整理组件所需实现的功能，并以功能为维度设计组件 API。以下是一个设计移动端选择器的例子，这个选择器需要支持单选、多选和时间选择，于是这样写了第一版 API👇，它可以满足我们当前的选择器需求。</p><p><img src="/2023/09/11/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/image%20(5).png"></p><p>在后续迭代中发现还有地区选择和级联选择的需求，选择器需要进行优化更新，在以上 API 的基础上只能通过添加 cascader、region 两个布尔值字段用于标识不同选择需求。这样做的缺陷是很明显的，每当我们新增不同类型的选择功能，都需要新增一个 API 字段，并且这些字段还是互斥关系。理清问题后，更新了第二版 API👇。在组件库中很多 API 都设计为常量枚举值的形式，即使其只有两个取值，这样扩展性相较于布尔值类型更好。</p><p><img src="/2023/09/11/%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/image%20(6).png"></p><p>除上述例子外，还可以利用 ts 的泛型和可选类型来实现 API 扩展，例如 Table 组件的 pagination、border 等字段，既可以直接设置为 true/false，也能够以对象的形式进行更详细的配置。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为何要进行组件设计&quot;&gt;&lt;a href=&quot;#为何要进行组件设计&quot; class=&quot;headerlink&quot; title=&quot;为何要进行组件设计&quot;&gt;&lt;/a&gt;&lt;strong&gt;为何要进行组件设计&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;开发过程中有大量的重复或相似模块，通过对数据和方法的简单封装，可以解决许多代码冗余的问题。特别是随着项目规模和复杂度的增加，良好的组件设计能够节省许多时间精力和开发维护成本。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>ReactNative原理浅析</title>
    <link href="https://wine1.github.io/2023/09/11/ReactNative%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/"/>
    <id>https://wine1.github.io/2023/09/11/ReactNative%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</id>
    <published>2023-09-11T13:46:52.000Z</published>
    <updated>2023-09-11T13:57:59.962Z</updated>
    
    <content type="html"><![CDATA[<p>特点<br>跨平台：React Native 使用了 Virtual DOM(虚拟 DOM)，只需编写一套代码，便可以将代码打包成不同平台的 App，极大提高了开发效率，并且相对全部原生开发的应用来说，维护成本也相对更低。<br>上手快：相比于原生开发，JavaScript 学习成本低、语法灵活。允许让 Web 开发者更多地基于现有经验开发 App。React Native 只需使用 JavaScript 就能编写移动原生应用，它和 React 的设计理念是一样的，因此可以毫不夸张地说：你如果会写 React，就会写 React Native!<br>原生体验：由于 React Native 提供的组件是对原生 API 的暴露，虽然我们使用的是 JavaScript 语言编写的代码，但是实际上是调用了原生的 API 和原生的 UI 组件。因此，体验和性能足以媲美原生应用。<br>热更新：React Native 开发的应用支持热更新，因为 React Native 的产物是 bundle 文件，其实本质上就是 JS 代码，在 App 启动的时候就会去服务器上获取 bundle 文件，我们只需要更新 bundle 文件，从而使得 App 不需要重新前往商店下载包体就可以进行版本更新，开发者可以在用户无感知的情况下进行功能迭代或者 bug 修复。但是值得注意的是，AppStore 禁止热更新的功能中有调用私有 API、篡改原生代码和改变 App 的行为</p><span id="more"></span><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><h4 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h4><p>JavaScriptCore 是 JavaScript 引擎，通常会被叫做虚拟机，专门设计来解释和执行 JavaScript 代码。在 React Native 里面，JavaScriptCore 负责 bundle 产出的 JS 代码的解析和执行。</p><h4 id="JS-Engine"><a href="#JS-Engine" class="headerlink" title="JS Engine"></a>JS Engine</h4><p>React Native 需要一个 JS 的运行环境，因为 React Native 会把应用的 JS 代码编译成一个 JS 文件（x x.bundle），React Native 框架的目标就是解释运行这个 JS 脚本文件，如果是 Native 拓展的 API，则直接通过 bridge 调用 Native 方法</p><h4 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h4><p>在 React Native 中，原生端和 JavaScript 交互是通过 Bridge 进行的，Bridge 的作用就是给 React Native 内嵌的 JS Engine 提供原生接口的扩展供 JS 调用。理论上，任何原生代码能实现的效果都可以通过 Bridge 封装成 JS 可以调用的组件和方法, 以 JS 模块的形式提供给 RN 使用。</p><p><img src="/2023/09/11/ReactNative%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/pic1.png"><br>绿色的是我们应用开发的部分，我们写的代码基本上都是在这一层。<br>蓝色代表公用的跨平台的代码和工具引擎，一般我们不会动蓝色部分的代码。<br>黄色代表平台相关的 bridge 代码，做定制化的时候会添加修改代码。<br>红色代表系统平台的功能，另外红色上面有一个虚线，表示所有平台相关的东西都通过 bridge 隔离开来了，红色部分是独立于 React Native 的。</p><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><ol><li><p>减少 re-render</p></li><li><p>React.memo<br>React.memo 是 React v16.6 中引入的新功能，是一个专门针对 React 函数组件的高阶组件。当想要避免子组件不必要的重新渲染（即便父组件发生了更改），你可以使用 React.memo 打包子组件 – 只要 props 不发生改变，就不会重复渲染。<br>默认情况下，它和 PureComponent 一样，都是进行浅比较，因为就是个高阶组件，在原有的组件上套一层就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const MemoButton = React.memo(function Button(props) &#123;</span><br><span class="line">return &lt;button color=&#123;this.props.color&#125; /&gt;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果想和 shouldComponentUpdate 一样，自定义比较过程，React.memo 还支持传入自定义比较函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Button(props) &#123;</span><br><span class="line">return &lt;button color=&#123;this.props.color&#125; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function areEqual(prevProps, nextProps) &#123;</span><br><span class="line">if (prevProps.color !== nextProps.color) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">export default React.memo(MyComponent, areEqual)</span><br></pre></td></tr></table></figure><p>值得注意的是，areEqual() 这个函数的返回值和 shouldComponentUpdate 正好相反，如果 props 相等，areEqual() 返回的是 true，shouldComponentUpdate 却返回的是 false。</p></li><li><p>React.useMemo</p></li><li><p>React.userCallback</p></li></ol><h4 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h4><ol><li>使用 react-native-fast-image 替代原有的 Image 组件<br>它的底层用的是 🔗 iOS 的 SDWebImage 和 🔗 Android 的 Glide 。这两个明星图片下载管理库，原生开发同学肯定很熟悉，在缓存管理，加载优先级和内存优化上都有不错的表现。而且这些属性都是双平台可用，这个库都封装好了，但是官网上只有基础功能的安装和配置，如果想引入一些功能（比如说支持 WebP），还是需要查看 SDWebImage 和 Glide 的文档的。<br>使用 WebP<br>使用 webP 同样的视觉效果，图片体积会明显减少。而且可以显著减小 CodePush 热更新包的体积（热更新包里，图片占用 90% 以上的体积）。<br>虽然 WebP 在前端解压耗时可能会多一点点，但是考虑到传输体积缩小会缩短网络下载时间，整体的收益还是不错的。</li><li>图床定制图片<br>一般比较大的企业都有内建图床和 CDN 服务，会提供一些自定制图片的功能，比如说指定图片宽高，控制图片质量。借用云端图片定制功能，前端可以轻松通过控制 URL 参数控制图片属性。</li></ol><h4 id="创建和调用分离"><a href="#创建和调用分离" class="headerlink" title="创建和调用分离"></a>创建和调用分离</h4><p>对象创建和调用分离，其实更多的是一种编码习惯。<br>我们知道在 JavaScript 里，啥都是对象，而在 JS 引擎里，创建一个对象的时间差不多是调用一个已存在对象的 10 多倍。在绝大部分情况下，这点儿性能消耗和时间消耗根本不值一提。但在这里还是要总结一下，因为这个思维习惯还是很重要的。</p><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>常见的优化方案主要分为三个方向<br>缩：缩小 Bundle 的总体积，减少 JS 加载和解析的时间<br>延：动态导入（dynamic import），懒加载，按需加载，延迟执行<br>拆：拆分公共模块和业务模块，避免公共模块重复引入<br>但是 React Native 的打包工具不是 webpack 而是 Facebook 自研的 Metro，虽然配置细节不一样，但道理是相通的</p><h4 id="减小-JS-Bundle-体积"><a href="#减小-JS-Bundle-体积" class="headerlink" title="减小 JS Bundle 体积"></a>减小 JS Bundle 体积</h4><p>Metro 打包 JS 时，会把 ESM 模块转为 CommonJS 模块，这就导致现在比较火的依赖于 ESM 的 Tree Shaking 完全不起作用，而且根据官方回复，Metro 未来也不会支持 Tree Shaking ，因为这个原因，我们减小 bundle 体积主要是三个方向：<br>对于同样的功能，优先选择体积更小的第三方库<br>利用 babel 插件，避免全量引用<br>制定编码规范，减少重复代码<br>使用 react-native-bundle-visualizer 查看包体积<br>使用 babel-plugin-import 对包进行按需引入<br>使用 babel-plugin-transform-remove-console 在打包发布的时候移除 console 语句，减小包体积的同时还会加快 JS 运行速度<br>代码的抽象和复用：代码中重复的逻辑根据可复用程度，尽量抽象为一个方法，不要用一次复制一次<br>删除无效的逻辑：这个也很常见，随着业务的迭代，很多代码都不会用了，如果某个功能下线了，就直接删掉，哪天要用到再从 git 记录里找<br>删除冗余的样式：例如引入 ESLint plugin for React Native，开启 “react-native/no-unused-styles” 选项，借助 ESLint 提示无效的样式文件</p><h4 id="Inline-Requires"><a href="#Inline-Requires" class="headerlink" title="Inline Requires"></a>Inline Requires</h4><p>Inline Requires 可以理解为懒执行，注意我这里说的不是懒加载，因为一般情况下，RN 容器初始化之后会全量加载解析 JS Bundle 文件，Inline Requires 的作用是延迟运行，也就是说只有需要使用的时候才会执行 JS 代码，而不是启动的时候就执行。React Native 0.64 版本里，默认开启了 Inline Requires 。<br>值得注意的是，Metro 的自动 Inline Requires 配置，目前是不支持 export default 导出的，这个需要特别注意一下，社区也有相关的文章，呼吁大家不要用 export default 这个语法，感兴趣的可以了解一下</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;特点&lt;br&gt;跨平台：React Native 使用了 Virtual DOM(虚拟 DOM)，只需编写一套代码，便可以将代码打包成不同平台的 App，极大提高了开发效率，并且相对全部原生开发的应用来说，维护成本也相对更低。&lt;br&gt;上手快：相比于原生开发，JavaScript 学习成本低、语法灵活。允许让 Web 开发者更多地基于现有经验开发 App。React Native 只需使用 JavaScript 就能编写移动原生应用，它和 React 的设计理念是一样的，因此可以毫不夸张地说：你如果会写 React，就会写 React Native!&lt;br&gt;原生体验：由于 React Native 提供的组件是对原生 API 的暴露，虽然我们使用的是 JavaScript 语言编写的代码，但是实际上是调用了原生的 API 和原生的 UI 组件。因此，体验和性能足以媲美原生应用。&lt;br&gt;热更新：React Native 开发的应用支持热更新，因为 React Native 的产物是 bundle 文件，其实本质上就是 JS 代码，在 App 启动的时候就会去服务器上获取 bundle 文件，我们只需要更新 bundle 文件，从而使得 App 不需要重新前往商店下载包体就可以进行版本更新，开发者可以在用户无感知的情况下进行功能迭代或者 bug 修复。但是值得注意的是，AppStore 禁止热更新的功能中有调用私有 API、篡改原生代码和改变 App 的行为&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>merge和rebase</title>
    <link href="https://wine1.github.io/2023/09/11/merge%E5%92%8Crebase/"/>
    <id>https://wine1.github.io/2023/09/11/merge%E5%92%8Crebase/</id>
    <published>2023-09-11T13:31:01.000Z</published>
    <updated>2023-09-11T13:37:46.465Z</updated>
    
    <content type="html"><![CDATA[<p>merge 操作会生成新的合并节点，并保留原本的分支记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge main</span><br></pre></td></tr></table></figure><p><img src="/2023/09/11/merge%E5%92%8Crebase/pic1.png"></p><p>git rebase<br>rebase 操作会将功能分支合并到主分支中，并且不产生新的合并节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p><img src="/2023/09/11/merge%E5%92%8Crebase/pic2.png"></p><p>git rebase 和 git merge 的区别<br>rebase 会把你当前分支的 commit 放到公共分支的最后面,所以叫变基。就好像你从公共分支又重新拉出来这个分支一样。<br>而 merge 会把公共分支和你当前的 commit 合并在一起，形成一个新的 commit 提交</p><p>git rebase 和 git merge 的优缺点<br>git merge 优点是分支代码合并后不破坏原分支代码的提交记录，缺点是会产生额外的提交记录并进行两条分支的合并<br>git rebase 优点是可以将对象分支的提交记录续道目标分支上，形成线性提交历史记录，review 时更加直观</p><p>使用 git rebase 的黄金法则 🌿<br>就是不要再公共分支执行 git rebase<br><img src="/2023/09/11/merge%E5%92%8Crebase/pic3.png"></p><p>Rebase 将 main 中的所有提交移到了 feature 的顶端。问题是，这只发生在你的版本库里。所有其他的开发者仍在使用原来的 main。由于重定会产生全新的提交，Git 会认为你的主干分支的历史已经与其他人的不同了。<br>同步两个主分支的唯一方法是将它们 merge 到一起，这样就会产生一个额外的合并提交和两组包含相同修改的提交（原始提交和来自你的重构分支的提交）。不用说，这是一个非常混乱的局面。<br>所以，在你运行 git rebase 之前，一定要问自己，”还有人在看这个分支吗？”如果答案是肯定的，就把你的手从键盘上拿开，开始考虑其他方式来合并修改。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;merge 操作会生成新的合并节点，并保留原本的分支记录&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s</summary>
      
    
    
    
    
    <category term="git" scheme="https://wine1.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端设计模式</title>
    <link href="https://wine1.github.io/2023/07/13/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://wine1.github.io/2023/07/13/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-13T14:49:26.000Z</published>
    <updated>2023-09-11T13:12:36.941Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。<br>简单来说 它是一套被反复使用、多人知晓的、经过分类的、代码设计经验总结。</p><span id="more"></span><h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><p>单一职责原则：就是功能要单一，简而言之就是一个类负责做一件事情。<br>开放封闭原则：对扩展开放，对修改关闭。<br>里氏替换原则：基类出现的地方，子类一定出现，不要破坏继承体系。<br>接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>依赖翻转原则：针对接口编程，依赖抽象而不依赖具体。<br>合成复用原则：少用继承，多用合成方式实现。</p><h3 id="前端常用设计模式"><a href="#前端常用设计模式" class="headerlink" title="前端常用设计模式"></a>前端常用设计模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。<br>主要解决：一个全局使用的类频繁地创建与销毁。<br>何时使用：当您想控制实例数目，节省系统资源的时候。<br>如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。<br>关键代码：构造函数是私有的。<br>常见实现方法，该方法在多线程的状态下不能正常工作，但是 js 是单线程工作，所以不用考虑这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"> private static Singleton instance;</span><br><span class="line"> private Singleton ()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。<br>主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。<br>何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。<br>如何解决：使用面向对象技术，可以将这种依赖关系弱化。<br>关键代码：在抽象类里有一个 ArrayList 存放观察者们。</p><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p>其实 24 种基本的设计模式中并没有发布订阅模式，它只是观察者模式的一个别称。<br>但是经过时间的沉淀，似乎它已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。<br>在现在的发布订阅模式中，称为发布者的消息发送者不会将消息直接发送给订阅者，这意味着发布者和订阅者不知道彼此的存在。在发布者和订阅者之间存在第三个组件，称为调度中心或事件通道，它维持着发布者和订阅者之间的联系，过滤所有发布者传入的消息并相应地分发它们给订阅者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const EventEmit = function() &#123;</span><br><span class="line">  this.events = &#123;&#125;;</span><br><span class="line">  this.on = function(name, cb) &#123;</span><br><span class="line">    if (this.events[name]) &#123;</span><br><span class="line">      this.events[name].push(cb);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.events[name] = [cb];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  this.trigger = function(name, ...arg) &#123;</span><br><span class="line">    if (this.events[name]) &#123;</span><br><span class="line">      this.events[name].forEach(eventListener =&gt; &#123;</span><br><span class="line">        eventListener(...arg);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>主要解决：在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。<br>何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。<br>如何解决：将这些算法封装成一个一个的类，任意地替换。<br>关键代码：实现同一个接口。<br>举个 🌰 : 表单验证中，要校验不同的规则，如果通过条件判断代码就会非常难以理解和维护，换成以下策略模式实现的方法，更加简洁明了<br><img src="/2023/07/13/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/pic1.png" alt="tu"><br>使用的时候，调用不同的类方法</p><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。<br>装饰器模式通过将对象包装在装饰器类中，以便动态地修改其行为。<br>在前端中的应用 举个 🌰: HOC<br>定义一个黄色背景的高阶组件，既不影响子组件的结构，又拓展了组件的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">const yellowHOC = WrapperComponent =&gt; &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      &lt;div style=&#123;&#123; backgroundColor: &#x27;yellow&#x27; &#125;&#125;&gt;</span><br><span class="line">        &lt;WrapperComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default yellowHOC;</span><br><span class="line"></span><br><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import yellowHOC from &#x27;./yellowHOC&#x27;;</span><br><span class="line"></span><br><span class="line">class TargetComponent extends Reac.Compoment &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;66666&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default yellowHOC(TargetComponent);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是设计模式&quot;&gt;&lt;a href=&quot;#什么是设计模式&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式&quot;&gt;&lt;/a&gt;什么是设计模式&lt;/h3&gt;&lt;p&gt;设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;br&gt;简单来说 它是一套被反复使用、多人知晓的、经过分类的、代码设计经验总结。&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="工程" scheme="https://wine1.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative开发App</title>
    <link href="https://wine1.github.io/2023/07/12/ReactNative%E5%BC%80%E5%8F%91App/"/>
    <id>https://wine1.github.io/2023/07/12/ReactNative%E5%BC%80%E5%8F%91App/</id>
    <published>2023-07-12T00:38:47.000Z</published>
    <updated>2023-09-11T13:29:59.285Z</updated>
    
    <content type="html"><![CDATA[<p>一年多没有更新博客 经历了 22 年上海三月到五月的封控，辞掉了之前的工作。六月解封之后就火速跑到了杭州，换了新的工作，一直到现在。</p><p>近一年一直在做物联网 iot 工业互联网相关的事情<br>做了快一年的 app 多少也算是有一些收获，整理一下，也算是对这个项目的一个总结</p><span id="more"></span><p>背景：组里有做 app 的需求，又没有专门做 native App 的开发人员，所以就选择了用跨端框架来实现，因为做过 react native 又对 flutter 不熟悉，所以顺理成章的选择了这个技术栈。 中间经历很多，活了很多时间在了解一些规则和配置方法上，在这里记录一下，说不定后面忘了还可以回头看看</p><p>RN 项目构建<br><a href="https://reactnative.cn/docs/environment-setup">官网</a>有比较详细的环境安装和项目构建教程</p><p>打包配置：</p><h3 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h3><p>ios 打包需要以下文件：</p><ul><li><p>开发者账号的签名证书 signing certificate (一套签名：包含证书.cert 和私钥.p12 两个文件)</p></li><li><p>应用的签名文件 provision (一般文件后缀.mobileprovision)</p></li></ul><p>同一个开发者账户开发的多个 App 可已共用一个证书</p><p>私钥(p12)需要安装在开发者电脑上</p><p><img src="/2023/07/12/ReactNative%E5%BC%80%E5%8F%91App/pic1.png"></p><p><img src="/2023/07/12/ReactNative%E5%BC%80%E5%8F%91App/pic2.png"></p><h3 id><a href="#" class="headerlink" title></a></h3><p><img src="/2023/07/12/ReactNative%E5%BC%80%E5%8F%91App/pic3.png"></p><h3 id="android"><a href="#android" class="headerlink" title="android"></a>android</h3><ol><li><p>生成一个签名密钥</p></li><li><p>设置 gradle 变量<a href="https://reactnative.cn/docs/signed-apk-android#%E8%AE%BE%E7%BD%AE-gradle-%E5%8F%98%E9%87%8F" title="标题的直接链接">​</a></p><ol><li><p>把<code>my-release-key.keystore</code>文件放到你工程中的<code>android/app</code>文件夹下。</p></li><li><p>编辑<code>~/.gradle/gradle.properties</code>（全局配置，对所有项目有效）或是<code>项目目录/android/gradle.properties</code>（项目配置，只对所在项目有效）。如果没有<code>gradle.properties</code>文件你就自己创建一个，添加如下的代码（注意把其中的<code>****</code>替换为相应密码）</p></li><li><p>注意：~符号表示用户目录，比如 windows 上可能是<code>C:\Users\用户名</code>，而 mac 上可能是<code>/Users/用户名</code>。</p></li></ol></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MYAPP_RELEASE_STORE_FILE=my-release-key.keystore</span><br><span class="line">MYAPP_RELEASE_KEY_ALIAS=my-key-alias</span><br><span class="line">MYAPP_RELEASE_STORE_PASSWORD=*****</span><br><span class="line">MYAPP_RELEASE_KEY_PASSWORD=*****</span><br></pre></td></tr></table></figure><ol><li>把签名配置加入到项目的 gradle 配置中</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    defaultConfig &#123; ... &#125;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            if (project.hasProperty(&#x27;MYAPP_RELEASE_STORE_FILE&#x27;)) &#123;</span><br><span class="line">                storeFile file(MYAPP_RELEASE_STORE_FILE)</span><br><span class="line">                storePassword MYAPP_RELEASE_STORE_PASSWORD</span><br><span class="line">                keyAlias MYAPP_RELEASE_KEY_ALIAS</span><br><span class="line">                keyPassword MYAPP_RELEASE_KEY_PASSWORD</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            ...</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol><li>生成发行安装包</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd android</span><br><span class="line">./gradlew bundleRelease</span><br></pre></td></tr></table></figure><p>生成的文件位于<code>android/app/build/outputs/apk/release/app-release.ap</code></p><h2 id="RN-内测"><a href="#RN-内测" class="headerlink" title="RN 内测"></a>RN 内测</h2><ol><li>挂载到网站上 进行内测分发</li></ol><p><strong><a href="https://www.pgyer.com/">https://www.pgyer.com/</a></strong></p><p>可以挂载到上述网站 需要注意的是 ios 需要上传指定测试手机的 udid 才能安装测试包</p><h2 id="RN-上架-App-Store"><a href="#RN-上架-App-Store" class="headerlink" title="RN 上架 App Store"></a>RN 上架 App Store</h2><h3 id="ios-上架"><a href="#ios-上架" class="headerlink" title="ios 上架"></a>ios 上架</h3><ol><li> 在 xcode 中 打开 window =&gt; organizer 选择要发布的 App，然后点击 Distribute App.</li><li>选择 App Store Connect 发布到 AppStore<br> <img src="/2023/07/12/ReactNative%E5%BC%80%E5%8F%91App/pic4.png"></li><li>选择语言 中文简体<br> <img src="/2023/07/12/ReactNative%E5%BC%80%E5%8F%91App/pic5.png"></li><li>点击 upload 上传<br> <img src="/2023/07/12/ReactNative%E5%BC%80%E5%8F%91App/pic6.png"></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;一年多没有更新博客 经历了 22 年上海三月到五月的封控，辞掉了之前的工作。六月解封之后就火速跑到了杭州，换了新的工作，一直到现在。&lt;/p&gt;
&lt;p&gt;近一年一直在做物联网 iot 工业互联网相关的事情&lt;br&gt;做了快一年的 app 多少也算是有一些收获，整理一下，也算是对这个项目的一个总结&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="ReactNative" scheme="https://wine1.github.io/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>常见网络问题总结</title>
    <link href="https://wine1.github.io/2022/05/09/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>https://wine1.github.io/2022/05/09/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-09T02:08:11.000Z</published>
    <updated>2022-05-17T05:54:37.730Z</updated>
    
    <content type="html"><![CDATA[<p>搜集自网络的一些常见网络问题</p><span id="more"></span><ol><li><p>网络分层结构<br>应用层：为应用程序提供交互服务。<br>传输层：负责向两台主机进程之间的通信提供数据传输服务。传输层的协议主要有传输控制协议 TCP 和用户数据协议 UDP。<br>网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括 IP 协议。<br>数据链路层：在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。<br>物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和物理设备的差异。</p></li><li><p>三次握手</p><ol><li>服务端向客户端发送建立连接请求。客户端随机生成一个起始序列号 x,</li><li>服务端收到消息后向客户端发送确认连接请求</li><li></li></ol></li><li><p>两次握手可以吗？</p></li><li><p>四次挥手</p></li><li><p>第四次挥手为什么要等待 2MSL？</p></li><li><p>为什么是四次挥手？</p></li><li><p>TCP 有哪些特点？</p></li><li><p>TCP 和 UDP 的区别？</p></li><li><p>HTTP 协议的特点？</p></li><li><p>HTTP 报文格式</p></li><li><p>HTTP 状态码有哪些？</p></li><li><p>HTTP1.0 和 HTTP1.1 的区别?</p></li><li><p>HTTP1.1 和 HTTP2.0 的区别？</p></li><li><p>HTTPS 与 HTTP 的区别？</p></li><li><p>什么是数字证书？</p></li><li><p>HTTPS 原理</p></li><li><p>DNS 的解析过程？</p></li><li><p>浏览器中输入 URL 返回页面过程？</p></li><li><p>Cookie 和 Session 的区别？</p></li><li><p>什么是对称加密和非对称加密？</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;搜集自网络的一些常见网络问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="网络" scheme="https://wine1.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>封装axios</title>
    <link href="https://wine1.github.io/2022/04/13/%E5%B0%81%E8%A3%85axios/"/>
    <id>https://wine1.github.io/2022/04/13/%E5%B0%81%E8%A3%85axios/</id>
    <published>2022-04-13T05:21:21.000Z</published>
    <updated>2022-04-13T05:21:34.719Z</updated>
    
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="https://wine1.github.io/2022/01/11/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://wine1.github.io/2022/01/11/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2022-01-11T03:02:40.000Z</published>
    <updated>2022-05-17T14:24:41.547Z</updated>
    
    <content type="html"><![CDATA[<p>react + node 实现文件上传</p><span id="more"></span><p>node 端接收并转存文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static updateUserAvatar = async (ctx: any) =&gt; &#123;</span><br><span class="line">    const file = ctx.request.files.file || &#123;&#125;</span><br><span class="line">    let code = 0, data = &#123;&#125;, message = &#x27;&#x27;</span><br><span class="line">    if (file) &#123;</span><br><span class="line">        let filePath = path.join(__dirname, &#x27;../../&#x27;, &#x27;public/upload/&#x27;) + `/$&#123;file.name&#125;`;</span><br><span class="line">        // 创建可写流</span><br><span class="line">        const upStream = fs.createWriteStream(filePath);</span><br><span class="line">        const reader = fs.createReadStream(file.path)</span><br><span class="line">        // 可读流通过管道写入可写流</span><br><span class="line">        reader.pipe(upStream);</span><br><span class="line">        message = &quot;上传成功！&quot;;</span><br><span class="line">        data = &#123; path: `/public/upload/$&#123;file.name&#125;` &#125;</span><br><span class="line">        code = 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        message = &quot;上传图片失败！&quot;;</span><br><span class="line">        data = &#123;&#125;</span><br><span class="line">        code = 1</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        code,</span><br><span class="line">        data,</span><br><span class="line">        message</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端有两种方案</p><ol><li>用 form 表单<br>form 上传 利用 form 表单的 enctype 属性可以把表单提交的对象设置为多媒体资源，然后通过 inuput:file 就可以实现文件上传的功能<br>这个方法相对便捷有效而且还不用考虑跨域的问题，毕竟我们上传的文件终究还是要访问 API 接口；不过这种方法还有一个不方便的地方，就是 form 表单会<strong>默认跳转也就是会在浏览器访问你所提交文件的那个接口</strong>，这个行为处理起来很麻烦。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;http://localhost:8088/api/user/updateUserAvatar&quot; method=&quot;post&quot; encType=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;file&quot; name=&quot;file&quot; value=&#x27;&#x27; onChange=&#123;(e: any) =&gt; handleFileChange(e)&#125; /&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>用 xhr 自己发送<br>自己发送时会遇到跨域问题，后端解决</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot; onChange=&#123;(e: any) =&gt; handleFileChange(e)&#125; /&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;提交&quot; onClick=&#123;submit&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    const [fileValue, setFileValue] = useState(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    const handleFileChange = (e: any) =&gt; &#123;</span><br><span class="line">        const file = e.target.files</span><br><span class="line">        const data = new FormData()</span><br><span class="line">        data.append(&#x27;file&#x27;, file[0])</span><br><span class="line">        setFileValue(data)</span><br><span class="line">    &#125;</span><br><span class="line">    const submit = async () =&gt; &#123;</span><br><span class="line">        const res = await newApi.upload(&#123; data: fileValue &#125;)</span><br><span class="line">        console.log(111, res)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>node 端的跨域处理</p><ol><li>koa2-cors</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install koa2-cors --save</span><br><span class="line">const cors = require(&#x27;koa2-cors&#x27;);</span><br><span class="line">app.use(cors())</span><br></pre></td></tr></table></figure><ol start="2"><li>自己写一个中间件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx: any, next: any) =&gt; &#123;</span><br><span class="line">  ctx.set(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);</span><br><span class="line">  ctx.set(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;);</span><br><span class="line">  ctx.set(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;);</span><br><span class="line">  if (ctx.method == &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">    ctx.body = 200;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    await next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于登录鉴权</p><p>如果两种场景都有，怎么封装组件</p><p>大文件上传<br>断点续传<br>h h h h h h h h h h h<br>gy</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;react + node 实现文件上传&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>node项目中使用typescript</title>
    <link href="https://wine1.github.io/2021/12/10/node%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8typescript/"/>
    <id>https://wine1.github.io/2021/12/10/node%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8typescript/</id>
    <published>2021-12-10T10:43:43.000Z</published>
    <updated>2021-12-22T02:34:01.889Z</updated>
    
    <content type="html"><![CDATA[<p>写一个 node 项目，写着写着觉得 ts 在 node 的场景里应该会更加如鱼得水</p><span id="more"></span><p>首先安装一个 ts 如果没有装的话<br><code>npm install -g typescript</code></p><p>在项目下 执行 <code>tsc --init</code>以生成 tsconfig.json 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    // &quot;incremental&quot;: true,                   /* 增量编译 提高编译速度*/</span><br><span class="line">    &quot;target&quot;: &quot;ES2019&quot;,                       /* 编译目标ES版本*/</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                     /* 编译目标模块系统*/</span><br><span class="line">    // &quot;lib&quot;: [],                             /* 编译过程中需要引入的库文件列表*/</span><br><span class="line">    &quot;declaration&quot;: true,                      /* 编译时创建声明文件 */</span><br><span class="line">    &quot;outDir&quot;: &quot;dist&quot;,                         /* ts编译输出目录 */</span><br><span class="line">    &quot;rootDir&quot;: &quot;src&quot;,                         /* ts编译根目录. */</span><br><span class="line">    // &quot;importHelpers&quot;: true,                 /* 从tslib导入辅助工具函数(如__importDefault)*/</span><br><span class="line">    &quot;strict&quot;: true,                           /* 严格模式开关 等价于noImplicitAny、strictNullChecks、strictFunctionTypes、strictBindCallApply等设置true */</span><br><span class="line">    &quot;noUnusedLocals&quot;: true,                   /* 未使用局部变量报错*/</span><br><span class="line">    &quot;noUnusedParameters&quot;: true,               /* 未使用参数报错*/</span><br><span class="line">    &quot;noImplicitReturns&quot;: true,                /* 有代码路径没有返回值时报错*/</span><br><span class="line">    &quot;noFallthroughCasesInSwitch&quot;: true,       /* 不允许switch的case语句贯穿*/</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,               /* 模块解析策略 */</span><br><span class="line">    &quot;typeRoots&quot;: [                            /* 要包含的类型声明文件路径列表*/</span><br><span class="line">      &quot;./typings&quot;,</span><br><span class="line">      &quot;./node_modules/@types&quot;</span><br><span class="line">      ],</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: false,    /* 允许从没有设置默认导出的模块中默认导入，仅用于提示，不影响编译结果*/</span><br><span class="line">    &quot;esModuleInterop&quot;: false,                /* 允许编译生成文件时，在代码中注入工具类(__importDefault、__importStar)对ESM与commonjs混用情况做兼容处理*/</span><br><span class="line">    &quot;watch&quot;:true                            /** 监听ts文件变化并自动更新 */</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;: [                                /* 需要编译的文件 */</span><br><span class="line">    &quot;src/**/*.ts&quot;,</span><br><span class="line">    &quot;typings/**/*.ts&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;: [                                /* 编译需要排除的文件 */</span><br><span class="line">    &quot;node_modules/**&quot;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置文件注意点<br>“module”是用来指定设置编译后的 js 代码，使用何种模块规范。由于是开发 node.js 项目，所以选择 commonjs。(有兴趣的话，可以把所有 module 所有可能的值都试一遍，查看编译后的 js 文件的差别，会发现生成的代码还是很不错的，很干净。)</p><p>“target”是编译后的 js 代码遵循何种规范，可以是 es3/es5/es6 等等，这里为了对比 ts 2.0 代码和 es6 代码的不同，使用了”es6”。</p><p>“rootDir”是一个需要注意的地方，它会告诉编译器，此目录下的文件需要经过编译。那么，如果设置了这个选项，又在外部（比如根目录）放置了.ts 文件，会怎么样呢？tsc 会提示一条类似这样的错误：</p><p>生成.d.ts 文件<br>xx.d.ts 声明文件，来说明模块对外公开的方法和属性的类型以及内容。<br><code>npm install --save-dev @types/node</code></p><p>安装 nodemon 以及 ts-node 用于监控 指定目录 ts 代码的改动，改动后自动编译运行项目。<br>// 仅开发环境安装<br><code>npm install --save-dev nodemon</code> // nodemon 用来监视 node.js 应用程序中的任何更改并自动重启服务<br><code>npm install --save-dev ts-node</code> // ts-node 命令可直接执行 TypeScript 源文件而不需要预先编译</p><p>package.json<br>script 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;start&quot;: &quot;nodemon ./index.ts&quot;,</span><br><span class="line">&quot;watch&quot;: &quot;tsc&quot; //tsconfig中配置 watch:true</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;写一个 node 项目，写着写着觉得 ts 在 node 的场景里应该会更加如鱼得水&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="工程化" scheme="https://wine1.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>react组件通信</title>
    <link href="https://wine1.github.io/2021/06/24/react%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>https://wine1.github.io/2021/06/24/react%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</id>
    <published>2021-06-24T15:50:33.000Z</published>
    <updated>2021-06-24T15:57:11.782Z</updated>
    
    <content type="html"><![CDATA[<p>react中 props是不可更改的 所以在子组件中 想要更改父组件传进来的props 只能把它先赋值给state<br>例如</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">      super(props)</span><br><span class="line">      this.state= &#123;</span><br><span class="line">          stateList:this.props.list</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后就是要在父组件更新的时候 同步通知到子组件<br>网上搜到最多的就是<code>componentWillReceiveProps</code>这个钩子函数<br>目前还是能用 但是官方文档已经建议废弃这个用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(props) &#123;</span><br><span class="line">   this.setState(&#123;</span><br><span class="line">    stateList:props.list</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转而使用这个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static getDerivedStateFromProps(nextProps,preState) &#123;</span><br><span class="line">    console.log(nextProps,preState)</span><br><span class="line">    if(nextProps.list!==preState.stateList) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            stateList:[...nextProps.list]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;react中 props是不可更改的 所以在子组件中 想要更改父组件传进来的props 只能把它先赋值给state&lt;br&gt;例如&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="react" scheme="https://wine1.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>用createReactApp创建项目之后的配置</title>
    <link href="https://wine1.github.io/2021/06/03/%E7%94%A8createReactApp%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>https://wine1.github.io/2021/06/03/%E7%94%A8createReactApp%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%B9%8B%E5%90%8E%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2021-06-03T11:09:16.000Z</published>
    <updated>2021-06-03T11:19:17.343Z</updated>
    
    <content type="html"><![CDATA[<p>在用<a href="https://github.com/facebook/create-react-app">create-react-app</a>创建一个新的react项目之后<br>会发现package.json里面没有webpack 这是因为 用这个脚手架创建的项目 webpack相关配置都被集成在 react-scripts中了<br>脚手架本身提供了 ejest 来把webpack相关配置暴露出来 但是这个过程是不可逆的 弹出配置后，你将无法跟随官方的脚步去升级项目的 react-script 版本 谨慎操作 反正我没操作<br>如果我们想自己加一些配置 可以通过craco实现</p><span id="more"></span><ol><li><p>安装包<br><code>yarn add @craco/craco</code></p></li><li><p>项目根目录创建 craco.config.js 文件</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* craco.config.js */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 package.json 的 scripts 命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* package.json */</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">-   &quot;start&quot;: &quot;react-scripts start&quot;,</span><br><span class="line">+   &quot;start&quot;: &quot;craco start&quot;,</span><br><span class="line">-   &quot;build&quot;: &quot;react-scripts build&quot;,</span><br><span class="line">+   &quot;build&quot;: &quot;craco build&quot;</span><br><span class="line">-   &quot;test&quot;: &quot;react-scripts test&quot;,</span><br><span class="line">+   &quot;test&quot;: &quot;craco test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在用&lt;a href=&quot;https://github.com/facebook/create-react-app&quot;&gt;create-react-app&lt;/a&gt;创建一个新的react项目之后&lt;br&gt;会发现package.json里面没有webpack 这是因为 用这个脚手架创建的项目 webpack相关配置都被集成在 react-scripts中了&lt;br&gt;脚手架本身提供了 ejest 来把webpack相关配置暴露出来 但是这个过程是不可逆的 弹出配置后，你将无法跟随官方的脚步去升级项目的 react-script 版本 谨慎操作 反正我没操作&lt;br&gt;如果我们想自己加一些配置 可以通过craco实现&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="工程化" scheme="https://wine1.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>webpack多文件打包</title>
    <link href="https://wine1.github.io/2021/05/27/webpack%E5%A4%9A%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/"/>
    <id>https://wine1.github.io/2021/05/27/webpack%E5%A4%9A%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/</id>
    <published>2021-05-27T07:51:13.000Z</published>
    <updated>2022-01-13T08:21:58.288Z</updated>
    
    <content type="html"><![CDATA[<p>webpack 多文件打包系统的配置</p><span id="more"></span><p><img src="/2021/05/27/webpack%E5%A4%9A%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/tu1.png" alt="tu1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">   new CleanWebpackPlugin(),</span><br><span class="line">   new HtmlWebpackPlugin(&#123;</span><br><span class="line">     title: &#x27;test1&#x27;,</span><br><span class="line">     template: path.resolve(__dirname, &#x27;./public/index.html&#x27;),</span><br><span class="line">     chunks: [</span><br><span class="line">       &#x27;page1&#x27;,</span><br><span class="line">     ] /** HtmlWebpackPlugin一定要配chunks，否则所有页面的js都会被注入到当前html里 */,</span><br><span class="line">     filename: &#x27;page1.html&#x27;,</span><br><span class="line">   &#125;),</span><br><span class="line">   new HtmlWebpackPlugin(&#123;</span><br><span class="line">     title: &#x27;test2&#x27;,</span><br><span class="line">     template: path.resolve(__dirname, &#x27;./public/index.html&#x27;),</span><br><span class="line">     chunks: [&#x27;page2&#x27;],</span><br><span class="line">     filename: &#x27;page2.html&#x27;,</span><br><span class="line">   &#125;),</span><br><span class="line">   new MiniCssExtractPlugin(&#123;</span><br><span class="line">     filename: &#x27;[name]/css/[name].[contenthash].css&#x27;,</span><br><span class="line">     chunkFilename: &#x27;[name]/css/[id].[contenthash].css&#x27;,</span><br><span class="line">   &#125;),</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><p><img src="/2021/05/27/webpack%E5%A4%9A%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/tu2.png" alt="tu2"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">   path: path.resolve(__dirname, &#x27;./dist&#x27;),</span><br><span class="line">   filename: &#x27;[name]/js/[name][chunkhash].bundle.js&#x27;,</span><br><span class="line">   chunkFilename: &#x27;[name]/js/[name][chunkhash].bundle.js&#x27;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>打包结果<br><img src="/2021/05/27/webpack%E5%A4%9A%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85/tu3.png" alt="tu3"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;webpack 多文件打包系统的配置&lt;/p&gt;</summary>
    
    
    
    
    <category term="工程化" scheme="https://wine1.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>自己搞一个npm包</title>
    <link href="https://wine1.github.io/2021/05/18/%E8%87%AA%E5%B7%B1%E6%90%9E%E4%B8%80%E4%B8%AAnpm%E5%8C%85/"/>
    <id>https://wine1.github.io/2021/05/18/%E8%87%AA%E5%B7%B1%E6%90%9E%E4%B8%80%E4%B8%AAnpm%E5%8C%85/</id>
    <published>2021-05-18T02:59:26.000Z</published>
    <updated>2021-05-18T05:56:00.617Z</updated>
    
    <content type="html"><![CDATA[<p>搞一个npm包给其他业务部门使用 过程中还是有许多问题的<br>主要是 在测试过程中频繁发布npm包 以及版本迭代太快 业务部门更新不及时</p><span id="more"></span><p>npm打包基础<br>注册一个npm账号<br>npm login<br>npm publish</p><p>打包工具<br>rollup </p><p>打包发布配置<br><a href="https://wine1.github.io/2021/04/25/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85/#more">详见另一个文章</a></p><p>测试方法<br>之前真机测试只要发布测试环境即可，但是现在要先发布npm包，安装npm包，然后再发布测试环境，从一个步骤变成了三个步骤。<br>npm link</p><blockquote><p>npm link可以让项目和要使用的npm包之间建立符号连接。</p></blockquote><p>换句话说，如果在项目A中使用组件包B，之前要把B打包并发布，然后项目A安装B，打包并发布测试环境才能验证，现在只需要B打包一下，A直接打包并发布测试环境即可（A打包时获取的是B在本地的打包文件, 即写在B package.json中的main文件）</p><blockquote><p>而要使用npm link, 要做到如下几步：<br>在B包里：<br>npm link // 相当于npm install B -g<br>在A包里：<br>npm link B // 代码无需修改，package.json中引用B的包会自动指向本地B的打包文件<br>A包发布测试环境测试</p></blockquote><p>版本管理<br>tag</p><blockquote><p>tag可以用来指带版本号，用户可以使用npm install <name>@<tag>安装</tag></name></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;搞一个npm包给其他业务部门使用 过程中还是有许多问题的&lt;br&gt;主要是 在测试过程中频繁发布npm包 以及版本迭代太快 业务部门更新不及时&lt;/p&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="工程化" scheme="https://wine1.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>小程序同层渲染那些坑</title>
    <link href="https://wine1.github.io/2021/05/14/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%8C%E5%B1%82%E6%B8%B2%E6%9F%93%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    <id>https://wine1.github.io/2021/05/14/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%8C%E5%B1%82%E6%B8%B2%E6%9F%93%E9%82%A3%E4%BA%9B%E5%9D%91/</id>
    <published>2021-05-14T09:54:07.000Z</published>
    <updated>2021-05-14T11:54:24.570Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><code>&lt;textarea&gt; &lt;input&gt;</code> 组件的placeholder穿透问题<br>textarea input 上方有元素时 组件输入的内容显示在所有布局的最上面</p><span id="more"></span><p> 解决方案</p><ul><li>input textarea上方元素弹起时 将输入框的内容暂时替换为’’  </li><li>将整个输入框隐藏</li><li>用view标签模拟<code>&lt;textarea&gt;</code>组件，来避免<code>&lt;textarea&gt;</code>组件的placeholder穿透问题</li></ul></li><li><p>live-player组件「同层渲染」失败问题</p></li><li><p>canvas组件「同层渲染」<br>微信小程序从基础库1.0.0开始支持 canvas，2.9.0 起支持一套新 Canvas 2D 接口（需指定 type 属性），同时支持同层渲染，原有接口不再维护<br>canvas的层级最高 会穿透</p></li><li><p>原生组件」无法在 scroll-view、swiper、picker-view、movable-view 中使用，因为如果开发者在可滚动的 DOM 区域，插入「原生组件」作为其子节点，由于「原生组件」是直接插入到 webview 外部的层级，与 DOM 之间没有关联，所以不会跟随移动也不会被裁减。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;textarea&amp;gt; &amp;lt;input&amp;gt;&lt;/code&gt; 组件的placeholder穿透问题&lt;br&gt;textarea input 上方有元素时 组件输入的内容显示在所有布局的最上面&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    
    <category term="前端" scheme="https://wine1.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="小程序" scheme="https://wine1.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>发布一个npm包</title>
    <link href="https://wine1.github.io/2021/04/25/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85/"/>
    <id>https://wine1.github.io/2021/04/25/%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85/</id>
    <published>2021-04-25T11:54:24.000Z</published>
    <updated>2021-04-25T12:11:19.177Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个项目，做sdk给其他业务部门用<br>通过发到内部的npm库 来给大家用</p><span id="more"></span><p>开始是把打包出来的dist文件拷贝出来单独新建一个文件夹发布到npm<br>但是这样就存在很多问题<br>那么如何过滤 npm publish 的文件<br>下面会介绍两种方法</p><ol><li>.npmignore </li><li>在package.json中添加files:[] 如 <code>&quot;files&quot;: [&quot;dist/types&quot;,&quot;dist/index.es5.js&quot;,&quot;dist/index.umd.js&quot;],</code><br>第一个方法和gitignore类似 npm发布时忽略掉配置中的文件<br>第二个方法则相反 只发布配置中的文件</li></ol><p>如果发错了 或者想删掉测试用的包<br>执行命令 <code>npm unpublish xxx --force</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做一个项目，做sdk给其他业务部门用&lt;br&gt;通过发到内部的npm库 来给大家用&lt;/p&gt;</summary>
    
    
    
    
    <category term="工程化" scheme="https://wine1.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
</feed>
