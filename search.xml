<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重排和重绘]]></title>
    <url>%2F2020%2F07%2F14%2F%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98%2F</url>
    <content type="text"><![CDATA[今天一个bug引发了我对重排和重绘的好奇对这个知识点做个系统的了解和总结 DOM的变化引发了原生的几何属性的变化，比如宽高和位置的变化等，属于重排完成重排后，要将重新构建的其他样式（如颜色）渲染到屏幕上，这个过程就是重绘重排必然会引发重绘，但重绘并不一定伴随着重排 重排的触发条件： 添加或者删除可以的DOM元素 元素位置改变 元素本身的尺寸变化 内容改变 页面渲染器初始化 浏览器窗口大小发生改变 重绘和重排的开销是非常昂贵的，如果我们不停的在改变页面的布局，就会造成浏览器耗费大量的开销在进行页面的计算，这样的话，我们页面在用户使用起来，就会出现明显的卡顿。现在的浏览器其实已经对重排进行了优化 1234var div = document.querySelector(&apos;.div&apos;);div.style.width = &apos;200px&apos;;div.style.background = &apos;red&apos;;div.style.height = &apos;300px&apos;; 比较久远的浏览器，这段代码会触发页面2次重排，在分别设置宽高的时候，触发2次.当代的浏览器对此进行了优化，这种思路类似于现在流行的MVVM框架使用的虚拟DOM，对改变的DOM节点进行依赖收集，确认没有改变的节点，就进行一次更新。但是浏览器针对重排的优化虽然思路和虚拟DOM接近，但是还是有本质的区别。大多数浏览器通过队列化修改并批量执行来优化重排过程。也就是说上面那段代码其实在现在的浏览器优化下，只构成一次重排。 除此之外，我们也可以针对性的做一些优化 最小化重排和重绘（把会引起重排和重绘的操作一起操作，尽量只重绘或重排一次） 缓存布局信息 缓存布局信息这个概念，在《高性能JavaScript》DOM性能优化中，多次提到类似的思想. 比如我现在要得到页面ul节点下面的100个li节点，最好的办法就是第一次获取后就保存起来，减少]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node+koa]]></title>
    <url>%2F2020%2F06%2F23%2Fnode-koa%2F</url>
    <content type="text"><![CDATA[koa+node基础搭建到实现api接口 https://www.jianshu.com/p/3b60dda108d4 使用pm2管理node进程 使用knex操作数据库]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序+腾讯云实时音视频]]></title>
    <url>%2F2020%2F06%2F23%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E8%85%BE%E8%AE%AF%E4%BA%91%E5%AE%9E%E6%97%B6%E9%9F%B3%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[小程序加腾讯云实时音视频 腾讯实时音视频官方demo，IOS微信小程序端不显示本地和远程画面？ 在 app.json 下 window 下配置一下 “renderingMode”: “seperated”强制关掉同层]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js遍历]]></title>
    <url>%2F2020%2F06%2F12%2Fjs%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[foreach和map的区别 foreachforeach没有返回值 map映射 跟foreach用法类似 返回一个新数组]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[touch-action]]></title>
    <url>%2F2020%2F06%2F12%2Ftouch-action%2F</url>
    <content type="text"><![CDATA[touch-action用于设置触摸屏用户如何操纵元素的区域 可选的属性值 auto 当触控事件发生在元素上时，由浏览器来决定进行哪些操作，比如对viewport进行平滑、缩放等。 none 当触控事件发生在元素上时，不进行任何操作。 pan-x 启用单指水平平移手势。可以与 pan-y 、pan-up、pan-down 和／或 pinch-zoom 组合使用。 pan-y 启用单指垂直平移手势。可以与 pan-x 、pan-left 、pan-right 和／或 pinch-zoom 组合使用。 manipulation 浏览器只允许进行滚动和持续缩放操作。任何其它被auto值支持的行为不被支持。启用平移和缩小缩放手势，但禁用其他非标准手势，例如双击以进行缩放。 禁用双击可缩放功能可减少浏览器在用户点击屏幕时延迟生成点击事件的需要。 这是“pan-x pan-y pinch-zoom”（为了兼容性本身仍然有效）的别名。 pan-left, pan-right,pan-up,pan-down 启用以指定方向滚动开始的单指手势。 一旦滚动开始，方向可能仍然相反。 请注意，滚动“向上”（pan-up）意味着用户正在将其手指向下拖动到屏幕表面上，同样 pan-left 表示用户将其手指向右拖动。 多个方向可以组合，除非有更简单的表示（例如，“pan-left pan-right”无效，因为“pan-x”更简单，而“pan-left pan-down”有效）。 pinch-zoom 启用多手指平移和缩放页面。 这可以与任何平移值组合。 应用场景：将touch-action改为manipulation可以减少移动端浏览器在用户点击事件的延迟]]></content>
  </entry>
  <entry>
    <title><![CDATA[css3实现加载图标]]></title>
    <url>%2F2020%2F06%2F12%2Fcss3%E5%AE%9E%E7%8E%B0%E5%8A%A0%E8%BD%BD%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[纯css3实现loading效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;line1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line3&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line5&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line6&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line7&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line8&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line9&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line10&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line11&quot;&gt;&lt;/div&gt; &lt;div class=&quot;line12&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;style&gt; @-webkit-keyframes loading &#123; from &#123; opacity: 1; width: 5px; height: 20px; &#125; to &#123; opacity: 0.25; width: 5px; height: 20px; &#125; &#125; .wrapper &#123; position: relative; top: 50%; left: 50%; display: inline-block; zoom: 0.3; /*通过修改这个值(值的区间为0-1)的大小来设置菊花的大小*/ &#125; .wrapper div &#123; width: 3px; height: 16px; background: #a4a2a4; position: absolute; left: 100%; top: 100%; opacity: 0; -webkit-animation: loading 1.2s linear infinite; &#125; .wrapper .line1 &#123; -webkit-transform: rotate(0deg) translate(0, -34px); -webkit-animation-delay: 0s; &#125; .wrapper .line2 &#123; -webkit-transform: rotate(30deg) translate(0, -34px); -webkit-animation-delay: 0.1s; &#125; .wrapper .line3 &#123; -webkit-transform: rotate(60deg) translate(0, -34px); -webkit-animation-delay: 0.2s; &#125; .wrapper .line4 &#123; -webkit-transform: rotate(90deg) translate(0, -34px); -webkit-animation-delay: 0.3s; &#125; .wrapper .line5 &#123; -webkit-transform: rotate(120deg) translate(0, -34px); -webkit-animation-delay: 0.4s; &#125; .wrapper .line6 &#123; -webkit-transform: rotate(150deg) translate(0, -34px); -webkit-animation-delay: 0.5s; &#125; .wrapper .line7 &#123; -webkit-transform: rotate(180deg) translate(0, -34px); -webkit-animation-delay: 0.6s; &#125; .wrapper .line8 &#123; -webkit-transform: rotate(210deg) translate(0, -34px); -webkit-animation-delay: 0.7s; &#125; .wrapper .line9 &#123; -webkit-transform: rotate(240deg) translate(0, -34px); -webkit-animation-delay: 0.8s; &#125; .wrapper .line10 &#123; -webkit-transform: rotate(270deg) translate(0, -34px); -webkit-animation-delay: 0.9s; &#125; .wrapper .line11 &#123; -webkit-transform: rotate(300deg) translate(0, -34px); -webkit-animation-delay: 1.0s; &#125; .wrapper .line12 &#123; -webkit-transform: rotate(330deg) translate(0, -34px); -webkit-animation-delay: 1.1s; &#125; &lt;/style&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>前端</tag>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[层序遍历]]></title>
    <url>%2F2020%2F06%2F12%2F%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[小余同学给讲的层次遍历 层序遍历就是从上到下 从左到右遍历二叉树 比如上面这颗 层序遍历就是 1 4 2 3 5 要实现层序遍历一般我们使用队列（why？因为先进先出，这和二叉树的访问结构对上了，某一层进入队列，可以先访问这一层的节点，再通过每个节点的左右孩子访问下一层，然后把对应节点出列） Leetcode里面的代码其实就是给定你数据结构的定义，你只要能了解就可以用 其实是这样的Struct Node{ Int val; Node left; Node right；} Root也是Node类型是给定的二叉树的根 二叉树的结构已经通过left和right定义好 比如上面root.left（也是一个Node型变量）代表它的左孩子，root.left.val 代表左孩子的结点的值是4，root.right.val=2 传入函数的是根结点var levelOrderBottom = function(root) { if(!root)return []; //如果根是空节点 retrun 空的数组 let queue=[root]; //根入列 let res=[]; let level=0; //记录层数初始值为0 while(queue.length){ //当队列不为空时 let temp=[];//临时变量用来存放下一层的所有节点 res[level]=[];//某一层的层序遍历结果 for(let i=0;i&lt;queue.length;i++){ //遍历某一层的节点 res[level].push(queue[i].val);//将此节点入本层队列 if(queue[i].left){ temp.push(queue[i].left); //将左孩子（即下一层）入temp队列 } if(queue[i].right){ temp.push(queue[i].right);// 将右孩子（即下一层）入temp队列 } } queue=temp; //此时temp里就有下一层按从左到右顺序的所有节点将它赋值给queue，接着重复遍历queue直到空 ++level;//由于这一层的节点遍历完（跳出前面的for循环了），此时的queue是装的下一层节点所以层数加1 } return res.reverse();//由于层序是从上到下从左到右 题目是从下到上从右到左，过将层序结果reverse一下即可}; 通过上面的二叉树模拟一下：开始 queue 里面是 1节点 level是0，，res为空当queue.length（1）不为0循环： Temp置空 走for遍历这一层的节点； 将 1节点放入res[level]队列 （level为0）看看他的左右孩子是否存在，依次进入temp队列 此时temp是 4和2节点 第一层遍历完了temp赋值给queue（4和2）,level++为1 当queue.length（2）不为0循环： temp为空（由于上次循环里temp放的是这一层的节点，而temp是要每次存放下一层的节点故每次for遍历此层前将temp置空） 走for遍历这一层的节点； 将 4节点放入res[level]队列 （level为1）看看他的左右孩子是否存在，依次进入temp队列 此时temp是3节点将 2节点放入res[level]队列 （level为1）看看他的左右孩子是否存在，依次进入temp队列 此时temp是3和5节点 第二层遍历完了temp赋值给queue（3和5）,level++为2 当queue.length（2）不为0循环： temp为空（由于上次循环里temp放的是这一层的节点，而temp是要每次存放下一层的节点故每次for遍历此层前将temp置空） 走for遍历这一层的节点； 将 3节点放入res[level]队列 （level为2）看看他的左右孩子是否存在（不存在），依次进入temp队列 此时temp为空将 5节点放入res[level]队列 （level为2）看看他的左右孩子是否存在（不存在），依次进入temp队列 此时temp依然是空 第二层遍历完了temp赋值给queue（为空）,level++为3 此时queue长度为空，跳出循环，而level就是二叉树的层数（虽然从0层开始（为了和数组下标对应）但是再遍历完第二层（此时是最后一层遍历后仍然加1）为3）然后将res数组reverse一下得到结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[小程序开发总结]]></title>
    <url>%2F2020%2F06%2F11%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[虽然之前提换组没有成功，但是也阴差阳错参与到了小程序开发组开启了小程序开发的升级打怪之路 rpx单位 没有刷新页面的功能，页面数据都是异步请求获取的，你删除某个商品的时候，直接再请求一次数据，更改页面的数据就可以了。 点击事件传递参数 微信小程序 点击事件获取到的 event.currentTarget.datasethttps://blog.csdn.net/weixin_37861326/article/details/84027569 小程序实现长按复制文字 https://blog.csdn.net/weixin_39589455/article/details/99704077 小程序使用sass https://www.jb51.net/article/144681.htm 微信小程序01：关于错误Page “pages/goods_list/index” has not been registered yet.的原因 小程序打开H5 https://www.jianshu.com/p/3c8e84c6e67d 小程序使textarea自动聚焦 9.e.target和e.currentTarget的区别 e.target 指向触发事件监听的对象。e.currentTarget 指向添加监听事件的对象，指向代码中点击事件的元素e.target始终指向即当前点击的目标元素，e.currentTarget在事件委托中，如果监听元素不是目标元素，则指向监听元素 bind call 的作用和区别 methods中的函数和直接写在page中函数的区别 catchTap 生命周期 wx.onMemoryWarning 监听内存不足警告 页面跳转传参 https://www.jianshu.com/p/079db5ea1a9b 小程序实现写入缓存与读取缓存 17 flex布局 设置小程序的状态栏、导航条、标题、窗口背景色[Window] https://blog.csdn.net/dxnn520/article/details/79342548 textarea 中 ajust-position 中 false 值需要用双层中括号包起来 否则不生效 【微信小程序】微信小程序阻止IOS页面上下拖动问题为了阻止IOS端小程序页面上下拖动可以再对应的json文件当中添加这个配置 “disableScroll”:true 小程序windowHeight在不同页面高度不一致问题及解决方案https://blog.csdn.net/qq_41619741/article/details/83143624 小程序的windowheight和screenheight 小程序阻止事件冒泡 https://blog.csdn.net/promiseCao/article/details/83926807?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2 组件层级问题 https://www.cnblogs.com/duxingdexin/p/9585285.html 使用TypeScript开发小程序入门 https://www.jianshu.com/p/c778943acb37]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack配置css-modules]]></title>
    <url>%2F2020%2F05%2F20%2Fwebpack%E9%85%8D%E7%BD%AEcss-modules%2F</url>
    <content type="text"><![CDATA[CSS Modules 是指：项目中所有 class 名称默认都是局部起作用的。 CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。产生局部作用域的唯一方法，就是使用一个独一无二的class的名字，不会与其他选择器重名。这就是 CSS Modules 的做法。 https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbef07bbbba80861a35c21]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6-新特性总结]]></title>
    <url>%2F2020%2F05%2F20%2Fes6-%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[es6常用新特性总结 es6新特性 object.assign(source,target) 参数必须是对象 否则会报错 用来将source对象中的所有可枚举属性赋值到目标对象target中 箭头函数 箭头函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象，箭头函数中没有自己的this的，而箭头函数会默认使用父级的this。 不管在什么情况下,箭头函数的this跟外层function的this一致，外层function的this指向谁，箭头函数的this就指向谁，如果外层不是function则指向window。 适合使用箭头函数的场景：使用箭头函数对this指向进行干预 不适合的场景： 构造函数的原型方法中（构造函数的原型方法需要通过this获得实例） 需要获得arguments时（箭头函数中没有arguments） 使用动态回调 proxy代理 proxy用于修改某些操作的默认行为 ES6中常用的10个新特性讲解]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS-BFC]]></title>
    <url>%2F2020%2F05%2F20%2FCSS-BFC%2F</url>
    <content type="text"><![CDATA[今天认真仔细地看了下BFC的内容，算是有了更具体的理解 BFC（块级格式化上下文） BFC的触发条件 根元素或其他包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML 表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML 表格标题默认属性) 具有 overflow 且值不是 visible 的块元素 display: flow-root 的元素 column-span: all 的元素 BFC导致的现象 内部的 box 将会独占宽度，且在垂直方向，一个接一个排列 box 垂直方向的间距由 margin 属性决定，但是同一个 BFC 的两个相邻box 的 margin 会出现边距折叠现象 每个 box 水平方向上左边缘，与 BFC 左边缘相对齐，即使存在浮动也是如此 BFC 区域不会与浮动元素重叠，而是会依次排列 BFC 区域内是一个独立的渲染容器，容器内元素和 BFC 区域外元素不会形成任何干扰 浮动元素的高度也参与到 BFC 高度的计算当中 目前为止 最常用的BFC操作有 通过设置元素display:inline-block消除边距折叠 给相邻元素或父元素设置 display:inline-block 清除浮动 和给浮动元素设置overflow:hidden清除浮动]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios中的拦截器]]></title>
    <url>%2F2020%2F05%2F18%2Faxios%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[拦截器在请求或响应被 then 或 catch 处理前拦截它们。分为请求拦截器和响应拦截器 关于拦截器的官网文档 请求拦截器请求拦截器的作用是在请求发送前进行一些操作，例如在每个请求体里加上token 响应拦截器响应拦截器的作用是在接收到响应后进行一些操作，例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get和post方法]]></title>
    <url>%2F2020%2F05%2F16%2Fget%E5%92%8Cpost%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[http中的get和post方法 get获取的数据可以被缓存get传输的数据长度短get是明文传输，参数在url中，相对来说安全性不够 关于在axios中 get和post 以及params和data的区别详情看官网]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效能人士的七个习惯]]></title>
    <url>%2F2020%2F05%2F16%2F%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[好久之前看的 先记个提纲吧 日后若果看第二遍 倒是可以记个详细的笔记 积极主动 以始为终 要事第一 双赢思维 知彼解己 综合综效 不断更新]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rn踩坑]]></title>
    <url>%2F2020%2F05%2F13%2Frn%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[ract native 报错系列 ES5/ES3 中的异步函数或方法需要 “Promise” 构造函数。确保对 “Promise” 构造函数进行了声明或在 “–lib” 选项中包含了 “ES2015”。解决办法： RN开发 js jsx ts tsx的区别详情看别人家总结 报错 Building and installing the app on the device (cd android &amp;&amp; gradlew.bat installDebug)…Downloading http://10.10.82.235:8080/sdk-resources/gradle-4.6-all.zipException in thread “main” java.net.ConnectException: Connection refused:解决办法1、 rm android/ -rf2、 react-native eject3、 run Props获取不到值原因 箭头函数 this的指向丢了解决办法]]></content>
      <tags>
        <tag>前端</tag>
        <tag>rn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[echarts在rn中设置颜色不生效解决方案]]></title>
    <url>%2F2020%2F05%2F06%2Fecharts%E5%9C%A8rn%E4%B8%AD%E8%AE%BE%E7%BD%AE%E9%A2%9C%E8%89%B2%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[echarts在rn中设置颜色不生效解决方案在rn中的用法跟h5中有点不一样 直接照搬过来会出很多问题费了九牛二虎之力 实践摸索出来的]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对中文编码的函数]]></title>
    <url>%2F2020%2F05%2F06%2Fjs%E5%AF%B9%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[js中的中文保险起见 最好都进行一下转码escape,encodeURI,encodeURIComponent escapeescape encodeURIencodeURI() 函数可把字符串作为 URI 进行编码。如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。encodeURI encodeURIComponentencodeURIComponent 参考博文]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端1像素解决方案]]></title>
    <url>%2F2020%2F04%2F02%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF1%E5%83%8F%E7%B4%A0%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[移动端适配 1px 边框解决方案transform: scale(0.5) 方案1234567div &#123; height:1px; background:#000; -webkit-transform: scaleY(0.5); -webkit-transform-origin:0 0; overflow: hidden;&#125; css 根据设备像素比媒体查询后的解决方案1234567891011121314/* 2倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 2.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125;&#125;/* 3倍屏 */@media only screen and (-webkit-min-device-pixel-ratio: 3.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.33); transform: scaleY(0.33); &#125;&#125; 适配方案待续。。。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年度总结]]></title>
    <url>%2F2020%2F01%2F01%2F2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[断舍离]]></title>
    <url>%2F2020%2F01%2F01%2F%E6%96%AD%E8%88%8D%E7%A6%BB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[好好吃饭]]></title>
    <url>%2F2019%2F12%2F22%2F%E5%A5%BD%E5%A5%BD%E5%90%83%E9%A5%AD%2F</url>
    <content type="text"><![CDATA[总结三项法则 吃饭吃到有饱腹感为止，任何东西都是 少吃快餐油炸食品之类的 少囤积食物，多吃果蔬，饮食健康 最好的节食，就是你不觉得自己在节食 吃饱之后继续吃是发胖的主要原因之一 吃饱了就停止，不要觉得浪费，从经济学上讲在为食物付帐的那一刻起这份实物得懂成本就已经定了，不会因为吃了都少而改变 用小容器吃东西会吃的比较少 少点种类会吃的比较少 看电视看电影时容易无意识的吃太多，任何分散我们对食物注意力的事情，都可能使我们不自觉多吃 甜品最好吃的就是最开始的两口，少吃甜品 成功的市场音效时激发美好联想和回忆，而气味是与回忆密切相关的 人们经常为包装消费 先吃最好吃的食物 不要委屈自己，决定彻底不再吃某种喜欢的食物 半盘法则，一半是水果蔬菜，另一半是肉类淀粉]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞定GTD]]></title>
    <url>%2F2019%2F12%2F22%2F%E6%90%9E%E5%AE%9AGTD%2F</url>
    <content type="text"><![CDATA[构建以结果和行动为导向的思维方式，从漫无目的的思考到行动性的思考 GTD步骤 列出所面临的问题 思考预期结果 为了推动事情进展需要采取的下一步实际行动（一次只做一件事） 在行动之前进行周密的思考思考结果是促使希望转化为现实的最有效的手段之一 tips: 任何事情都应该做到最简单而不是相对简单 机制管理“todolost”经常回访并予以清理收集经常冒出来的念头和想法，解决他们 制定行动计划 将与行动方案相关联的体时，放到一个经常查询的系统中（融入到日常习惯） 事务极少会由于时间匮乏而受阻，他们陷入困境往往是由于未能预先明确下一步的行动而造成的]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web安全详解1]]></title>
    <url>%2F2019%2F12%2F17%2Fweb%E5%AE%89%E5%85%A8%E8%AF%A6%E8%A7%A31%2F</url>
    <content type="text"><![CDATA[桥哥给我们讲web安全~ 前端语言：html js php 面向浏览器 用户后端语言：java c语言 c++ OSI是一个开放性的通信系统互连参考模型，它是一个定义得非常好的协议规范。OSI模型有7层结构，每层都可以有几个子层。OSI的7层从上到下分别是 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层 ；其中高层（即7、6、5、4层）定义了应用程序的功能，下面3层（即3、2、1层）主要面向通过网络的端到端，点到点的数据流。实际应用中 表示层和会话层是没有的 数据包的传送过程输入url浏览器发送请求默认路由：常见端口21：FTP25：SMTP 邮件80: HTTP443: HTTPS DNS域名解析：顶级域到子域]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rgba的十六进制写法]]></title>
    <url>%2F2019%2F12%2F17%2Frgba%E7%9A%84%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[rgba的十六进制写法一个小tips 00%=FF（不透明）5%=F210%=E515%=D820%=CC25%=BF30%=B235%=A540%=9945%=8c50%=7F55%=7260%=6665%=5970%=4c75%=3F80%=3385%=2190%=1995%=0c100%=00（全透明） UI给出的颜色值为#FF0000，透明度30%。结合上表，30%的透明度16进制的值为 B3，那么最终的颜色值为 #B3FF0000]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类似fontawesome图标库的实现]]></title>
    <url>%2F2019%2F12%2F03%2F%E7%B1%BB%E4%BC%BCfontawesome%E5%9B%BE%E6%A0%87%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[通常一个app中，正常情况下会有大量重复使用的小图标icon 这些图标以图片的形式存在的话，虽然小，但每个图片都会有一个请求。近日我司一个从阿里来的大佬给提供了另一个做前端小图标的思路。类似 fontawesome 自己实现类似的库，可以通过这种方法(https://zhuanlan.zhihu.com/p/22724856)]]></content>
  </entry>
  <entry>
    <title><![CDATA[支付宝体验设计精髓]]></title>
    <url>%2F2019%2F12%2F01%2F%E6%94%AF%E4%BB%98%E5%AE%9D%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E7%B2%BE%E9%AB%93%2F</url>
    <content type="text"><![CDATA[哈]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事实]]></title>
    <url>%2F2019%2F12%2F01%2F%E4%BA%8B%E5%AE%9E%2F</url>
    <content type="text"><![CDATA[《事实》一书，读书笔记 一分为二 关注大多数 负面思维 对坏消息有思想准备 直线思维 直线可以弯曲 恐惧本能 计算风险 规模错觉 按照比例看待事物 以偏概全 思考你的分类方法 命中注定 一点点改变也是改变 单一视角 获取一套工具箱 归咎他人 拒绝职责他人 情急生乱 慢慢来]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[document.body.scrollTop值为0的解决方法]]></title>
    <url>%2F2019%2F11%2F25%2Fdocument-body-scrollTop%E5%80%BC%E4%B8%BA0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[网传解决方法，不再赘述]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端隐藏滚动条]]></title>
    <url>%2F2019%2F11%2F25%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%9A%90%E8%97%8F%E6%BB%9A%E5%8A%A8%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[记录工作中遇到的问题，移动端的滚动条在某些情况下十分不美观，特别是在可滚动的表格中，显得格外的不精致。 ::-webkit-scrollbar {display: none;}在ios端并不起作用，安卓端我没有测试针对ios不生效的情况，做如下处理让滚动条离远点超出父元素的范围，在通过隐藏父元素的超出部分让滚动条消失。由于子元素的高度大于父元素的高度，超过父元素的高度的内容被剪裁。因此，子元素的滚动条就被剪裁掉了]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[serviceworker]]></title>
    <url>%2F2019%2F11%2F13%2Fserviceworker%2F</url>
    <content type="text"><![CDATA[serviceworker离线网页应用？ serviceworker的前身 manifest Service Worker是谷歌发起的实现PWA（Progressive Web App）的一个关键角色 Service Worker的使用套路是先注册一个Worker，然后后台就会启动一条线程，可以在这条线程启动的时候去加载一些资源缓存起来，然后监听fetch事件，在这个事件里拦截页面的请求，先看下缓存里有没有，如果有直接返回，否则正常加载。或者是一开始不缓存，每个资源请求后再拷贝一份缓存起来，然后下一次请求的时候缓存里就有了。 网上的文章]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端系列笔记4]]></title>
    <url>%2F2019%2F10%2F28%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[前端技能优化4 前端性能优化 页面加载性能 秒开率：即一秒之内打开的用户占用户总量的百分比。 动画与操作性能 3.内存 电量消耗 技术方案划分 缓存 1.客户端控制的强缓存策略 降低请求成本 http dns：由客户端控制，隔一段时间主动请求 DNS 获取域名 IP，不走系统的 DNS TCP/TLS 连接复用：由服务端升级到 HTTP2，尽量合并域名 减少请求数 JavaScript css 打包到 html 用 JavaScript 控制图片异步加载和懒加载 小型图片使用 data-uri(base64) 减少传输体积 尽量使用 SVG/GRADIENT 等代替图片 根据机型和网络状控制图片清晰度 对低清晰度的图片使用锐化来提升体验 设计上避免大型背景 技术设计应该从业务角度考虑 工具链 工具体系的设计：1.初始化项目 2.运行和调试 3.测试 4.发布 持续集成 持续集成的目标：一是要及早集成代码形成可测试的版本，二是通过一定的测试来验证提交的代码的有效性。 搭建系统 大量紧急不重要的页面 抽象成一个需求 就是搭建一个快速实现大量页面的系统]]></content>
      <tags>
        <tag>前端</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化之防抖]]></title>
    <url>%2F2019%2F10%2F06%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[函数防抖：实际上就是对于频繁触发的事件进行延时处理，只触发一次只响应一次，这样可以极大的提高性能 我们实现的思路就是：先设置一个计时器变量，用闭包保存，保证不会被内存释放，在事件触发的时候，也就是只要事件触发，先清除这个计时器，然后再设置一个，那么只要事件持续触发，刚刚建立的定时器就会被销毁，直到最后我们不在触发事件，就执行最后一次设置的定时器。 节流：限制触发频率当快速的点击抢购按钮的时候，数量快速的增加，如果有人用脚本点击，那么这个数量会瞬间非常的大，造成性能问题。那么我们就需要控制触发函数的频率，也就是节流，事件第一次触发的时候，记录下函数执行的时间点，当函数想要再一次执行，需要间隔一定的时间才能执行，也就是每间隔一定的时间，才能触发这个函数，而不能快速触发，这就是节流的方法。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希]]></title>
    <url>%2F2019%2F09%2F25%2F%E5%93%88%E5%B8%8C%2F</url>
    <content type="text"><![CDATA[今天开始刷算法，立了个每天一道算法题的flag,第一天，一道简单的题目，但是也可以有 有深度 的写法leetcode第一题用常规方法时间复杂度为O(n*n) 而hashmap的时间复杂度只有O(n) hashmap是一个用于存储key-value键值对的集合]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24岁这一天]]></title>
    <url>%2F2019%2F09%2F24%2F24%E5%B2%81%E8%BF%99%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[健康状况保持的不行，要坚持每天锻炼一会会呀 少看点书，慢下来，不要着急。欲速则不达 赶紧复习基础，多写代码，不然怎么跳槽，一定要尽快跳出这个烦人的圈。 存到一些钱，但是不要放太多注意力在这个东西，不然得不偿失。 不要抱怨，去改变~]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[做一个规划]]></title>
    <url>%2F2019%2F09%2F16%2F%E5%81%9A%E4%B8%80%E4%B8%AA%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[最近两个月沉迷于看书以及梳理计划之类的东西，除了工作之外都没有写代码。今天来系统的做一个反思，关于生活、工作和理财。 首先是生活，我给自己定了一系列的目标规划，基本上算是把日常生活安排的明明白白了。虽然有些安排没做到。。。但是大部分还是坚持下来了，而且说实话作为一个995的社畜，实践真的是很难安排。早起一杯水，一杯黑咖啡这个习惯基本上算是养成了，别说黑咖啡真的还挺提神醒脑的，不过要想上午不犯困还是得早点休息，所以我的计划是11点关灯趴在床上看书然后自然入睡~看书。个人觉得多看书真的能学到一些东西，特别是人文社科类的书籍，挺启发人的。输出。人说最好的学习方式是输出，我在努力。尽量保持隔一天就写一篇总结吧，不过也意识到了水平不足的情况下高产带来的负面影响，质量不够高。复盘。每天复盘目前我没做到。每月复盘倒是坚持下来了。每个月月尾必须要做的事情，就是做一篇复盘、核对一遍账单和换床单。目前看来，还挺有成效的，把一些不好量化的东西量化出来，慢慢能看到自己的进步，这种感觉挺好的~听广播。每天起床到出门的这段时间，就是边洗漱收拾边听广播过的，说起来我目前唯一还在续费的会员就是喜马拉雅了~ 听听相声小品脱口秀或者讲书，都挺不错。最近开始尝试坚持运动和正念冥想。我一直是注意力不太容易集中的人。听说正念冥想能有用，想着尝试一下，反正也没有成本~ 运动的话，是我一直觉得自己有点胖了，而且不够健康了。作为一个心里把健康摆在第一重要位置的人，每周在运动上花费的时间不到五小时我觉得这对健康来说委实不公，所以得不到健康也正常。。。 工作啊。就我所接触到的来说，大多数人的工作都是没有挑战性的，千篇一律，没什么意思。这也正常，企业家的目标是挣钱，不在乎你个人的理想。如果一开始工作就进入了一个高速成长的团队，那真的是很幸运了。但很多人没那么幸运，我也没那么幸运。好在我意识到这一点并且尝试要做点什么。给自己定一个跳槽的目标并且按照这个标准准备，理想很美好，但是没时间的现实有点残酷，达不到目标的现实更残酷，所以还是逼自己一把吧，做起来其实也没想象的那么难，关键在于把握好一种平衡，而这种平衡我目前还在摸索。 今天梳理了一下自己的账户，感觉还可以再抠门一点，每个月还能再多存一点~ 理想总是要有的，万一实现了呢按照大V的建议，每个月的储蓄额为收入的50%，预期年化收益10%的话，十年下来好像是能够实现理想的样子~ 现在想十年好像很漫长，理想随时可能会变，但是谁知道呢，先种一颗树呗，万一十年之后我还是想吃苹果呢 比现在什么都不做好。而且大幅度削减开支并没有让我的生活过得紧巴巴的，感觉变化不大，但是余额增多很爽啊~从去年开始接触基金到现在，大A股一直处于一个比较低的点位，而且我因为不太懂这些东西一直处于猥琐发育的状态，所以到现在一直也没亏，今年以来竟然也陆陆续续的赚到了四五千的样子，不看我的账本流水我也是没有想到的，更没有想到的是，这半年的加班报销晚餐钱都有了两千多，我都不晓得我居然加了这么多班~今天稍微思考了一下资金分配的问题，虽然总金额不多，但是一想到我差点把所有的钱都投进了高风险的基金里，就觉得有点刺激，得亏是运气好，前段时间卖掉了一些盈利的基金，留下了一笔紧急备用的资金放在天天基金的活期宝里不动，从此告别我司的理财产品了~ 从其他理财大V那抄的，留三到六个月的生活费，虽然目前还没用上，而且也不明白为啥要留，但还是希望不要有用上这笔钱的时候。反正裸辞是不可能裸辞的，说什么都不会裸辞的。为了不被劝退，还是得好好学习啊~ 希望能成为一个有点厉害的人吧~ N]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度工作]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在卡尔·纽波特博士的论述里，深度工作的意思为在无干扰的状态下专注进行职业活动，是个人的认知能力达到极限的状态。深度工作不仅是对于正在工作的职场人士有意义，对于任何想要提升自己做事情效率，甚至仅仅是想提升专注的的人来说，都具有极大的意义。 我们的周围充斥着信息和干扰。包括我自己，手机也是越来越放不下的东西。很难长时间的集中精力在一件事情上，特别是当一件事情做起来有一定的难度时。截至到目前，我一共拿起了手机41次，其中有12次拿起后第一次打开的应用是微信，但今天是周末，几乎没有任何重要甚至仅仅是有意义的消息找我，而且我今天大部分的时间在看书，其间拿起手机41次，可见我的专注的多么低了。心理学研究表示，培养深度工作的习惯更有助于经济成功。对于书中关于这个观点的论述这里就不再赘述了，有兴趣的可以自己去看看书。接下来我们讲一讲，怎么提高自己深度工作的能力。首先，你得认同深度工作即专心致志沉浸在工作状态里是有价值有好处的，看这个深度工作的方法论才有意义。1.工作要深入，屏蔽干扰。摸索出最适合自己的深度工作方式。书中举例的几种深度哲学大多是对普通人没多大参考价值的。比如离群索居，独自思考的禁欲主义哲学。比如以年度为单位划分出不受打扰的时间段的双峰哲学。但是大多数人的工作都是与人协作型的工作，没有自由的时间可以沉浸在自己的工作中，这种情况可能就比较适合小段小段的时间去沉入工作中。 我们常说，玩的时候好好玩，学的时候好好学。这条规则在深度工作中同样适用。实际上，保持高度的专注是很累的事情，跟我们常规意识中的“意志力强是个人的选择和自律的表现”不同，在《自控力》一书中，作者提出“人的意志力是有限的”这样一个观点，所以不要给自己的工作时间安排的太满，留出一点时间来，让自己好好好休息，也有助于下一次全身心的投入深度工作。2.拥抱无聊，时常也让自己“分心”。生活处处都是网络，我们也需要与社会关联。网络的普及和发展实际上正是我们人类文明发展的体现。真正危害我们的是，稍有无聊或者遭遇一点点认知上的挑战，就从低刺激、高价值的活动转向高刺激、低价值的活动，这会使得人的大脑习惯这种新奇刺激的东西。针对这种情况，作者提出的策略是，预先计划好使用网络的时间，在这个时间段之外的时间里，坚决不碰网络。当然这里的网络，特指让人工作时候分心的软件和网站之类的，毕竟像我们这种程序员，日常工作就靠面向搜索引擎编程了，完全不用网络当然是不现实的。3.远离无意义的社交在我的观点里，任何事情都具有多面性。从某种角度来讲，社交媒体并不见得如广告中说的那样是当代互联世界的血液，他们只是产品，由一些私人公司开发，投资巨大，营销精心，最终啥的设计目的是俘获你的个人信息和注意力，卖给广告商。在社交媒体上，你其实没那么重要，但大多数人不愿意承认这样一个事实，或者根本没有意识到。 倘若你是想慢慢的变成一个越来越厉害的人，我建议你可以根据这些方法论结合自身情况实践起来，如果没有，那也没关系。 我个人打算实践的是每个工作日的早上查看完邮件做完工作计划之后就开始关掉微信,开始做最重要的事情。下午午休完不清醒的时候可以摸摸鱼，查看下邮件消息。然后来处理工作上的琐事，大多数时候，工作上的事情还是琐事偏多。晚上回去就看书好了，或者看剧，能让人放松的就好，或者，开心就好。（这里对每日计划的安排来自另一本书中的观点，具体哪本记不清了，但是在最近看的《精进》这本书中，作者对此也做了论述。将事情划分为四个象限，每天我们最开始做的事情应该是计划中重要且紧急的事情，或者至少是最重要的事情，因为琐事总是处理不完的，但是太小的事情，随手就能立马解决掉的事情，也别一直往后堆了 顺手就做了吧）工作中被各种事情和消息打断无可避免，即使关掉所有通讯工具，还是会有人跑到你身边来打断你，所以这个事情，，尽力而为就好，做不到完全不受打扰也不需要过分苛责]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[经济机器是怎样运行的]]></title>
    <url>%2F2019%2F09%2F07%2F%E7%BB%8F%E6%B5%8E%E6%9C%BA%E5%99%A8%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%2F</url>
    <content type="text"><![CDATA[经济动力：1.生产率提高2.短期债务周期3.长期债务周期]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于做产品的一些笔记]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%85%B3%E4%BA%8E%E5%81%9A%E4%BA%A7%E5%93%81%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[如何成为一名优秀的独立开发者，作者给出了以下几点建议：做一些你喜欢做的东西；快速构建好产品，并及早放到市场上验证（精益创业）；不要在技术上浪费太多时间，定好发布日期便执行；不懂技术也可以打造一款好产品；如果你打算开始单干，记得打造好你的个人品牌；亲自为客户提供邮件支持，至少在一开始时要这么做；顾客至上；仔细思考并设定合理的目标，先实现产品再谈其他。 认清自己，你可以自己问问自己，最喜欢做什么，最不喜欢做什么，也可以问问身边的朋友，觉得你哪方面不错，哪方面不灵。然后认真分析一下，真的，这事可能需要很多年，越早知道越有利。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀缺]]></title>
    <url>%2F2019%2F09%2F06%2F%E7%A8%80%E7%BC%BA%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[乌合之众]]></title>
    <url>%2F2019%2F09%2F06%2F%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%2F</url>
    <content type="text"><![CDATA[法国心理学家古斯塔夫勒庞的这本社会心理学著作《乌合之众》大多数人就算没有看过也应该听说过。其实刚开始看这本书的时候我是看不下去的，加之网上对他各种评论，褒贬不一，让我更加不敢妄加断言自己的观点。但是自己些写东西嘛，必然是有自己的偏见的，还是记录一下自己看这本书时的看法，不一定对。 首先我们不说这本书是不是一本好书。我对好坏的界定一直不清晰。个人有个人的看法，大致上大家都会倾向于相信自己所相信的东西。正如我是个悲观的人，一定程度上我很认同勒庞关于“群体的无意识性”的说法。这里的群体是指以某种共同的目的或者心理状态而聚合到一起的一群人。勒庞认为人们一旦陷入无序群体之中，个人意识就会消失，变成盲目的集体意识，充满了急躁、冲动、轻信、偏执……]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个冥想者的觉知书]]></title>
    <url>%2F2019%2F09%2F02%2F%E4%B8%80%E4%B8%AA%E5%86%A5%E6%83%B3%E8%80%85%E7%9A%84%E8%A7%89%E7%9F%A5%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[这是我看的第一本关于冥想的书，看完之后我依旧是个没有信仰的人。本书通过作者的亲身经历，描述自己在巨大的压力下，如何战胜抑郁和焦虑，找到了行之有效的自我调节方法。 看这本书的初衷很简单，我很焦虑。我也希望能有个行之有效的方法，能够让我恢复平静，另一方面，看书也使我平静。 这本书越看到后面，宗教的色彩越明显，对于作者所说的福至心灵的一刻，我从未体验过，但也无法证明其不存在，故而不置可否。但他其中提到的一些观念，和我在别的书籍中得到的知识交叉印证，这种感觉很妙。 以下，是来自书中的一些精彩的观点 根据拖勒所述，自我意识就是我们的内在叙述者，是我们对“我”的感知意识。他认为自我意识总是以当下为代价，迷恋着过去和未来。我们在对陈年往事恋恋不舍的同时反思反悔，我们在对未来远景憧憬期许的同时痴心妄想。但此时此刻才是最重要的，当下这一刻是我们所拥有的全部。 这一观点，隐约让我有点理解我们常说的 什么叫做“活在当下” 自己所预测的恐怖剧情无非是脑海中一闪而过的念头罢了。他们并非空穴来风，但也绝对不是既定事实。我们应当接受自己的思想，它只是些念头，不是事实，因而不必怀有那么深刻的恐惧。 人说恐惧才是人类发展最原始的驱动力。恐惧驱使着我们去做各种事情，一定程度上它促进了我们的进步，但另一方面，也让我们有些许盲目。 专注当下，接受自己的念头，承认它的存在，但是，客观世界里的隐患呢 我们要怎么面对 承认意识的存在 然后呢 问题还是没有得到解决 继而，接触到佛教 佛教的主要思想就是“无常”。就像我们说的，世界上唯一不变的就是变化本身。从某种角度看，佛教的思想其实也是一种东方的哲学思想。佛教并不通过挑战死亡来承诺灵魂的救赎，而是教我们直面那些能够毁掉我们的东西。 正念：是一种让我们站在一个非评判性的距离上审视思想内容的方法。 我个人将之理解为 觉察。感受到自我的意识，但不去评判好坏对错，仅仅是觉察到它的存在即可。 正念是给我们一种审视自我的机会，而不是试图驱逐它，尤其不是试图爱上它。这里提供了一种正念的方法：识别 接受 探寻（探究当下情绪对自己的影响） 不对号入座（不要给自己贴标签，甚至谴责自己当下的情绪，情绪并没有对错） 这种“佛系”，会让我们变成一个软弱的人吗 认清问题之所在并不是被动接纳，我们无法改变眼前发生的事情，但是我们可以控制自己应对的方式，积极或消极，只有自己说了算。 每当好事临门，我们却过于急切地把自己地心理预期提高，欲望的大坑依旧无法填满。人们总认为这样或者那样地事物才终极地自由和幸福的源泉，但佛法说“无常”，事物永恒是变化的，摆脱“执念”，活在当下的快乐里，才是幸福的源泉。 活在当下的其中一个我们比较容易做到的事情： 一次只做一件事。 一段高深的结尾：一个雄心勃勃、想要开创历史获得成功的人，当然需要发奋图强。但有了结果时，要放下结果，因为人生中并非事事如意。放下对于结果的执念。 个人理解的佛法（短暂的认为我是个有信仰的人），不同于我们传统印象中清心寡欲、不近酒色的和尚，反而是更接近《活佛济公》中的济公和尚。形形色色的欲望和情绪才组成了我们丰富饱满的人生啊，怀着欲望和情绪，活在当下，或许能让我们得到些许的安慰和救赎，谁知道呢 人终其一生，不都是在探索和寻觅这些嘛]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拆掉思维里的墙]]></title>
    <url>%2F2019%2F08%2F27%2F%E6%8B%86%E6%8E%89%E6%80%9D%E7%BB%B4%E9%87%8C%E7%9A%84%E5%A2%99%2F</url>
    <content type="text"><![CDATA[面对呼啸而至的时代车轮，我们必须加速奔跑，有时会力不从心，有时会浮躁焦虑，但必须适应，它可以轻易地将每一个落伍的个体远远抛下，甚至碾作尘土，且不偿命。” ——赫尔曼·黑塞《在轮下》在轮下，我们能做些什么？ 接受不能改变的，尽力去改变那些我们能改变的，且能让事情变得更好的东西。一万条空想不如开始行动，即使最后的结果并不尽如人意，但是开始，就是成功的第一步，否则想再多都没有意义。少听成功学，每个人的成功都有其特定的背景和机遇，你也有自己的。世俗意义的成功是唯一的成功标准嘛？你想爬到人上，但总有人站在你的上方俯视你，倘若你忿忿不平，发誓一定要站到更高的位置，把别人踩在脚下，那么想一想，你想要的到底是什么 你要付出了什么代价 相较于你想得到的东西，你愿意以失去另一些东西为代价吗 思考清楚了这个问题再行动。时代是时代，你是你。任何时候，当下都是最好的时代，也是最坏的时代。人无法轻易改变他人，不妨从改变自己开始。 ◆ 6招快速提升安全感 消除恐惧的最后一招，也是最有效的一招，就是找到你自己的恐惧底线，然后去面对它。 恐惧有三个层次：第一个层次是恐惧事情本身。第二个层次是害怕失去背后的价值。第三个层次，也就是真正的恐惧，是你觉得自己没有能力去应对这个失去。 ◆ 必问自己的两个触底反弹问题 你有没有被逼到命运的墙角？有没有试过触碰想都不敢想的事情的底线？那一瞬间你会怎么问自己？ ◆ 思维里的墙如何限制我们 愿上帝赐我一个平静的心，去接纳我所不能改变的事物；赐我无限勇气，去改变那有可能改变的东西；并且赐我智慧，去辨别这两者的差异。 ◆ 关于心智模式的几个观点 齐白石说：学我者生，似我者死。我说：学心智生，学心态死。 对一生进行充分规划永远都是一个好想法，但一定要记得写下来的时候要用铅笔，而且手边还要有块橡皮。——Adam Marchick ◆ 模仿比尔·盖茨就能成功？你死定了 模仿成功者就能成功，这是成功学的著名逻辑。当你真正开始实践，才发现很多东西是无法模仿的，这就是生活的逻辑 ◆ 努力就能成功？看看李嘉诚的创业奇迹 很多时候少听成功专家讲的话。所有的创业者多花点时间学习别人是怎么失败的，因为成功的原因有千千万万，失败的原因就一两个点。所以我的建议就是少听成功学讲座，真正的成功学是用心感受的，有一天你就是成功者，你讲任何话都是对的。 ◆ 成功，就是越走越近 成功的真正本义应该是：越走越近。 ◆ 你现在就很成功 你的天花板是别人的地板，而你总在向上看，从来没有留意过窗边的风景。 ．美国哲学家厄尔·南丁格尔：成功就是逐渐实现有价值的理想。2．成功就是实现人生目标的过程。3．成功可以分为两部分：你怎样看待自己；别人怎么看待你。4．成功=what you have been / what you should be。 罗兰：成功的意义应该是发挥了自己的所长，尽了自己的努力之后，所感到的一种无愧于心的收获之乐，而不是为了虚荣心或金钱。 现代社会的三种毒药：消费主义、性自由和成功学。消费主义以品牌为噱头，以时尚为药效，恋物成瘾。性自由以人性为噱头，以性爱为药效，纵欲成瘾。成功学以速成为噱头，以名利为药效，误导急于走捷径成为人上人的年轻人投身其中，投机成瘾。 ◆ 拒绝受害，现在就掌控你的生命 你看明白了吗？如果你愿意，你总是可以掌控些什么。你没有必要得到允许才开始学习，你也没有必要得到机会才开始努力。如果你愿意，你现在就能够为这件事情做些什么，除非你的受害者模式让你深深陷入抱怨与自怜中。拒绝受害，掌控你的生命。 ◆ 小人物也能有大掌控 面对不公平，无聊的人抱怨、懦弱的人受害、聪明的人跟随、清高的人躲避，而勇敢而智慧的人尝试用自己的方式来改变，掌控我们这个世界。我尊敬那些用自己的方式改变世界不公平的人，一个人面对不公平的态度，最能反映他的品德。 ◆ 谁动了我们的幸福 你可以按照社会设置好的方式去工作、设置好的方式去竞争、设置好的方式去交换，但是一定不能按照社会设置好的方式去幸福。否则，你就彻底废了。 ◆ 我们把自己弄丢了 我们很听话地长成为一群有脑无心的人，一群有逻辑没情感的人，一群讲高度不讲尊重的人。我们长成为别人要求的样子，并且以此为荣。就这样，我们把自己弄丢了。 ◆ 幸福不是用来讲的——口是心非原则 从心理学来说，一个人缺什么，就会投射到身边人的身上，他会觉得身边的其他人也觉得自己缺。于是他就会不断地表达说自己其实不缺，一不小心就过了。这个结果就是，他不断地表达的东西就是自己最缺乏的——这个法则我把它命名为口是心非法则。此法则看人非常有用：你看一个人觉得自己缺什么，你就看他不断强调什么就好了。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript(1)]]></title>
    <url>%2F2019%2F08%2F21%2Ftypescript-1%2F</url>
    <content type="text"><![CDATA[类型思维强类型语言：强类型语言在没有强制类型转化前，不允许两种不同类型的变量相互操作。弱类型语言：弱类型语言允许将一块内存看做多种类型。比如直接将整型变量与字符变量相加。 静态类型语言：编译阶段确定所有变量的类型动态类型语言：执行阶段确定所有变量的类型（js） 具体解释 基本类型：枚举： 一个有名字的常量集合，类似通过通讯录，只需要记住名字而不必在意具体数据 提高可读性和可维护性 分为数字枚举和字符串枚举 枚举的实现原理 反向映射 字符串枚举不能反向映射 数字枚举和字符串枚举一起使用 异构枚举 接口：TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑思考的工具]]></title>
    <url>%2F2019%2F08%2F19%2F%E9%80%BB%E8%BE%91%E6%80%9D%E8%80%83%E7%9A%84%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[古语有言‘学而不思则罔’，读再多的书，看再多的信息，不会加以辨别全盘接受或者彻底否定，也没有一点用处。这是一个信息爆炸的时代，每天我们都会接触到各种各样的信息，如何处理这些信息呢 下面是一些方法 不妨试试 证有不证无不存在的东西，就没有办法被证明，此时只需要证明存在，便可以驳倒“不存在”的观点。生活中我们也经常陷入一种困境，即抓着自己的情绪不放，试图证明一个不存在的东西。对立成因的谬误:有时候，事情的因果关系可能是相反，符合统计学的规律并不代表符合因果关系。一个简单的判断标准：是否可以做实验诉诸完美的谬误：凡事不必追求完美，在有一个大体的计划时，就去做好了，在尝试中完善自己的想法。追求思想上的完美，大多数会成为行动上的矮子。滑坡谬误：将小事情放大到无限大这其实也是归谬法的应用，即确定一个观点，将这个推演到极致从而得出一个荒谬的结论。但是其实，好多小事情，并不会产生那么大的坏影响不要对自己太苛刻~重复命名的谬误：翻来覆去的废话，并没有以新观点去证明某个观点。同时也可以用这种方法来忽悠人哈哈归因谬误：人都趋向于自我合理化，把自己的成功归功于自己的聪明，失败归咎于坏运气。这种思维容易让人陷入自我安慰和自我麻痹，并不能从成功和失败中吸取经验和教训。分解的谬误：人们总是倾向于相信自己相信的东西，从一个整体中，有意无意地挑出自己符合自己信念的东西，用以加深自己的信念，这种观念容易让人陷入一种盲目的自信和狭隘，从而产生一种错误的信念，并且愈发坚定，在错误的道路上坚定的越走越远。 非黑即白的二分法谬误世界并不是黑白的，大多数事情其实处于暧昧的灰色地带，武断的下结论，说它好，或者不好，都是把问题过于简单化，这样，通常能得出一些鸡汤式的结论，除了自我合理化之外，并没有实际的用处。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客与画家]]></title>
    <url>%2F2019%2F08%2F18%2F%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[读《黑客与画家有感》]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[富爸爸穷爸爸]]></title>
    <url>%2F2019%2F08%2F11%2F%E5%AF%8C%E7%88%B8%E7%88%B8%E7%A9%B7%E7%88%B8%E7%88%B8%2F</url>
    <content type="text"><![CDATA[《富爸爸，穷爸爸》作为一本理财知识的入门书简直要被推烂了。前段时间一直都处于一种很丧气的状态。逼着自己看了好多书，渐渐的体验到了看书的乐趣和思考的乐趣。虽然作者所处的年代和国情跟我们不一样，但是还是有很多通用的方法论，甚至可以用到生活的其他方面。以下，是第二遍看完这本书之后的梳理~ 一个人的观念对他一生的影响是巨大的，最底层的观念，指导着生活中大大小小的行为，从而决定我们怎样过这一生~在理财方面，大多数人在想要什么超出自己承受范围的东西时，第一反应通常是“我可买不起”，这时候，倘若我们换个思路呢 想一想“我想要这个东西，我要怎么才能得到这个东西”。这里我们不是在鼓吹消费主义，而是通过‘想要’去促进我们思考。 1.富人不为钱工作这个标题，有点标题党了···作者意在说明穷人和中产阶级对钱更多的是不能拥有而带来的恐惧，因此陷入一种“起床、上班、付账、再起床、在上班、再付帐”的循环中，他们的生活从此就被这两种感觉所控制：恐惧和贪婪。而我们要学会的就是，去支配金钱而不是让金钱支配我们。如果不先控制恐惧和欲望，即使获得高薪，也只不过是金钱的奴隶而已。 2.为什么要教授财务知识造成贫困和财务问题的主要原因是无知和恐惧，因此学习财务知识和提升自己整体认知，十分重要。首先要弄明白资产和负债的区别，什么是资产，而什么又是负债呢？简言之，资产是能把钱放进你口袋的东西，而负债是把钱从你口袋里取走的东西。 3.关注自己的事业为了财务安全，人们需要关注自己的事业。而事业并不意味着工作。事业的重心应该是资产项，而不是收入项。谨记资产与负债的区别，并且去买入资产项。 4.税收的历史和公司的力量学习财商：财商主要是由四个部分构成：一是会计、二是投资、三是了解市场、四是法律。这四个方面的专业度很高，但其实我们并不需要去系统的学习这几个学科，尤其是法律，个人认为，一般情况下，有基本的常识足矣。 5.富人的投资金钱不是真实的资产，他是我们大家都认可的东西，一种价值的衡量。常言道，风险越大，收益越大。但是我们还是可以通过对技术知识的了解和智慧来尽可能的降低风险，但凡有用的东西，都不是绝对的正确，面对风险，我们要尽可能地做好准备做好决策，选择概率较大地可能性。风险无法回避，回避风险，也就意味着断绝了所有可能性。 6.学会不为钱工作又是一个标题党···这里的不为钱工作，其实是说不要为了工作而工作，忽略其他的东西，比如人际交往，自我营销之类，而一头扎进工作的专业方向。当然，也有人在一个方向深耕出了巨大成就的，这样的人，我们任然对他们表示敬佩。 7.克服困难作者认为，掌握了财务知识却还不能积累丰厚的资产的人，主要有以下几个问题： 1.恐惧心理：对亏钱的恐惧 2.愤世嫉俗：总有人会在我们要做什么在他们眼里看似疯狂的事情时，指指点点，杞人忧天，这或许会让我们产生自我怀疑。当然，有些人的意见，也不无道理，所以最重要还是自己理性的分析和判断。 3.懒惰：懒惰最普遍的表现形式之一就是通过做不重要的事情假装自己很忙从而逃避真正需要做的事情。最大的懒惰，是思维上的懒惰。 4.不良习惯：不良的花钱习惯，习惯的力量真是巨大呀~ 5.自负：傲慢是自大和无知的结合体。无知使我们失去很多东西 我个人还想再加一条，运气~ 8.开始行动首先，开始读这本书吧其中许多东西，自己去细细体会。最近最喜欢的四个字，就是知行合一。 我所理解的知行合一，就是行动要跟得上认知，不要出于畏难情绪就停止思考，好多事情，其实做起来并没有想象中那么难呀~最后，晚安~愿每个人，都能在经历过痛苦之后，得偿所愿~]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿德勒《人，可以做得到任何事》]]></title>
    <url>%2F2019%2F08%2F10%2F%E9%98%BF%E5%BE%B7%E5%8B%92%E3%80%8A%E4%BA%BA%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%81%9A%E5%BE%97%E5%88%B0%E4%BB%BB%E4%BD%95%E4%BA%8B%E3%80%8B%2F</url>
    <content type="text"><![CDATA[阿德勒的这本《人，做得到任何事情》是在哪儿看到的来着。不甚记得。一直觉得自己是个很自卑的人，想要摆脱这种状态，所以积极的寻找这类书看。也不知道是不是因为最近的心绪一直不宁，太浮躁，还是不太能够理解书中的内容，有点不太能看下去，但是还是 梳理下内容吧。 1.生活的科学2.自卑情结3.优越情节4.人生风格5.早期记忆6.态度与行动7.梦与梦的解析8.问题儿童及其教育9.社会问题与社会适应10.社会感、常识与自卑情结11.爱情与婚姻12.性与性的问题]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哲学的慰藉]]></title>
    <url>%2F2019%2F08%2F03%2F%E5%93%B2%E5%AD%A6%E7%9A%84%E6%85%B0%E8%97%89%2F</url>
    <content type="text"><![CDATA[哲学给人以慰藉 1.对与世不合的慰藉（苏格拉底） 传统的成见往往不是从无懈可击的推理中得来的，而是从及实际的混沌头脑中涌现出来的。现存的不一定是合理的。 苏格拉底的思辨方法：取一种为世所认定的常识论断；想象一下这一论断可能是错的；如果对于这一论断能找到例外的情况，那么原来的定义就是错的，或者至少不准确。最初的论断必须考虑到以上例外并将之精确细腻地表达；思考的产物总是优于直觉。 如果我们做不到这样的泰然自若，若果我们听了几句对我们的性格或业绩的严厉批评就忍不住掉眼泪，那可能是因为我们相信自己正确的能力主要是由于他人的赞许构成的。我们对于不受使人喜欢很在意，不仅是出于实用的理由——例如生存或升迁，更重要的是世人的嘲弄似乎是一种信号，毫不含糊地表明我们已经误入歧途。苏格拉底自然会承认我们有时可能是错的，我们的观点恶意怀疑，但是他会提出一项至关重要的细节来改变我们对真理与不受世人喜爱之间的关系的认知：我们的思想和生活方式的错误绝不能简单地以遭到反对来证明。我们应该关心的不是反对我们的人数，而是他们反对的理由有多充分。 批评的价值取决于批评者的思想程序，而不是人数的多少或者是他们所在的阶层。 一种思想或行动是否有价值不取决于它广受赞同或则广受攻击，而取决于它是否合乎逻辑规则。 2.对缺少钱财的慰藉（伊壁鸠鲁） 我们灵魂对自身的病痛并不见得比我们身体对病痛陈述得更清楚，我们凭直觉的诊断也不会比身体的诊断更准确。钻洞疗法象征着我们理解自身有多困难，这一象征意义既适用于肉体也适用于精神。 我们应该停止凭第一直觉形式，而应该审视我们的欲望是否合乎理性，其方法类似一百年前的苏格拉底用以评价伦理定义的诘难法。哲学可以提出有时看来与直觉相反的病因诊断，从而引导我们达到优异的治疗和真正的快乐。 真正的朋友不以世俗的标准来衡量我们，他们看重的是我们的本质;就像理想的父母一样，他们对我们的爱不以身穿旧衣服，承认今年没赚多少钱，都不会于心不安。追求财富的欲望不一定单纯出自对奢侈生活的渴望，更重要哦的动机可能是希望的得到别人赞赏和善待。我么追求发财的最大目的可能就是要获得别人的尊重和关注，否则他人就会对我们视而不见。 如果能合乎理性地思考生命有限地问题，就会意识到人一死，物我两忘，复归于无。要到来时自然到来，为此而预先担忧是庸人自扰。事先对永远不会经历地境界妄自惊扰是没有意义的。 以下诘问法用于一切欲望：如果我们所渴望的得以实现，对我会怎样？如果实现不了，又会怎样？ 对于我们不理解的需要，昂贵的东西看起来好像是适当的解决办法。我们所需要的精神的东西在物质世界中被仿造。我们需要的是重整自己的思想，却为新的货架所引诱。 不论我们觉得海外探险多么了不起，最终衡量其价值的是它引起了多少快感：我们最终诉诸快感，用这一感觉来判断一切善。由于社会财富的增加并不足以保证快乐随之增进，伊比鸠鲁就会说，昂贵物品所迎合的需求并不能作为快乐的基础。 3.对受挫折的慰藉 根据塞内加的看法，促使我们发怒的原因是我们对世界和对他人持有过分乐观的观念，这种乐观达到危险的程度。 怒气来自一种信念，这种信念发源于近乎戏剧性的乐观，但其后果却是悲剧性的。 我们的思想应该实现准备迎接所有的问题，我们应该考虑的不是惯常发生的事，而是有可能发生的事。 命运之神的干预，不论是仁慈还是凶恶，使人的命途无常。 如果你想消除一切担心，那么请设想你所害怕的一切都会发生。 智者什么也不会失去。万物皆备于他一身。智者是自足的，如果他因疾病或战争而失去一只手，或者某种意外事故使他失去一目或双目，他会满足于剩给他的那些。 不把错误的解释强加于一切事物。 当一条狗拴在一辆车上时，如果它愿意跟着走，它就被拉着，同时跟着走，这样它自发的行动与“必然”巧合。但是如果它不想跟着走，反正它也得被迫跟着走。人也是一样：即使他们不愿意，他们也得被迫跟着命定的道路走。 把并非必然的事当做必然接受下来同对必然的事进行反抗一样不合理。我们可能误把非必然当做必然而拒绝可能之事，我们也可能拒绝承认必然而妄想不可能之事。对二者作正确的区分，就需要理性。 理性使我们能够决定，什么时候我们的愿望与现实的冲突事无法调和的，于是命令我们甘心情愿地，而不是怨恨满怀地接受必然。我们可能无力改变某些事态，但还是有自由决定对待它们地态度。正是从自发地接受必然之中，我们找到了明白无误地自由。24.对缺陷的慰藉 问彼何所知，答曰所知唯一事，即我无所知，是为古往今来上上智。 当我们被指责为不正常时，还有一种慰藉是友谊。朋友总是能善待我们，把我们看做比一般人心目中更为正常的人。我们可以向朋友倾诉一些不足与外人道的看法，通常这些看法会被指责为太刻薄，张扬性欲，让人绝望，狡猾，软弱——友谊是一种小小的阴谋，用来对付一般人所谓的合理的事物。 全部道德哲学都能附属于一个人平凡的私生活，并不亚于其他更丰富的生活。 善良而平凡的生活，努力追求智慧而从未远离愚蠢，有此成就足矣。 5.对伤心的慰藉（阿瑟 叔本华） 在他的生活和不幸的过程中，他着眼与人类整体的命运多余自己的命运，因而行为更像是个知者，而不是受难者。 6.困难中的慰藉（弗里德里希 尼采） 对于我所关心的人，我祝愿他们受苦受难，孤寂凄凉，疾病缠身，受尽虐待，备尝屈辱——我希望他们不得幸免于以下的体验：深刻的自轻自贱，缺乏自信的折磨，一败涂地的悲惨境界。 对所有谋求心满意足的人来说，首先必须承认达到完美是不可能的，这样就可以避免我们在追求完美的过程中最常遇到的麻烦和焦虑：目标不应当指向生活中的欢乐和愉悦，而是指向尽可能避免那无数恶事 一个人最大的幸运就是没有经历巨大的身心痛苦而度过一生。 我们知道生活是由苦难构成的；我们越是努力去享受它，就越受它的奴役，所以应当摈弃种种生活物品而实行禁欲。 人的自我完成曾不是通过避免痛苦，而是通过承认痛苦是通向任何善的自然的，毕竟的步骤而达到的。 人的计划最圆满的完成看来是与某种成都 的磨难分不开的，我们最大乐趣的源泉是与我们最大的痛苦别扭地联系在一起地。 不过，单有吓人地困难当然是远远不够的。一切人生都是艰难的；而其中有些得以实现完美，是对痛苦的态度使然。每一次痛苦都是一个本能的信号，说明有些事不对头，而其孕育的结果是好事坏全赖承受者的只会和力量。焦虑可能导致惊慌失措，也可能导致对缺失的准确分析。不公平感可能引出谋杀，也可能引出开创性的经济理论。忌妒可能引起怨恨，也可能激发起与对手竞争的决心，从而传做出杰作。 仇恨，忌妒，贪婪，权欲等情感都是生命的必要条件，是贯穿于整个人生的经营中的基本要素。如果把所有的负面的根砍掉，也就等于扼杀了可能在枝头结出的正面的花果的元素。使我们感到窘迫的不应该是困难本身，而是我们无能让困难结出美丽的果实。 如果你拒绝苦难在你身上逗留哪怕是1小时，如果你总是早早地防范可能地痛苦于未然，如果你把苦难与不快当做应当消灭的邪恶与仇恨，当作生存的缺点，那么，很清楚，你心中怀有安逸的宗教。生活在安逸中的人啊，你们真不知人类幸福为何物因为幸福与不幸是两姐妹，甚至是孪生姐妹，要么一起长大，要么一起永远保持矮小。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于五年之后的畅想]]></title>
    <url>%2F2019%2F07%2F28%2F%E5%85%B3%E4%BA%8E%E4%BA%94%E5%B9%B4%E4%B9%8B%E5%90%8E%E7%9A%84%E7%95%85%E6%83%B3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[普鲁斯特问卷]]></title>
    <url>%2F2019%2F07%2F26%2F%E6%99%AE%E9%B2%81%E6%96%AF%E7%89%B9%E9%97%AE%E5%8D%B7%2F</url>
    <content type="text"><![CDATA[普鲁斯特问卷一年一次吧观己观心 1.你认为最完美的快乐是怎样的？不用考虑现实压力 内心充盈 有想做的事情 而且可以去做 2.你最希望拥有哪种才华？其实我没啥想要的才华 我觉得拥有一样东西必然有利有弊 有啥我就接受 没有不强求 3.你最恐惧的是什么？我太丧了 我觉得没啥恐惧的 恐惧失去希望吧 但是又感觉总能找到活着的意义的 4.你目前的心境怎样？迷茫 害怕未知的一切 怕做不到自己想要的样子 5.还在世的人中你最钦佩的是谁？我也没有钦佩的人 因为好像一直很冷漠 不关心和我无关的人 6.你认为自己最伟大的成就是什么？没有什么伟大的成就 7.你自己的哪个特点让你最觉得痛恨？执行力差 8.你最喜欢的旅行是哪一次？没有 9.你最痛恨别人的什么特点？我谈不上痛恨 但我不喜欢跟虚伪的人打交道 10.你最珍惜的财产是什么？珍惜的财产是 我的健康 时间 与人之间的情感联系 11.你认为最奢侈的是什么？自由和勇气 12.你认为程度最浅的痛苦是什么？身体上的痛苦我觉得是程度最浅的 13.你认为哪种美德是被过高的评估的？我是觉得 好多所谓美德 都是别人拿来约束别人的 是为了自己作恶方便 14.你最喜欢的职业是什么？挣钱贼多的职业哈哈哈 还有可以体验各种各样的角色的 15.你对自己的外表哪一点不满意？都不满意 唯一觉得还行 就眼睛 16.你最后悔的事情是什么？要说有后悔的 我后悔以前没有听话好好读书 沉迷于早恋了 17.还在世的人中你最鄙视的是谁？没有 18.你最喜欢男性身上的什么特质？上进 真诚 19.你使用过的最多的单词或者是词语是什么？我 还有 都行随便 20.你最喜欢女性身上的什么特质？勇敢 独立 同时保留女性自己的特点 21.你最伤痛的事是什么？被亲人欺骗背叛从而导致的对人性的怀疑和失望 22.你最看重朋友的什么特点？真诚 23.你这一生中最爱的人或东西是什么？我没啥最爱的 啥都可以失去 但是不失去最好 24.你希望以什么样的方式死去？突然死掉 来不及反应 也没啥后悔遗憾的时间 25.何时何地让你感觉到最快乐？跟亲人朋友待在一起 内心平和的时候~ 26.如果你可以改变你家庭的一件事，那会是什么？我就希望 我们家条件能更好点 这样我父母大概就不会老是为钱的问题吵架了 27.如果你能选择的话，你希望让什么重现？小时候早上醒的时候我妈妈在给我织毛衣吧~ 在脑子里重现好多遍 28.你的座右铭是什么？ 知行合一]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[background-clip]]></title>
    <url>%2F2019%2F07%2F25%2Fbackground-clip%2F</url>
    <content type="text"><![CDATA[今日份的需求出现了一个bug琢磨了好一会解决了，记录一下 需求是这样的别的浏览器都显示的好正常的,但是在火狐中，显示的效果就是这样的了经过多次尝试，发现去掉左边的背景色，边框就能正常显示出来了但是需求表示左边这块就是要有不一样的颜色，怎么办呢面向浏览器编程的我们打开了谷歌 搜索结果中出现了这么一个属性background-clip嗯，根据实际情况酌情使用]]></content>
      <tags>
        <tag>前端</tag>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fetch]]></title>
    <url>%2F2019%2F07%2F23%2Ffetch%2F</url>
    <content type="text"><![CDATA[最近在写的一个项目用到了fetch,本着边写边学的原则，终于到了我要开始学习fetch的时候了。首先是定义： fetchfetch基于promise的语法结构]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小学问]]></title>
    <url>%2F2019%2F07%2F22%2F%E5%B0%8F%E5%AD%A6%E9%97%AE%2F</url>
    <content type="text"><![CDATA[马东马薇薇邱晨黄执中 证有不证无 对立成因的谬误 诉诸完美的谬误() 滑坡谬误(破解方法：就事论事，不做发散性的思考) 重复命名谬误（命名谬误就是把相同意思的话语，用不同的表述再说一遍，或者给一种行为起一个名字作为行为的解释。） 归因谬误 分解的谬误 二分法的谬误（凡事并不是非黑即白） 人身攻击思路 思考一下，你的工作的本质是什么工作的本质 劳动价值 你为什么选择这样一份工作为了劳务报酬 自律来自于内心深处的渴望对自己的想法 反问三次 明白内心深处的需求 并从需求开始 假设自己是这样的一个人 逆向思维 从而确定自己到底应该怎么做]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《对赌》]]></title>
    <url>%2F2019%2F07%2F20%2F%E8%AF%BB%E3%80%8A%E5%AF%B9%E8%B5%8C%E3%80%8B%2F</url>
    <content type="text"><![CDATA[最近看完了安妮杜克的《对赌》，私以为是一本关于方法论的书，有那么一点点的啰嗦了。不过这本书对我本身的一些观念造成了些许冲击。 我们的生活充满着许多不确定的因素，运气在能否做好一件事情中占了很大一部分。从结果去评判一个决策的好坏是不理智的行为。 我们的思维分为审慎思维和反射思维，大多数情况下，我们达成目标的过程中执行的大都是反射思维，但同时也需要意识到，改变大脑是不可能的，只能够在现有的思维局限里更好的利用我们的大脑。 承认自己对某事的无知并不是一件可耻的事情。获取知识的第一步应该是明确自己不知道什么。 我们无法确切的知道某件事情将会如何发生，学会接受不确定性，并尽量去弄清楚不确定的程度，而不是专注于如何才能确定。根据不同结果的发生概率来最初最佳判断。这些判断的准确性取决于拥有多少信息以及是否具有丰富的判断经验。 当我们以发生概率为依据做出决定却得出相反的结果时，并不意味着我们是错误的，仅仅说明在一系列可预期的未来中发生了不可控制的意外。 脱离非黑即白的思维模式，在这两种极端之间的灰色地带中调整和校正自己的决策。 所有的决策都是对赌。任何一个选择都是有机会成本的。我们习以为常的在各种选择中做决定，讲资源置于风险之中，评估不同结果的可能性，并考虑什么才是我们重视的。 信念强则赢面大，人们总是基于自己的信念来下注。人类是容易轻信的动物，很容易相信，却很难产生怀疑。这种相信，通常是非理性的理解，而不是理性的评估。人们倾向于把所有的陈述都推断为事实。这表明人类默认的设置是相信我们听到的一切都是真实的。一些无关紧要的日常信念显然是错误的，看似也没什么大不了，但这是人类信念形成的一般过程，它在一些可能会产生重大后果的方面发挥着一些重要作用。所以要及时根据新信息来更新我们的信念，那么这种随意的信念形成过程就会导致比较小的问题。 我们的思维月客观，我们的信念就会变得越准确，从长远来看，赢得堵住的人都持有更为准确的信念。 从经历的事情，结果中学习。避免产生自利性偏差，客观的评价过去的决策。以积极的方式更新自我形象。 不要随意指责他人，从他人的错误中反思自己的问题。不要片面的去评价他人对错，去分析其中深层的原因和动机。 把结果归类，分为运气和技能。这么做能让我们更加理性，明白过去的事情中，我们做对了什么，做错了什么。有助于培养我们实现长期目标所必须的习惯。 发现自己可以控制的事情，思考如何改进相关决策。 对赌思维通过鼓励我们明确自己知道什么不知道什么，以及我们对自己的信念和预测的信心水平来将怀疑主义具体化。这会让我们更加接近客观事实。 这种我们都不得不以牺牲未来自我为代价来满足当前自我的倾向被称为时间贴现，是人性中本来固有的东西。 后悔的情绪并没有错，如果发生在下一次类似的决策之前，那么是有可能帮我们避免一次糟糕的决策的。 从长远的角度看待问题可以培养更加理性的思维方式。 尝试对未来做一个规划和设想，尽可能将所有的好的坏的情况都考虑进去。 尝试从一个积极的未来开始逆向思考，想象自己已经成功了，然后思考目标实现的过程，类似动态规划，哈哈哈。 而从一个负面的未来开始逆向思考，有助于我们提前制定好应急的计划。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于价值观：什么更重要]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%85%B3%E4%BA%8E%E4%BB%B7%E5%80%BC%E8%A7%82%EF%BC%9A%E4%BB%80%E4%B9%88%E6%9B%B4%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[最近依然想很多，但是没那么难受，没有那种撕裂的感觉了~ 事情正在朝好的方向发展中 关于三观： 价值观什么东西，最重要呢我曾经列出了人生中最不愿失去的五样东西：健康、家人、金钱、色相。最后一个 我之前没想到，现在想想 应该是独立的思想。排名不分先后，我也不知道怎么分先后。或许在一些极端情况下是可以牺牲其中某些坚持，来换取另一些东西的。没法区分先后顺序，也没必要。 人生观人生观啊，我觉得人生就是一场体验。人生啊，就应该体验各种各样的东西，遇见各种各样的灵魂。但是真的会很难过啊，如果遇到的人，跟自己相克，无论是分开还是磨合，都是一个很撕裂的过程。不过从中真的学到很多。我对人生的态度消极，但也在努力去追求更好的东西。 世界观世界观啊 没怎么观过世界，所以也谈不上世界观。 说到底三观 到底是什么东西，一时半会也说不清。可能因为经历的太少，也可能是在灵魂碰撞或是契合的时候才能够感知到的吧。 愿永远热忱 永远保持向死而生的勇气和能力。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决图片宽高自适应需求：object-fit]]></title>
    <url>%2F2019%2F07%2F17%2F%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94%E9%9C%80%E6%B1%82%EF%BC%9Aobject-fit%2F</url>
    <content type="text"><![CDATA[在日常的需求中，有这么一个场景：文本中可能会穿插一些图片，但是这个图片的大小啊长宽比啊什么的 都是不确定的。但我们要它美观啊，好看啊，所以要给它一个确定的大小，但同时让展示出来效果尽可能是图片的主体而不是边边角角。这时候，有一个不常见的利器了 object-fit mdn的官方解释是 指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。其属性值有fill:被替换的内容正好填充元素的内容框。整个对象将完全填充此框。如果对象的宽高比与内容框不相匹配，那么该对象将被拉伸以适应内容框。contain:被替换的内容将被缩放，以在填充元素的内容框时保持其宽高比。 整个对象在填充盒子的同时保留其长宽比，因此如果宽高比与框的宽高比不匹配，该对象将被添加“黑边”。cover:被替换的内容在保持其宽高比的同时填充元素的整个内容框。如果对象的宽高比与内容框不相匹配，该对象将被剪裁以适应内容框。none:被替换的内容将保持其原有的尺寸。scale-down:内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。 而我在开头提到的需求场景是可以用cover属性值来实现了~css果然是博大精深啊值得好好学习mdn地址]]></content>
      <tags>
        <tag>前端</tag>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人性的弱点]]></title>
    <url>%2F2019%2F07%2F16%2F%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9%2F</url>
    <content type="text"><![CDATA[人性的弱点读后整理以及有感而发 与人相处的基本技巧 不要批评，责怪或者抱怨别人，尽量去了解，去设身处地为别人思考，但同时，在理解的基础上有自己的原则性。 真诚的赞赏他人，给他想要的东西是与人交往最容易获取好感的方式，而每个人，都渴望得到认同，渴望实现自我价值。按照弗洛伊德的说法，一个人做事的动机不外乎两点：性冲动和渴望伟大。 激发他人强烈的需求。天底下只有一种方法可以影响他人，就是提出他们的需要，并且让他们知道怎样去获得。成功的人际关系在于你捕捉对方观点的能力；还有，看一件事须兼顾你和对方的不同角度。 我们所相处的对象，并不是绝对理性的动物，而是充满了情绪变化、成见、自负和虚荣的东西。 平安快乐的要诀 保持自我。一般人的心智能力使用率不超过10％，大部分人不太了解自己还有什么才能。 ◆ 一个人最糟的是不能成为自己，并且在身体与心灵中保持自我。 人往往都活在自己所设的限制中，我们拥有各式各样的资源，却常常不能成功地运用它们。你的经验、环境和遗传造就了你。不管好坏，你只有好好经营自己的小花园，也不论好坏，你只有在生命的管弦乐中演奏好自己的一份乐器。 拥有良好的工作习惯。没有人能永远按照事情的轻重程度去做事。但按部就班地做事，总比想到什么就做什么要好得多。 保持桌面整洁 事情排好优先级 遇到问题马上解决，而不是一拖再拖 不要忘记，快乐并非取决于你是什么人，或你拥有什么，它完全来自于你的思想。 学会放松。大部分疲劳的原因源于精神因素，真正因生理消耗而产生的疲劳是很少的。 疲劳往往是我们自己的忧烦挫折和不满引起的。 活在当下。你所认为的，并非真正的你；反倒是你怎么想，你就是什么样的人。行动似乎跟着感觉走，其实行动与感觉是并行的，如果意志控制行动，也就能间接控制感觉。只要将一个人内心的态度由恐惧转为奋斗，就能克服任何障碍。 伤害人的并非事件本身，而是他对事件的看法。而对事件的看法完全取决于我们自己。 行动似乎跟着感觉走，其实行动与感觉是并行的，多以意志控制行动，也就能间接控制感觉。 也就是说，我们虽然不能一下决心，就能立即改变情绪，但是我们确实可以做到改变行动。当我们改变行动时，就能自动改变感觉。 人如果改变对事与人的看法，事与人就对他发生改变……如果一个人的想法有激烈的改变，他会惊讶地发现生活中的状况也有急速的改变。人的内心都有一股神奇的力量，那就是自我……所有的人都是自己思想的产物……人提升了自己的思想，才能上进，克服并完成某些事。 1234567891011活在今天 1．今天我要很开心。因为林肯说过：“多半的人都可以决定自己要有多快乐。”快乐源于人的内心，它并非外来之物。 2．今天我要调适自己，而非调整世界来配合我。我要让自己配合我的家庭、事业与机运。 3．今天我要照顾自己的身体。我要运动、关心它、滋养它、不滥用它、不忽略它，使它成为我心灵的殿堂。 4．今天我要强化我的心灵。我要学习，不让心灵闲置，我将阅读需要专注、思想与努力的读物。 5．今天我要由三方面操演我的心灵：我要默默地为某人做一件好事。再起码做两件我不想做的事，照威廉·詹姆士所说的，只是为了让心灵演练，不致怠惰。 6．今天我要使自己怡人。我要使自己看来愉悦，穿着合宜，轻声慢语，举止恰当，多予赞赏，少作批评，不找任何事的毛病，也不想挑任何人的缺点。 7．今天我要全心全意只活这一天，不去想我整个的人生。一天工作12小时固然很好，如果想到一辈子都得如此，可能会先吓坏我自己。 8．今天我要制订计划。我要计划每小时要做的事。可能不能完全遵行，但我还是要计划，为的是避免仓促及犹豫不决。 9．今天我要给自己保留半小时轻松时间。我要用这半小时祈祷，想想我人生的远景。 10．今天我将无所畏惧，特别是我不怕更快乐，更享受人生的美好；也不怕失去爱人，相信我爱的人亦爱我。 不要对敌人心存报复。即使我们没办法爱我们的敌人，起码也应该多爱自己一点。我们应该不让敌人控制我们的心情、健康和容貌。 要想真正宽恕忘却我们的敌人，最有效的办法还是诉诸比我们更强大的力量。如果我们可以忘记一切，侮辱也就无足轻重了。永远不要对敌人心存报复，那样对自己的伤害将大于对别人的伤害。 不要指望别人感激你的付出。 忘记感谢乃是人的天性，如果我们一直期望别人感恩，多半是自寻烦恼。 要追求真正的快乐，就必须抛弃别人会不会感激的念头，只享受付出的快乐。与其担心他人不知感恩，不如不予预期。 意识到你所拥有的，并对此心存感激。 将不利因素转化成有利的因素。真正的快乐不见得是愉悦的，它多半是一种胜利。 人生最重要的不是以你的所得投资，任何人都可以这样做。真正重要的是如何从损失中获利。这才需要智慧，才能显示出人的上智下愚。 批评他人是人性中一种自我满足。 凡事尽力而为，相信自己所做的事情，就不要在意别人怎么说。 学会自我反思，自我批评。 如何使人喜欢你 真诚的关心他人。凡不关心别人的人，必会在有生之年遭受重大困难，并且大大伤害到其他人。也就是这种人，导致了人类的种种错失。 不要忘记微笑。 千万别忘记他人姓名 学会倾听他人讲话，鼓励别人谈论自己。迎合他人兴趣 让他人感觉到自己的重要。人类本质里最深层的驱动力就是希望具有重要性。 如何赢得他人赞同 不要争论不休。天下只有一种方法能得到辩论的最大利益——那就是避免辩论。 如果你辩论、争强、反对，你或许有时获得胜利；但这种胜利是空洞的，因为你永远得不到对方的好感了。 凡决意成功的人，不能费时于个人的成见，更不能费时去承受结果，包括他无法控制自己的脾气，丧失自制。 尊重他人意见。我们犯错的时候，也许会私下承认。当然，假如别人的态度温和一些，或显得有些技巧，我们也会向他们认错，甚至自认为坦白、心胸宽大。但是，假如对方有意让你难堪，情况又不同了。我现在确信，如果你过于直率地指出别人的错误，再好的意见也不会被人接受，甚至会受到很大的伤害。你剥夺了别人的自尊，也让自己成为讨论中最不受欢迎的一部分。 如果错了，当即承认。 友善的对待他人。 当你与别人交谈的时候，不要先讨论你不同意的事，要先强调，而且不停地强调——你所同意的事。 给他人说话的机会。 别将自己的意愿强加于人。 善于从他人角度考虑问题。 同情对方的意愿。 激发他人去产生一种高尚的动机。 让他人不断面临挑战 如何更好的说服他人 称赞并欣赏他人 间接委婉的指出他人错误 不要用 虽然 但是这样的句式 不要总是责怪他人 没有人喜欢受人指使，要想办法激发他人主动去做的欲望 保全他人的面子 激励他人获得成功 鼓励更容易使人改正错误 学会给他人授权 让你的家庭幸福快乐 切勿喋喋不休 不要试图改造对方 不要批评对方 真诚的欣赏对方 注重生活中的小事 今日的婚姻是否美满，要看双方的心理是否成熟。也就是说，他们是否了解自己、了解自己与对方的关系，并且愿意彼此分担责任，以增进对方的快乐与福利。”克瑞尔院长又进一步提到了家庭关系的维持，是“凭借内在价值的满足，如感情、友谊、价值观等，而且不能用强求的方式取得。” 学会倾听，善解人意 要能干，在方方面面能够独当一面，但是又要适当的藏起锋芒，给对方一些付出的机会。 如何使你变得更加成熟 勇于承担责任，不要总从别的地方找借口 困难并不意味着不幸，不要把不幸怪罪到困难上。 对喜欢规避责任的人来说，困难则成了最好的挡箭牌。 假如每个人成天都认为环境不好，当然就会把自己的过失诿诸“缺陷”或种种其他原因。 不成熟的人随时可以把自己与众不同的地方看成是缺陷、是障碍，然后期望自己能受到特别的待遇。成熟的人则不然。 摆脱生活中的不幸。我们的生活被不幸遭遇分割得支离破碎的时候，只有时间可以把这些破片捡拾起来，并重新抚平。我们要给时间一个机会。在初受打击的时候，整个世界似乎停止运行，而我们的苦难也似乎永无止境。但无论如何，我们总得往前走，去履行生命计划中的种种目的。而一旦我们完成了这些生命中的种种运作，痛楚便会逐渐减轻。终有一天，我们又能唤起以往快乐的回忆，并且感受到被护佑，而不是被伤害。 拥有自己的信仰 每个人的生活遭遇都是独一无二的。尽管构成人体的基本因素相同，但我们每个人的生命都很奇妙地自成一格，绝不与人雷同。 心灵的成熟过程，是持续不断的自我发现、自我探寻的过程。除非我们先了解自己，否则我们很难去了解别人。 兴奋的品质是我们工作能否成功的极重要因素，因为情绪的动力是促成我们向前进的力量。 每天抽出时间独处，以进一步认识自己 要打破习惯的束缚 发现生活中什么东西最能让我们感到满足 学会喜欢你自己。不要对自己过度挑剔。 不要盲从因袭。你心灵的完整性是不可侵犯的。 不要令人生厌 外交的秘诀仅在5个字：我要喜欢你。要想赢得爱情，先要值得被爱；要想赢得友谊，先要表示友善；要想赢得别人对我们感兴趣，就得先要对他们发生兴趣——没有什么方法可以一劳永逸。 走出孤独忧郁的人生 99%的烦恼其实不会发生 忧虑是健康最大的敌人 能接受既成事实，这是克服随之而来的任何不幸的第一步。 能接受最坏的情况，就能在心理上让你发挥出新的能力。 忧虑最大的坏处就是摧毁我们集中精神的能力，一旦忧虑产生，我们的思想就会到处乱转，从而丧失作出决定的能力。 如果我们将忧虑的时间，用来寻找解决问题的答案，那忧虑就会在我们智慧的光芒下消失。一旦作出决定，当天就要付诸行动，同时要完全不理会责任问题，也不必担心后果。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公共组件整理]]></title>
    <url>%2F2019%2F07%2F16%2F%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前段时间经历了好大一段黑暗的时光呀整个人，像是被撕裂开来，碎成一片片，又努力拼凑起来。自我反省，自我安慰，最后跟自己和解。工作上也是，一直是繁琐的事情。改别人项目的bug 零零散散 扰得人不胜其烦。主要还是 在一个项目里，总也没有统一的标准，杂乱不堪。故而，整理一份自己的标准和通用的样式，用在以后的项目里。 移动端消除滚动条 1234567891011121314151617181920/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/::-webkit-scrollbar &#123;width: 0px;height: 0px;background-color: #F5F5F5;&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track &#123;-webkit-box-shadow: inset 0 0 1px rgba(0, 0, 0, 0);border-radius: 10px;background-color: #F5F5F5;&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb &#123;border-radius: 10px;-webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, .3);background-color: #555;&#125; 清除浮动 123456789.clear:after &#123; content: &apos;&apos;; display: block; clear: both;&#125;.clear &#123; zoom: 1;&#125; 内容超出隐藏 123456789101112.ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;.ellipsis2 &#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;&#125; css实现箭头 1234567891011121314151617181920212223242526272829303132.arrow-right &#123; display: inline-block; width: .8rem; height: .8rem; border-right: 1px solid #eee; border-top: 1px solid #eee; transform: rotate(45deg);&#125;.arrow-left &#123; display: inline-block; width: .8rem; height: .8rem; border-left: 1px solid #eee; border-top: 1px solid #eee; transform: rotate(-45deg);&#125;.arrow-up &#123; display: inline-block; width: .8rem; height: .8rem; border-right: 1px solid #eee; border-top: 1px solid #eee; transform: rotate(-45deg);&#125;.arrow-down &#123; display: inline-block; width: .8rem; height: .8rem; border-left: 1px solid #eee; border-top: 1px solid #eee; transform: rotate(-45deg);&#125; 按钮不可点击 12345.unclickable &#123; pointer-events: none; // color: #333 !important; opacity: .5;&#125; 三角形 12345678.triangle &#123; width:0; height:0; border-top:1rem solid red; border-left:1rem solid green; border-right:1rem solid blue; border-bottom:1rem solid transparent;&#125; 移动端一像素边框问题 .border_half { position:relative; &amp;:after { content:&apos;&apos;; width:200%; height:200%; position:absolute; top:0; left:0; box-sizing:border-box; border: 1px solid #eee; border-radius:3px; -webkit-transform: scale(0.5,0.5); transform: scale(0.5,0.5); transform-origin: top left; -webkit-transform-origin: top left; } }]]></content>
      <tags>
        <tag>前端</tag>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实现三角形]]></title>
    <url>%2F2019%2F07%2F16%2Fcss%E5%AE%9E%E7%8E%B0%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[在日常开发中，经常有一些箭头啊 边边角角的地方会用到三角形，但是又懒得切图啥的，其实用css自己画也是个不错的选择，这里，来探寻一下其原理~ css实现三角形的底层原理其实就是利用了盒模型的边框如图所示 实质上在块级元素的长宽均为0的情况下，块级元素的四条边框就组成了一个完整的矩形，在此基础上，我们需要什么样的三角形，调整相应的边框颜色为透明即可。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object.defineProperty]]></title>
    <url>%2F2019%2F07%2F09%2FObject-defineProperty%2F</url>
    <content type="text"><![CDATA[Object.defineProperty(object, propertyname, descriptor)为对象定义属性的函数]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html中引入公共模块]]></title>
    <url>%2F2019%2F06%2F21%2Fhtml%E4%B8%AD%E5%BC%95%E5%85%A5%E5%85%AC%E5%85%B1%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[在工作中经常会遇到]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码之外的软技能读后有感]]></title>
    <url>%2F2019%2F06%2F18%2F%E4%BB%A3%E7%A0%81%E4%B9%8B%E5%A4%96%E7%9A%84%E8%BD%AF%E6%8A%80%E8%83%BD%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[首先啊，不要老是觉得自己是在为别人打工啊，其实，无论怎么说都应该是自己为自己打工的，在企业工作也好，自己创业也好，工作的目的应该是为了自己，而不是为了企业。为了提升自己的综合实力也好，为了赚钱也好，都比总觉得自己在被压榨被利用的好~ 不要试图去改变别人的想法，具体表现为 不要跟人杠，不要贬低否定别人 控制好自己的情绪，不要随意宣泄 一个面试的捷径：经营自己的个人品牌，比如说写博客 比如说 去别人的博客下面混脸熟~]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我和解]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%87%AA%E6%88%91%E5%92%8C%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[最近真的好丧啊。每天处在 焦虑 易怒 暴躁的情绪里。整个人的感觉是破碎的 一片片的 拼不起来。负能量是不适合拿出来说的。没有合适的人 合适的事情只能自己默默消化掉。生活需要一场洗牌破后而立吧多看书 多规整 一件件事情 总是能好起来的可我确实是一个悲观主义者。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h5实现点赞动画呀]]></title>
    <url>%2F2019%2F06%2F11%2Fh5%E5%AE%9E%E7%8E%B0%E7%82%B9%E8%B5%9E%E5%8A%A8%E7%94%BB%E5%91%80%2F</url>
    <content type="text"><![CDATA[最近的一个需求里面要实现类似推特点赞的动画效果，纠结好久最后还是用了帧图片，,h5 实现的效果说实话不尽如人意，不知道原生那边的效果如何。但这依然是一个实用的 demo.记录一下说不定以后能用得上呢因为不好上传图片所以用了base64,图片的代码都有好长一串不想引jquery就用原生写的，结果发现原生的东西啊，简直是都不记得了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;zan&quot; id=&quot;zan&quot;&gt; &lt;div class=&quot;icon&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var btn =document.getElementById(&apos;zan&apos;) btn.onclick=function()&#123; console.log(1); var icon=document.getElementsByClassName(&apos;icon&apos;)[0]; console.log(icon); icon.classList.add(&apos;active&apos;,&apos;zanAnimation&apos;); &#125; &lt;/script&gt; &lt;style&gt; .icon &#123; content: &quot;&quot;; height: 100px; width: 100px; display: inline-block; vertical-align: middle; background-size: 100% 100%; background-repeat: no-repeat; background-position: left; background-size: 2000%; background: url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB9AAAABkCAMAAADpGlumAAAC91BMVEUAAADxXSnqVQTqVQTqVQT6qRDqVQTrVQT0XyjqVQRnZ2fqVQTQlDL5qzT7wARmZmZnZ2f7eQv7vAnqVQT7wARnZ2f0SClmZmb6sAbzRyv7vgT1TCb1TSRmZmb6lgf1SyfqVQT2TyLzTCP6mRD7wAT3UR36ew76cw37fAv11L7qVQT7uAPuVQz7ewn1TCX7ewn4vB1mZmb7wATrVQT7wAT0Sij0YzfqVQT3Ux/qVQT7wARmZmb6bw/6oVTy0sT7wATzdTz4vBv6oVT7wATzfED1Zj76oVT7kyX2akb1VBdxcXHtXgXqVQTqVQT5vBv7wAT7wAT7wAT7wATqVQTqVQT7wAT5nQv6cg78YBj7wATqVQT7ewn3hGf2uIv10p37w537uAL45rv0yLn43qn2yYvqVQT6jAP7wAT5vRT2yYv7wATqVQT8ogbqVQT8YBj7wAT6rwX7lCfrVQX8pALrVgT4vB38nQT6jAP7wATqVQRra2v7lCn7vwTy0sT3hGf6qFL8Yxb6rwf6qwf8nQT2uIv10p37w51mZmb2hRf3nBD2akbzgkTzdTz0Yzf0qpbzgkTzgkT3hGf0qpb3hGf2uIv8qAL6twz3nBD6jAP8aRP2viZmZmb7livqVQRnZ2dnZ2fqVQT3Uh/6rwf4vBv6rgb5hxD2yYv8ahP6rwRmZmb4y5343qn7mAr8mgj6sATqVQT3hhX3hBbqVQRpaWn3taT0yLn45rv3xE38mwb3taT2vib3xE30SSn7aRX6iwX3xE36dA70SSn5cgz7wAT10p36exb7jgz3xE3qVQT7wAT7mQv7ewlmZmb3Uh/1TSb1Sif6oVT6jAP6sAT0RyryRy38YBj6cg34uxv2akbzgkTzdTz8ngP6dA78ahL6rQn3hRf3hGf2nBH2vib0YzfzYzf7lCr6ly37kB72yYv2uIv3xE30qpb8pAL10p37w537aRT5lA36ehH2Xh/xbgby0sT0yLn3taT0Thn45rv43qn2Zx73gwn7uALfzX0fAAAAyHRSTlMABg8e4gelPBrFKFQDBfnXrR8dmZZT8kHxyg7ibr1ul/nzHxrtx0n0mEnxSyfySeL08rKGKPrLRtB4WOWX8+bTzMW+cW5uTc/M/g4L27WFNvKrh2pgXsjizOG9+vTx7u7n5ubm1dHPemxWQ0CwrfLkwm4w8OjPz8fClBj1y8S/hG7PkfewkZF09M/29vb21dDIhVZNJib+9vTzy8jIoIVhFflu+YaB+syZlolJQOric+K9VyLu58S+l49uTayr+fK+hk3fxO9i9JYHO6IAAB5PSURBVHja7N3LS1RxFAfwcyFrFk1gxKAomlqZSOMmzUWZlTbueoCPyOcoRhCmBSqIZmQtfJcFLdwU1aIHtLDITdCyxFGvD3y0cCFaWEGg0WvRzPXOz6k7zuS1Y3P1+/kHfujme3/nd84ZAgAAAAAAAAAAgIAhhe+MitoZLhEfKT2ppSUpXSKj66jLza3rIFY3WmdbbxAvc3dXV7eZjC8uJSWOAADAxZTcq0g2ERdT0pQiyURspPSMxsYM5m+G65OK68ToxqwLc6J3f3HqJl5xdjt72KbMzaUQt9paAgAIfFJyrypZIh5S0pQqSSImpoxRRYaJ+HRMqjqIT+usSyux6vri1EW87PPzdvICgQ4A65FUn1NWllMvEZvwXiGceKRPCenEQ8oYVWVIxKZuUlVHfGYX0J8MGejPaAkouQNAQAnenx2bvT+Y+JhyhhU5JuKys1fYSTySpoQk4pE+KqQTm9xJVS5pGOuGvjol92d2hC0AGMKu2BGX2F3ERcoZVuVIxOROr3CHeLRMCS3EI2NUyKDfGS3Qfb+hoykOAOCfC44dWRAbTEzqh4V6WsQV6FEkGC3QG0eFRvqTsUruapc7AACsilvnQl6OuO0nJjnDQg79BiX3ZQS6sZriAABgFR+4b4XI8ucRt2xiMryojDTYm+K0o+qMTXFSWmpzc2qaFMgl978cWzt6+MCBw0eJ19mSByVnCQBg7eN94D4ny/LbEbdYYhH04s2bH4yBrh1b8z+qzja2ZkodV6Sa+JripLT2pqb2NIl5scylfsUl4nT2nQtzopuv5udfNROvR8XFj4hbXFER+vMAjCm+/OJb1gfuEHkVbugvJpx6/JTcpfBQiyVU/5q3+MLCbJHWOjPf/xFP/S2WkVLHVakS19iaqW1M0WYiTkf7VUeJUck7lxJidfWj00PiVfztWzFxK/r6tYi4PX9OAPCv3ZPlAd4H7hD5b46IjgxLDIuMJp2eTDi98d0UZwodUoTqDanCnz8L1Xo6w6i6OMLf6te0cSFN3zeDzd9iGaltTNUmkT6HDpF/h/tVh4nRg3cuD4hV/kenfNJAoCPQAVZJPOv1WZTcP/grAlgtgy4W64oC3efYmhQ6pAqV9Af6cvrmmI5IHRdSdR7hb/Vr2piQxhnoB/pVB3Qesho39EOBE+gouQPA0spZH7hFU5w88dbnM320ZXCBJXolJXefi2XCh4Rw3SX3+OWMqjMd0TwuNDN9M7SPCe3Ew3+gG+sNXS25AwDowPHAzVAMV8bWQs499tlIHznoFqm3Ke7Jkxe+V7+GDgmhpGWcUXXPQGf6ZmgaE5pIr4ApufvucjdSUxwAwEoeuK2WPheLlRiFDbqFEZfEIcFCXhhmVF1/yV0IlED3aIoDAFgHgncnnE7YHUwcyv09cEdb+hZYoolP4qBbIv3GcIHO//st+pviFgVKyX1xbA0AYK1zhXmPYs8uYhAv+3ngjuxz0xTDDXZD/7uSuxF+YVUztqYXZ1OcEACLZQAA/r9de3qEPcHE4J7s9GEgdqkH7rA+N56o1b6hM9A2xTHQLpZh4rlYhoFmbA0AAFYs2JXnwm7iEF8eElIeT0tJ7HNLJA7aLncG2rE1RmL1Kx+x+pWBZrEMAACs3O4eTwnEj/+G7m8OnY9YLIOQEvytfsX9HADgn0jo8XTa6zQZJ/43dP4/R7v6FSEFAACr7PTSN3RrlMMlykpctF3u64QUUXX7dlUEa828wlZTY6vApwUAwDqR0LPUG3p0lGNBFHfOLs6hB4SgiKwrV7IigohNTOmAojSGuMTYZhS2GGJjruisqemsMJNXxulRv9mQl9dwkwAAjE28oWu63CMdbpGkA1MxPOiuq8PuLmfaVk4oKtmiUCodUJUGEQ/JNqOysf2rYmzTCq/fDAaaIr+Z994pjzXRzdcKCq5hyRsAcBJd7to59DCHWxgFjK2XZXniu8NRtomYBFVOqCq5ojBiQIggHhUzQgXxMNumVd6+GQy0563hvaKBGF375PSQeMXZ7XHELC4lhf2M2loCgBXNoWs2xSU63BJpOayutjArsQhy5blDWfd2gXhETAhLpe3WzG3V54+/Pn6+elvmVlq+qgGhinjYZgQb8aiYFirIO2NsYs97r8gjRgWfnAqIl31+3k7MUubmUsgLBDpAQNCufdV/Q1/sWX9FWpuPnTlxcMeWLTsOnjhzbDPpcFeW5e+DimQi4jgja0LIIi/MmdWvPVVnmmmZXg4IL4nHjAfi0TktdJJ3xvittLUU6M/IC6MFOsBatm/jhu0bNu4jXnuPuIPwyN4VvKHf71NZNffak6deezh1cqu+vfAOj43sDGf8Yu/8Ypuq4jj+K9DNabs/XQmkZrPKZNpVzbaahW1qzB7M2JbNjWHmn5iYoKRTVLJMB9OE7AF59EGR6MCYkECC+C8mvmAIRHNvuVEx8DQY7gETn+g2jQm+eO/l7tfbnnt7e889p12b80l8KYZPWMn5cn7nd35nbkFn+erV5TkgGb8o53JxnDLQL/X3PwJcwEC/0d//E/Dh4J/IQciizAK9ckru31dGyV0gqFx889Id5n38etAifU/JJp7qi1B2uYdu/2rwIGQRCdfKOdSGI+CSxUyg/wIIU8eckecqL0AuiXdlK95NUJXc+//9tx+4gCV3fgoM9JUVm0Avl5J7pinuachFNMUJBAKG6Hm++t/ldCr15ZEffr6gb9ergR7yfnmwr0XOoaUvSHUP/dQv1mNcu3UDYel2HehYcr8NCDsHltyv6hCGEVln9rW2jyIQ+ajttVlZZ8SVpDkT6PcDF7ApjqPiMwx025J7eTTFiWtrghJzuKe96W7IQjgqky4tzVMm/luVVGZ8QAm5807MyhbMJmhGq53FQDfvoINh2YZw0G3J3WiK+2UaEKaO5kyg74Ns+oxNfwIyJIyqQJ8Lhf9VLLk/CnzwP4Mld0JRTk1x4vFTQeVzXFHp2QkmhKNCGZIwzjHSJZVGoIM8G28bkS0ZaQP3LGLJ/TYg/g7Zlg6/26Y4/dra7YUvAGHq8E9jyb3XKs87QpBN6I65rzwHy4xNxToDQIO/kGtrqOA6WAYlAkH5sUVp33LgU+UwZBCOSmU1nSJIa5v0aqCB7F4fr5VtqB0H15xN/2rwJX4W7JDz0BF0d23N4BCGCGvHtrVE7/WBmW79Z7IXSPbqP8Luchz9ul9S2cVxsAwqPFN6ya6p2A7IRjiEwzNNynEtDesgg3BUKCdTlqiJXgUUkPfL2zDPSWrbwC2nfl/+VWf5FH4WlvMSdjlYRudQCBDWDn/z9NzcdO7o18SIVrVIghVJ/dcSwJjqwVgn8KVTUtnjcfQrhWJd/TkKZGOU+He0cAiHZ7boVeqAogTwI+GoRKqrNq2mbFiVNjHYoRsxZQ1VRoW2/p7WKuLpraHMztaBbldp+8WhrVsP4ehXC8fEaDLkjySSoxcJhxe0/vbaJFiTrNV63YExg5IkdQFX9kgan0OGclQURzKmKarAjHAIh2eMInW7shM/Eo7KIzAjSZjnJKtRFmfowVk5L7NBcEnb1t81tuLmPtIiO9CyDWghHRPdAfwJdk+wc4zLKnvBjr2yyjgwZT//xSQu6cQBKUdFkSRDmmIQzAiHcHhls9LjA4CdSjsgwlF5NEqSlE7Zkp5i0eXeJzvQB24JnTq7ePZUqIBiOBIGSkhHRyQr6DtYOYIXtd8c7NFME0FgyQ7+i8mMlLuzLUdFcSR3RTXFJjAhHMLhlUCdcuJOwfpT/Ew4Sspk42A0Otg4CSypliTsb7fka+/30AvZPUfAG6Fa2ZHaECtHOABZBMKMHONOv0WolvUWPTDIPdA3xiSNKUDKUVEkSafuqAETwiEcXjmh1AVApV45DgbCUUriz0sGz8eBHVVYcLfjjPdJcX2yI33gjVG5AEYZOZ4FgmfZON513OSHWZ+ifytpvAEceUPSqQKkHBXFkdwV0x0zkEE4hIOewN1bVDb3KJtB5W5FObHF4IBwlI7JmITEJoEZU7hBt+N18MxTsiNPgScCb8oF8GaAiWMiAgSRCRaOkKySgHwkZJUQMGPDJkljjOMtuDHpDpPrQ5FhPUqGhEM4GPJdnXKHetA4rZio3ykcJSIek0zE4sAKSZJSDmwDjyTkAkgQD7K5YZiYrT4ciQwTM9eHAWnofa71ud4GGkc3WNCNjtzLabuPHt3d7C+44j4L+ZnVa+6EZG4OJW4IDEkasQ3c5tRgDtasDwVxC45Cwo1Ao3AIB0ualJ6mOqWn/nAAVHY2mWhXTgtHiaiRVIYmBwYmh9h+91M5FffXzwwMnHk9ZeZLb4lOVtw7kpFIsiO35o5Ppj+yHVzzWs5WfNjI4JyN+2uwxvbWaxqt2907JgJgQWACHWa2HVnSObKt0K670QIK/2FiRo3O9DbXxT7jIKcTnPGpYWvErR8KYWNnY2McOiWDmkYTuwJFV+Ccmps6OKeGgYR+9hzi67qnCwbWztVm7smw0Xk+PEcHIhxl6dBud21W6sGCu5Ue4SgNXZLKDmxKZnhtuCq74n7Sas7MtB888SyZqmQGPwsNWp7rid7gUVGLu+REbY7EoEHNc53WBteOUdugRQfiP7KUXr5+fTm9dMRf4BF6G+SnDQ/RTVNkDdx8U51RqQp2SARTk2BNb3//JSNumwu+tF0NVZIlnSVSBLU818FJsgwl9NPhh7Qu541Whmi18wtuHB34hhtHByIcrB2KAnZBeEDpEQ57arqAG43a/lx3GCcujey63C+b9+drjuw9ejPLI/SONUdHziH6Q5fWeMijIpz5PsLZEkyOa2v0unYkrb/zJDpMNC+lr+ukl5rBmQk8H7d04Dn7mznvvKRXrqykF1RQ4siAJFkEer5BaNoTqUbavgMFsEHKF4RTJVLcu3JzjbcBWEno329DCS7uBG84v7HO0YGvrPN1wMOv4Cvr/BxPPsnTgawfh30Qah83CYcdG8ekXfvjwB6c5TW55phkestoJm3uaF9znEmZ2Q2eaJHNJNccSdlMCzyGgf6YR8Vw5vsYzpEYPIeB/pxrR8j6Ow+hw8TupeXrOstLu8EZbZ5exOHvVUQbrZfzEuvKlStXVhZUUOLIBttA3+Qc6D96D8LBEin2ZQL9MwBOEnj/feKFdS6L+0t/6bzEN0Be1gL9Zb4OeOWff14Bzo4n//77yfUTtqUO9OPKceGwYUNNDc/LvNrcgQ2GQ/97EAVW+FImImuOSMrMHHgiu+ydcWSXyeEFDPQXPCr8me/DnyMxaMVAb3Xt8Ft/5350mDi6dN1g6Sg4I6s4/b0i/6e5hSsaCypz1IHuvJa8kKmHf+I9COdLpDh4EzkIwFyCgf7EbwZPeF7cd9htzxkGOjpICwY6LwcG+vfAz4GBzs2BvPceCwf/QG9SNgtH3kCfB07EMNBVxwDHQEdHysxRoABb1q0DfZ4IdGKH7jnQ54GQkDt0j4E+zyzQyR06OvLv0Odwh84k0L8Ca965jDCoh48VQcE90FFCwjDQq4tQcq92LrnzdcDD37MouVfzLLmjg3+gF+EMPdCuHBAOGwae1xbeb4EDWHI3HIxL7mNZJXfDwaDkji3rRMndcBAld/IMnb7kbjjIkjt5hk5bckcHq5I7eYaOjvxn6LvxDN1Dyd15LWm+jDR7D8L9JVJ8dpNhyR0lJAxL7gPOTXEcHdgUx9GBCAc6OAY6NocLR4mY15viDIaY1gJqLhNDZBg0xZlb1ommOA2yKc5Vl/uF862t5y/YN8Uh4RwJ2eVO1RSHUDTFMe9yb15Amr0HetQH1vjJO2X0QRgLlEjx9k02TXEo4d4Ut4fi2ho7ByIc5ejIE4QnlHrhcENZXFuDKJdra+btdoHX1tzcQz95Teek3bW1hO21NfIe+nq6tkZxD524tuY10GtcTH2hD8KaUin8xLU1phLy2prnxb0RHBEO4XAdhKeVw8JBxXoeLANRLoNlzAfiBQ6WcTEp7sI1gwvUg2VwUty6GixDMSmOGCzjNdBnnOeyMgjCzuIryMEy/CTkYBn6xX0XOCEcwuE+COuULcLhinIY/Qo1XEa/mlvWCx39Wjjnrxmcpxv96kz83LFj5+IsR7/ymeWOkum5uWmU0Ac6RSMIXRDeUzIFjn5dR3+OvIt7HIRDOJgH4U5F8QkHFev5cRYYc3qc5WsAqh06sp354yyteOeM0+Ms8WO3VI7FuT7O4uvdt6/Xx+m1NfpAjxcl0O8qF4WThPviHguAcAgH0yA0HhQXjhISr8FjuzgwxLfH4fnUKUBcnqFjjxur51PJQOf0fOq5WzrnuD6f2ntVpZPqPXSOgT4FxQj0TWWjcJDwX9yfB+EQDvZBeFg5LRwlpatxMBobbOwCtmzck8rHf1FA3HW5Iw9FWmQHWiJAW3LHoHMCk9KZY7d0joEO6QgHIItA2L0D9l1V2QdZBCfwHgABXg2YCELhPPigu0AfAsSbAoOQ1SAs/ooPX/yQv+Rpl4t7J1AgHMLhEIT1ygnhqEh8H6fsSdNuQrZfItrivG7Qyaa4bxpMpWhHwkAZ6KSjIwImIh0UDgx0Yosu7wU79sq4QecU6DuKEuhfrT+Fyot/vEgh4by4d4FwCAc16tQVyyD8rl35Tjgqk48XU7asSlWAULfFBWflvMwGwQV4bW35xgd47YxhFQBL7j9hmxnhmOgO4Pa8e8K1A0vuN976wk+cotcmwZpkLbbBe8VnE+j7i1Jyr+Yf6NXF2KFX81/cPwfhEA5q6pX2uh71v1zalXrhqFAO2Sf6KvWalT3JNTEi52Ek8cB99z5+730PQKH8vKzFucoHDUSbuQXYnO6qKe56Gm+bWTgmRpOhYDCUHL1I54DQT7du3VhcXDxkchg/qZGkdZ7rv5YAJ+ifT411QjECPeorG0WRJL6ozeJeAyAcwvE/e3cWG1MYxQH83MQwEdMwaSYz2qi1lmHSCI2IpaWk8WCLUiIEtSWCaCSIpQipfYutnqwVYnsQYolIhBAzpJsljO1FqCVCgid3rm/OTH3Tmbm39zC3zu+1iZNU0v+9557vfIatOHQ/trajuEYzNXofJrqc58vBoIabXL1pcb5te32dAiGdfEn/4y/CeiTbdE+H5Nnm/N4G8wr3wRDUWBsU1tqkh4a0eSCbl6bzmcE2Lz8nJ3+eDQgkLqF0xCCk+ISeuISVisC5jjH/uM9eAlyDazTFitaxjOIazVYXd+xE/xzKcwWM+XOTa1Fao3le1FnNc02nzpCc8xjo5yPZ0vduHH31xFqHV6gDqChqHAmiIxBFDBz0dUJDzr56pw2cSx9pljqBQOISE3o1EoRTdLUUHVcqcnIqrjiAogS6eunGjUtXQW8RxhhLLQP3qerv/eFAxxYtW4FR0iZX79hG+u3edgMCYVmQnHIM9HIpbY1nLZr4Ck0EFUWNxUG0GGIkelp6P4jol56mN89tSx8JS22gR0qVAGfFa02FEwiteadZA4wxZm0D3WqiB+sb7oCFJpE3ufZbGXMerl92H38gLMPIGzpypDfaC3eAHvtfof2goqgRjHD/+d8xVvxu5nr3tof2e71zxa9u7EBI3rxHaB7okFolHBWvhQobkLn6TrgKdOaXnCiZD4wxRqv9sbX73CvXdbi86cz69Wc2Xb7dBUzkPHk2ePak0zG8qzR5PtyhtuYDqL+xb+hooFZBqoI5aDDQCWrECXR89pEffkCH/EcoH5KXYiWuvEZXgMyld8IlIDP/bQhtojs2TJu2wQGMMUbE664KcXuh/fChDfa9Dm+vDc/pf0NvJ3ru4Sl31B73t6O0dLUK8nlcLo9PZ8tdXw3jLXfUpgiPwqHJRW1Aj6OP0FFIWqqVqHiNKoDMjXfCDSBT8jakBCht+KA6BbROz5p1Goj1nDGjJzDGUo7TXfWb2wkA/YaPG9o1La3r0HHD+4WPt33R/Q0dsst/53m2XG78ogb728c7IcrNB5qbhobiEtcwOhQncxQtuxttWZHDeNrmQJJSr8TriIYlLBfoJ96GnABK0z6opgGtWT9+zAJiM75/nwGMsZRzsirspHzaXFtA8yyAU+46PtCfLz8f+6rVNmPmhh8a5o5pA9F8DwQfxIbXmAt4bC3JGsaPrcmcRenLFo29O3bRsvQiZ0r2wxspYb1Aj9tyt9AbOge6DqtWAWNMp7MY6PXitDnOy4UX0NQF8Ce0PA8ED8hiX2NuTO9rLte13vFrrBV5/mcN60ysxSlhrZZ73KE4C31D55Y7BzpjpIJVKPwejifawgtonn3xB/wDOgOpdoMmBR4ILpAYv8Zc1ttVrXL1jl/jyFq3e+0RGxikZLlcWUozP7aWaCjOQsfWGp9y56E4xpg1NHhD11yL7JyRFtAY4V3sdi/2QgLZ3evqpEAncq1acw0oZdWobqbuYhlT2PAVneiZARfL3Llz6SowxhhL5hv6i/Cn8shWWGkBjQHHqjTHIK52ap7X+SMtdypKWeXBg7X+6hAXUHLVqFxx97IuzclZ2rTVr76MDB9xidzcf79YxgR4uwut/Hwgd+sWMMZYvCn3IE6zR+5tkRbQ6OetErwQz6A61afIUBwRe+VzTW2AMtCVsuKFC/tjoBPK8PszgAgGus7Vr4ZueKWG96/KONAZY82FOIce/BkQ/FE3qzbd4iphMcQzqS7kCx5bo6FUPhdqCVvu9uJalb+RlrvVAj1JFgj00Bs6Y4w1Z783xV0PhC2MekNvOneV4IZ4utdpPvkDAY8P9Nm7oLR0wV5IQtlz5NeG4igoap6LRM9SgI6S2a3T4cOkZw+UEbnbtuWOUIAxxphlRO5Uux75hm52oDd+sfqkurBJoNPe0npVaTKJXvkc1V7rDTTKalEZ0LEP8GsG2IGKPfeNJtcOZJQRhZs3F/IzA2OMmQdvPZcG201ruftcD0JcPlBlXygvv5Ad9Q1dGAQ6LajXLIDEPj1HB0EX2zq3e50NklFci4qBjDLALwxQgIaS+0bIVYCIvfCxptAOtPasnjp19R5gjLH/Ab4+xx9sNz4U19kVPpWmFjn+QnM8aspd070d6FRaryklDfR1QdUxSEZtxELQZ3TOaEhSph9lEpUY8QaNABpK4WOhUAFKu15q+CM6Y+w/E3ew3fixtawHYVmQ/ULIjpxDD+meDRSBLrfcK0EXd1Dlpg70o8kvXe/mR92ISuS+QblUzwyP0QjKgfI9L4U9eouAfqlXgjHGzIGLZTIw0DPgwgvhQtSmuO6TBrUDZKjlrmSG7mvLVBIOxZUZDnSskVzLnSgKD/vRYaIS296gbUTPDIWPUSFloK9+KawGSru3v9++G2g5Nk6fvpHXzTHG/q3+GOj9ofyFUA4y40Nxdk+1xmNPcGytUjHccrd7ajRYg2AoTlegdwICUqCTPDNsfow2A6GpL4WpQGj3+xDiRN/4UXUKGGPsH4p+Qzcl0OVja4qnWvAocRfLVNrB6FCc4qkR1Br4E/nYmqpYAd3oWu6IruWO/s9A3/4+ZDuQmv5RNR1o9Zw5sydQ6zlkCN+qzphVRX1Dl1ru5sisRpkih0tLMW1x9WtlmdKEGjUoM/a4nL1Y5Lm9aYfMO3XLVEwbipMpBXlbt+YVKBRDcaQtd5RqLff3v4HMaoE+89u3mUBtyNevQ4AxZk1RU+7SUJw5PNXIAyHr6lXHwEyeGuSRx+Uiq1+LyxRTDpljG9vkY2v2vKeaPKmEecfWlIKdW7bsLFAIhuIEM4birPWGTtxyx0C/CLFZLND5FlbGiESfQ8dja2bqX436RybgS82tUYNcMQOd4JA5DpqZt1hGyXsq5EklzFosY9/xRLNDemYgOraGVeiPreUD/Tf0/H82FNfzYnNpuXOgM0YFj7pHL5ahCXTX3wl0bLmbRO6nSyEldeUNKXiKCrCEuatflR1PhB2RZwaCxTIjhw0ePGykNGWvZ7GMhabcGWPsv/APWu7RQ3FWmnjLe4rygEbBEyQ9M5i4+nXNQ80aUGEVxhhjlpZwKA6ZNBRHQDpkTmPrU7QVaOx8gnYCmZEPhZFAaX7JiZL5wBhjjJ50bI2CfGytIescMqcPdNjyBG0BMsMeCsOA0Py3IbSJ7tgwbdoGXhnDGGMgLZYhkGCxDLfc/36gD34oDAZCJW9DSoDShg8qXhnDGGONrmW1YI1f7d0xCsJAEAXQvY6XEkLuliZ9zmRjn3RqswQWgyxOcOS9SwyZzP/bHzLvP4qrkq3czxno0+1lKpGu96driTWP41wA+ESSt1Gb2FoVdRS3l23l/u4LPd1AH7dtLLEuw6ABDuALIfOOYpkQbWxtL9lR3NE/9FQr9xMG+rCuQ4m2LAUghY6QeXf1a4CmWCZGG1tr5blyPzqKy7RyN9AB/k6tfg1Ui2X4EVbuAAAAAAAAAMDOA75jlfxcXuNoAAAAAElFTkSuQmCC&quot;); &#125; .active &#123; background-position: right; &#125; .zanAnimation &#123; display: inline-block; -webkit-animation-name: zan; animation-name: zan; -webkit-animation-duration: 0.5s; animation-duration: 0.5s; -webkit-animation-iteration-count: 1; animation-iteration-count: 1; -webkit-animation-timing-function: steps(19); animation-timing-function: steps(19); background-position: right; &#125; @-webkit-keyframes zan &#123; 0% &#123; background-position: left; &#125; 100% &#123; background-position: right; &#125; &#125; @keyframes zan &#123; 0% &#123; background-position: left; &#125; 100% &#123; background-position: right; &#125; &#125; &lt;/style&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站部署]]></title>
    <url>%2F2019%2F06%2F07%2F%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[开启阿里云建站之旅~ 首先在阿里云购买云服务器，根据需求购买相对应的套餐就好。 下载xshell和xftp 安装apache mysql 和 php (使用阿里云 lunix下一键安装web环境)具体教程 wordpress定制模板 目前存在的问题：没怎么做定制的主页不晓得干嘛用经常要服务器重启之后才能重新连上数据库 一个大坑https://bbs.aliyun.com/read/269743.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[es6中的promise]]></title>
    <url>%2F2019%2F06%2F04%2Fes6%E4%B8%AD%E7%9A%84promise%2F</url>
    <content type="text"><![CDATA[promise的实现真的不是一时半会能看明白的，还是要在工作中用到并结合一些博文讲解，来更好地理解这个东西。真的有点难啊目前来说。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[坚持的重要性]]></title>
    <url>%2F2019%2F06%2F04%2F%E5%9D%9A%E6%8C%81%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[日复一日年复一年做什么事情总是半途而废的话做什么事情总是自我麻痹的话就什么都做不好了的并不是一定要做出多么令人惊叹的创举坚持和自律就已经足以让人变得更加优秀了不要走错了方向啊。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步不可怕？可怕]]></title>
    <url>%2F2019%2F06%2F03%2F%E5%BC%82%E6%AD%A5%E4%B8%8D%E5%8F%AF%E6%80%95%EF%BC%9F%E5%8F%AF%E6%80%95%2F</url>
    <content type="text"><![CDATA[异步是一个初期不怎么能遇到但是又十分重要的知识点。而且复杂。掉了三节更新的课程还没有看，罪过啊 众所周知，javascript是单线程，但是单线程的弊端也很明显，就是很多时间都浪费在等待某一个事件执行加载上面了。为了提高效率，我们在js中也实现了异步。 回调函数 promise generator async/awiat setTimeout的内容会被放入到执行队列中，不会马上执行，等到主线程执行栈中的任务执行完了之后才会执行setTimeout中的内容 宏任务和微任务：宏任务一般包括： setTimeout setInterval I/O 事件 postMessage setImmediate (Node.js) requestAnimationFrame UI渲染微任务一般包括： Promise.then MutationObserver process.nextTick(Node.js) 由上分析得知，每次主线程执行栈为空的时候，引擎会优先处理微任务队列，处理完微任务队列里的所有任务，再去处理宏任务。即 promise在setTimeout之前执行 async function async1() { console.log('async1 start') // step 4: 直接打印同步代码 async1 start await async2() // step 5: 遇见 await，首先执行其右侧逻辑，并在这里中断 async1 函数 console.log('async1 end') // step 11: 再次回到 async1 函数，await 中断过后，打印代码 async1 end } async function async2() { console.log('async2') // step 6: 直接打印同步代码 async2，并返回一个 resolve 值为 `undefined` 的 promise } console.log('script start') // step 1: 直接打印同步代码 script start // step 2: 将 setTimeout 回调放到宏任务中，此时 macroTasks: [setTimeout] setTimeout(function() { console.log('setTimeout') step 13: 开始执行宏任务，输出 setTimeout }, 0) async1() // step 3: 执行 async1 // step 7: async1 函数已经中断，继续执行到这里 new Promise(function(resolve) { console.log('promise1') // step 8: 直接打印同步代码 promise1 resolve() }).then(function() { // step 9: 将 then 逻辑放到微任务当中 console.log('promise2') // step 12: 开始执行微任务，输出 promise2 }) console.log('script end') // step 10: 直接打印同步代码 script end，并回到 async1 函数中继续执行]]></content>
      <tags>
        <tag>前端</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[告别低自尊呐]]></title>
    <url>%2F2019%2F06%2F03%2F%E5%91%8A%E5%88%AB%E4%BD%8E%E8%87%AA%E5%B0%8A%E5%91%90%2F</url>
    <content type="text"><![CDATA[为什么会有讨好行为 正视自己的真实情感与需求 接受自己的不完美]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的闭包]]></title>
    <url>%2F2019%2F05%2F13%2Fjs%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[js的闭包是一个,看了无数遍但是依旧不明白的知识点,这一遍下来,也不知道能不能彻底明白,姑且先看吧.依然觉得没能弄懂，糊里糊涂，好歹是顺着一遍认真看完了，啥时候顿悟要看缘分了吧 首先,关于闭包需要明确的知识点: 作用域 函数作用域和全局作用域 块级作用域和暂时性死区(这个范围起于函数开头，终于函数声明的那一行，在这个范围内无法访问let或者const声明的变量) 执行上下文和调用栈 代码执行的两个阶段 调用栈 闭包的相关概念 内存管理 内存管理基本概念 内存泄漏 浏览器垃圾回收机制 内存泄漏和垃圾回收注意事项 JavaScript预编辑阶段：进行变量声明变量声明提升，但是值为undifined所有非表达式的函数声明提升]]></content>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试点记录]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[别人家的面试记录，分享给我看一下以下是我的整理，扎心 jsonp 的实现原理利用&lt;script&gt;标签没有跨域限制的漏洞 来达到与第三方通讯的目的。当需要通讯时，本站创建一个 script 元素，地址指向第三方的 API &lt;script src=&quot;http://www.example.net/api?param1=1&amp;param2=2&quot;&gt;&lt;/script&gt; 并提供一个回调函数来接收数据（函数名可约定，或通过地址参数传递），第三方产生的响应为 json 数据的包装，即为 jsonp callback({&#39;name&#39;:&#39;hax&#39;,&#39;gender&#39;:&#39;Male&#39;}) 这样浏览器会调用 callback 函数，并传递解析后的 json 对象为参数，本站脚本可在 callback 函数里处理所传入的数据。 12345678910function jsonp() &#123; var cbname=&apos;myjson&apos; + date.getTime() + Math.random().toString().slice(2); window[cbname]= function(data) &#123; success(data) delete window[cbname] &#125; var script=document.createElement(&apos;script&apos;); script.src=url + &apos;?callback=&apos; + cbname document.body.appendChild(script)&#125; 0.5px 边框实现原理：把元素的伪类高度设为 1px，背景渐变，一半有颜色，一半透明。 123456789.border-gradient:after &#123; content: &quot; &quot;; position: absolute; left: 0; bottom: 0; width: 100%; height: 1px; background-image: linear-gradient(0deg, #eee 50%, transparent 50%); &#125; 在浏览器中输入 url 后发生了什么 解析 url a.传输协议 b.服务器 c.域名 d.端口 e.虚拟目录 f.文件名 g.锚 h.参数 DNS 解析（把域名解析成相应的 ip 地址） 浏览器与服务器建立 TCP 连接（三次握手） 请求和传输数据 浏览器渲染页面 深克隆 浅克隆 (这个东西好难呀，还是没有看太明白)深克隆和浅克隆的区别表现为 假设 a 克隆了 b,修改 a 之后 b 值也随之改变，为浅克隆；修改 a 之后 b 值不变，为深克隆。即 浅克隆的过程中，a和b指向的是同一个地址空间。而深复制则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。实现深克隆的方法 递归去复制所有的层级属性 借用JSON对象的parse和stringify promise.race() peomise.all() bind 和 apply call 的区别 原型链： 有限的实例对象和原型之间组成有限链，就是用来实现共享属性和继承的]]></content>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端系列笔记3]]></title>
    <url>%2F2019%2F04%2F11%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[面向对象：JavaScript对象的两类属性 数据属性 2. 访问器属性]]></content>
      <tags>
        <tag>前端</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端系列笔记2]]></title>
    <url>%2F2019%2F04%2F11%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[html部分 语义化由于越来越多的“阅读模式”的出现，而变得更加重要。emm…适当的实践语义化吧。但是最主要的目的可能是为了让代码可读性高可维护性强，从这个角度来讲，命名规范似乎更加重要一点。加上在企业级的应用里面，几乎并不涉及到seo,所以语义化对于seo的影响也基本上可以忽略不计了。尽可能的践行语义化，或者说是更加标准和工整的结构和命名方式吧。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重学前端系列笔记1]]></title>
    <url>%2F2019%2F04%2F11%2F%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[winter大神的重学前端课程已经买了几个月了，突然发现自己陷入了快节奏与焦虑之中。希望能慢慢改善。每天学点东西，每天积累。工作中用到的知识都比较简单和单一，导致没有多少上升的机会，大环境是这样，抱怨是没有用的啊 趁现在不忙 有时间有精力 多学习东西吧。 首先，明确方法和路线，偶尔看到之前记的一些笔记，但是都很长时间没有翻了，内容也大都忘记了，实在是不应该啊。果然不忘初心真的很难做到。 基础知识很重要 尝试自己建立自己的知识体系 目前来说，css的知识储备是够用的，一些比较奇技淫巧的东西，可能在碰到的时候就学会了，没有必要专门去学，况且也是学不完的。 目前的知识体系主要是说原生js,因为工作分配的原因，对原生js一直处于一知半解的状态，这也是焦虑的原因之一，希望这次能够在原生js方面能有比较多收获。 最近要多看看《js语言精粹》这本书了，买了这么久 一直没怎么看。 知识体系大致分为以下四部分 javascript css和html 浏览器的实现原理和API 实践部分 后续我会按照自己的理解整理一份知识体系]]></content>
      <tags>
        <tag>前端</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rn投顾项目记录]]></title>
    <url>%2F2019%2F04%2F08%2Frn%E6%8A%95%E9%A1%BE%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[NativeModules: rn调用原生模块withNavigation: withNavigation是一个更高阶的组件，它将navigationprop 传递给一个包装组件。当你不能navigation直接将prop 传递给组件时，或者在深度嵌套的子级的情况下不想传递它时，它很有用。react navigation:flex布局: TouchableWithoutFeedback：不支持任何视觉上的反馈 animated StatusBar 用于控制应用状态栏的组件 react-native-keyboard-spacer KeyboardAvoidingView本组件用于解决一个常见的尴尬问题：手机上弹出的键盘常常会挡住当前的视图。本组件可以自动根据键盘的位置，调整自身的position或底部的padding，以避免被遮挡。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>rn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端不满一屏的解决方案]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%8D%E6%BB%A1%E4%B8%80%E5%B1%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[12345678910body::before&#123; content:&quot; &quot;; position:absolute; left:0; right:0; top:0; bottom:0; background-color:#ccc;/* 颜色自定义 */ z-index:-100;&#125;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地运行服务器]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%9C%AC%E5%9C%B0%E8%BF%90%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[可以使用基于node的 http-server插件运行本地服务 启动的命令为 hs -o(即http-server -open)]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 多行省略失效]]></title>
    <url>%2F2019%2F01%2F31%2FCSS-%E5%A4%9A%E8%A1%8C%E7%9C%81%E7%95%A5%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[CSS 多行省略失效 (-webkit-box-orient 失效)神奇的这个问题目前最好的解决方案]]></content>
  </entry>
  <entry>
    <title><![CDATA[iframe下position失效问题]]></title>
    <url>%2F2019%2F01%2F26%2Fiframe%E4%B8%8Bposition%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[js学习计划]]></title>
    <url>%2F2019%2F01%2F18%2Fjs%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[给自己制定一个系统的学习计划，方便对知识体系的掌握和记忆 文法 词法 语法 语义 运行时 数据结构 类型 对象 实例 应用和机制 算法 事件循环 微任务的执行 函数的执行 语句级的执行]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的代码规范]]></title>
    <url>%2F2019%2F01%2F03%2F%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[最近接手别的同事的代码，才意识到代码的规范有多么的重要，所以决定整理一份自己的代码书写规范 不同的主题色分类除了默主题之外， 白色主题统一用white-theme 黑色主题统一用black-theme 作用在body上 样式从里往外写，这样在后期有改动的时候比较方便（特别是在边距边框之类的问题上） 使用列表标签的时候通过在ul上添加类名区分，表内的内容的名称可以一致 外边距可能会导致边距重叠的事情发生，所以尽量避免使用，虽然能够用别的方法解决这个问题，但是这样又增加了新的不必要的代码 写sass的时候，层级最好不超过三层，控制在三层左右 后面我定义一个公共组件样式表，用以将清除浮动，居中，布局，文字隐藏之类的重复率较高的代码分离出来 css的命名规则上，选择网易的nec原则]]></content>
      <tags>
        <tag>前端</tag>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react.js入门2（路由）]]></title>
    <url>%2F2018%2F12%2F27%2Freact-js%E5%85%A5%E9%97%A82%EF%BC%88%E8%B7%AF%E7%94%B1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[##react-router和react-router-domReact-routerReact-router提供了一些router的核心api，包括Router, Route, Switch等，但是它没有提供dom操作进行跳转的api。 React-router-domReact-router-dom提供了BrowserRouter, Route, Link等api,我们可以通过dom的事件控制路由。例如点击一个按钮进行跳转，大多数情况下我们是这种情况，所以在开发过程中，我们更多是使用React-router-dom。安装很简单npm i react-router-dom –save,安装了淘宝镜像的就用cnpm吧。——摘自 react-router中文官网]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react.js入门1]]></title>
    <url>%2F2018%2F12%2F24%2Freact-js%E5%85%A5%E9%97%A81%2F</url>
    <content type="text"><![CDATA[写在前面没啥好写的，说是资本寒冬，多学点东西总没坏处 干看文档可真是 枯燥又难懂呀 但是坚持至少看一遍，在实际应用过程中，大概率能够突然领悟或者立马想到文档中对应的点。 react.js安装（通过官方脚手架安装） 1234$ cnpm install -g create-react-app$ create-react-app my-app$ cd my-app/$ npm start 组件和props &amp;&amp; state目前，我理解的props 就是组件中用来接收传值的入口组件自身是没有办法修改自己的props值的这时候 引出了state,即 状态 组件是可以操作state的（通过setState） 基本的条件渲染 if else 判断 A &amp;&amp; B 原理：当A表达式为true，总是返回B；而A为false,总是返回false 三目运算符 condition ? true : false 阻止组件渲染 只需要让render返回null 即可实现 表单受控组件？？ 没看明白 状态提升react事件处理在以类继承的方式定义的组件中，为了能方便地调用当前组件的其他成员方法或属性（如：this.state），通常需要将事件处理函数运行时的 this 指向当前组件实例。jsx回调函数中的this 类的方法默认是不会绑定this的 如果忘记绑定，那么这个函数的this值会是undifined绑定事件处理函数的 this 到当前组件，有如下几种方式。 第一种方式，通过 bind 方法，原地绑定事件处理函数的 this 指向这种方式的优点是书写起来相对简单，但是每次渲染都会执行 bind 方法生成一个新的函数，会有额外的开销，由于事件处理函数是作为属性传递的，所以从而导致子组件进行重新渲染，显然这不是一种好的方式。第二种方式，通过一个箭头函数将真实的事件处理函数包装一下第三种方式，在 constructor 中预先将所有的事件处理函数通过 bind 方法进行绑定。 this.props.back]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git多分支多人协作开发]]></title>
    <url>%2F2018%2F12%2F19%2Fgit%E5%A4%9A%E5%88%86%E6%94%AF%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[以我们目前的开发方式来讲，dev分支是供其他开发人员查看的，test分支是提测试的分支，假如我们的开发分支为A。 当所要进行开发操作的分支A之前的改动已经提测了，那么我们开发之前就要在当前分支合并一下test分支的代码以确保当前分支的代码最新且跟test分支保持一致。 开发完成后，例行合并到dev分支，直到再一次提测，那么我们再从分支A直接合并到test分支，之所以不从dev分支合并，是因为dev分支上有所有分支的改动，但可能暂时不需要提到测试线。 git merge 时，发生了什么呢通过实验，我们发现 在merge的时候 只会提交并合并我们改动过的文件]]></content>
      <tags>
        <tag>前端</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用npm时的常见问题]]></title>
    <url>%2F2018%2F12%2F12%2F%E4%BD%BF%E7%94%A8npm%E6%97%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[npm ERR! Unexpected end of JSON input while parsing near ‘…”,’ npm ERR! code EINTEGRITY问题解决方案]]></content>
      <tags>
        <tag>前端</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async和await]]></title>
    <url>%2F2018%2F12%2F11%2Fasync%E5%92%8Cawait%2F</url>
    <content type="text"><![CDATA[async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。await 只能出现在 async 函数中。 123456async function testAsync() &#123; return &quot;hello async&quot;;&#125;const result = testAsync();console.log(result); 返回值是一个 promise对象 引用别人一段话联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。原文链接]]></content>
      <tags>
        <tag>前端</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的导航守卫]]></title>
    <url>%2F2018%2F11%2F08%2Fvue%E7%9A%84%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB%2F</url>
    <content type="text"><![CDATA[导航守卫（navigation-guards）中的导航，表示 路由正在发生改变。目前接触到的 用这个来实现的功能有 未登录时的路由拦截]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见属性失效情况]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[这里记录属性失效的情况 1.z-index失效 1、父标签 position属性为relative； 2、问题标签含有浮动(float)属性； 3、Z-index 仅能在定位元素上奏效；2.margin:0 auto失效 1、问题元素必须要有宽度 2、问题元素不能浮动3.vertical-align失效 1、只有当元素属于inline或者inline-block时，其vertical-align才有效]]></content>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再学es6]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%86%8D%E5%AD%A6es6%2F</url>
    <content type="text"><![CDATA[再一次看阮一峰的ES6入门简单的做个笔记。为接下来写react naive做准备。包括最常用的和已经理解了的部分 ##let和const1.var（es5）和let （es6） 在es5中 var的作用域范围是函数作用域，而在es6中，改用let来替换var 。let只在所在的代码块内有效。最典型的例子是循环输出。 let声明的变量不存在“变量提升”。声明的变量一定要在声明后使用，否则会报错 暂时性死区只要块级作用域内存在let，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。即，如果一个全局变量在一个代码块内被let重新声明，那么全局变量对于此代码块是无效的。 let不允许在同一作用域内，重复声明同一个变量，会报错；但是在用var声明的时候，后者会覆盖前者 块级作用域let的作用域只在所声明的代码块内，相当于为es6提供了块级作用域。 S6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 2.const const声明一个只读的常量。一旦声明，常量的值就不能改变。 对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 const声明的常量，也与let一样不可重复声明。 ##变量的解构赋值 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 如果解构不成功，变量的值就等于undefined。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 ##箭头函数箭头函数在js的语言中山一直存在的，比如 注意，使用了块语句的箭头函数不会自动返回值，你需要使用return语句将所需值返回。 普通function函数和箭头函数的行为有一个微妙的区别，箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。##calss##模板字符串##promise函数]]></content>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react入门]]></title>
    <url>%2F2018%2F11%2F06%2Freact%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[react.js入门笔记 要点： react创建之后是无法改变的，只能重新渲染出新的实例React 只会更新必要的部分 值得注意的是 React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。 jsx中无法使用if else语句，但可以用 三语运算符 代替 在react中 注释要写在花括号中 jsx允许在模板中插入数组，数组会自动展开所有成员 React 的 JSX 使用大、小写的约定来区分本地组件的类和 HTML 标签。注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 react组件 函数定义 ES6 的class 类定义 State 在react中，只需要更新组件的state，然后根据新的state重新渲染用户界面 componentDidMount() 挂载与 componentWillUnmount() 卸载 方法被称作生命周期钩子。 Props state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。 事件处理 条件渲染 组件api 生命周期 refs React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue入门]]></title>
    <url>%2F2018%2F11%2F06%2Fvue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[生命周期 v-if和v-show的区别 v-if是将dom动态的添加删除，只有在v-if为true时，该语句才会被编译 v-show则是对dom执行 display切换的操作 因此两者的使用场景也不大行同。v-if的每一次切换开销较大，因此适合不太可能频繁切换的场景。computed和method的区别]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端活动页面技巧及总结]]></title>
    <url>%2F2018%2F11%2F06%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B4%BB%E5%8A%A8%E9%A1%B5%E9%9D%A2%E6%8A%80%E5%B7%A7%E5%8F%8A%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[以下是工作中常用代码片段 head部分插入代码，自动调整到设备宽度，并禁止用户缩放页面 123&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0,viewport-fit=cover&quot; /&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt;&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; 移动端字体的使用系统默认即可，只需要标注出英文header 部分样式，如果只有图片的情况 display: block;//消除图片之间的间距，父元素设置fontsize:0;也能达到效果，但是可能会引起其他问题 1234567@import &apos;../../../../../public/source/sass/normalize&apos;;body &#123; font-family: Helvetica,Microsoft YaHei,PingFang SC,Tahoma, Arial,Hiragino Sans GB,Heiti SC,WenQuanYi Micro Hei, sans-serif; img &#123; display: block; &#125;&#125; 背景渐变兼容性写法 12345 background: -moz-linear-gradient(top, #000000 0%, #ffffff 100%); background: -webkit-linear-gradient(top, #000000 0%,#ffffff 100%); background: -o-linear-gradient(top, #000000 0%,#ffffff 100%); background: -ms-linear-gradient(top, #000000 0%,#ffffff 100%); background: linear-gradient(to bottom, #000000 0%,#ffffff 100%); 标题相关样式 1234567891011121314151617181920212223242526272829303132333435//标题两端添加图片&lt;h3&gt;&lt;span&gt;&lt;/span&gt;&lt;/h3&gt;h3 &#123; span &#123; &#125; span:before &#123; content: &quot;&quot;; display: inline-block; width: ; height: ; margin: 0 0.5rem; background: url(../../resource/img/) no-repeat; background-size: 100% 100%; vertical-align: middle; &#125; span:after &#123; content: &quot;&quot;; display: inline-block; width: ; height: ; margin: 0 0.5rem; background: url(../../resource/img/) no-repeat; background-size: 100% 100%; vertical-align: middle; &#125; &#125;//标题底下加一条横线:before,:after &#123; position: relative; bottom: 0.4rem; content: &apos;&apos;; display: inline-block; width: 4rem; border-top: 1px solid #fff;&#125; 单行内容超出隐藏 / 多行文本超出隐藏 12345678overflow: hidden;text-overflow: ellipsis;white-space: nowrap;​overflow: hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2; 文字渐变 1234567891011background: -ms-linear-gradient(top, #fff, #FFD246);background: -moz-linear-gradient(top, #fff, #FFD246);background: -webkit-linear-gradient(top, #fff, #FFD246);background: -o-linear-gradient(top, #fff, #FFD246);-webkit-background-clip: text;-webkit-text-fill-color: transparent;新的文字渐变方法background-image: -webkit-gradient(linear, 0 0, 0 bottom, from(rgba(255,234,209, 1)), to(rgba(254,185,134, 1)));-webkit-background-clip: text;-webkit-text-fill-color: transparent; translate的兼容性写法 12345transform: translateX(-50%);-ms-transform: translateX(-50%);-moz-transform: translateX(-50%);-webkit-transform: translateX(-50%);-o-transform: translateX(-50%); flex布局的兼容性写法 123456789101112131415161718192021222324display: -webkit-box;display: -webkit-flex;display: -ms-flexbox;display: flex;//定义布局为flex布局-webkit-box-orient: vertical;-webkit-flex-direction: column;-ms-flex-direction: column; flex-direction: column;//垂直布局-webkit-box-flex: 1;-webkit-flex: 1;-ms-flex: 1; flex: 1;//子元素占据空间-webkit-box-align: center;-webkit-align-items: center;-ms-flex-align: center; align-items: center;//子元素垂直居中-webkit-box-pack: center;-webkit-justify-content: center; -ms-flex-pack: center;justify-content: center;//子元素水平居中 输入框 1234567891011&lt;ul class=&quot;info-box&quot;&gt; &lt;li&gt;&lt;input class=&quot;input1&quot; id=&quot;telNumber&quot; type=&quot;tel&quot; onkeyup=&quot;this.value=this.value.replace(/\D/g,&apos;&apos;)&quot; maxlength=&quot;11&quot; placeholder=&quot;请输入您的手机号码&quot;&gt;&lt;/li&gt; &lt;li id=&quot;picturedl&quot; style=&quot;display:none;&quot;&gt;&lt;input class=&quot;input2&quot; id=&quot;graphCode&quot; type=&quot;tel&quot; maxlength=&quot;4&quot; placeholder=&quot;请输入图形验证码&quot;&gt;&lt;img id=&quot;vCodeImage&quot; class=&quot;yzm&quot; src=&quot;&quot; alt=&quot;&quot; /&gt;&lt;/li&gt; &lt;li style=&quot;position:relative&quot;&gt;&lt;input class=&quot;input2&quot; id=&quot;messageVCode&quot; onkeyup=&quot;this.value=this.value.replace(/\D/g,&apos;&apos;)&quot; maxlength=&quot;6&quot; type=&quot;tel&quot; placeholder=&quot;请输入短信验证码&quot;&gt;&lt;button id=&quot;sendMessage&quot; class=&quot;gray&quot;&gt;获取验证码&lt;/button&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot; id=&quot;submitApplication&quot; class=&quot;free&quot;&gt;免费领取&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=&quot;javascript:;&quot; class=&quot;ck&quot; id=&quot;messageTip&quot; style=&quot;text-decoration:none;color:red;&quot;&gt;&lt;/a&gt; &lt;/li&gt; &lt;!--&lt;li&gt;&lt;a href=&quot;#&quot; class=&quot;ck&quot;&gt;已领取，去查看&gt;&lt;/a&gt;&lt;/li&gt;--&gt; &lt;/ul&gt;​ 弹窗相关 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111.addbody &#123; position: fixed; width: 100%; height: 100%; top: 0; left: 0;&#125;​.layer &#123; display: none; position: fixed; width: 100%; height: 100%; top: 0; left: 0; background: rgba(0, 0, 0, 0.7); z-index: 1000;&#125;​.pop &#123; display: none; position: fixed; left: 50%; top: 40%; width: 90%; margin-left: -45%; padding: 2rem 0; box-sizing: border-box; background: #fff; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; transform: translateY(-40%); -webkit-transform: translateY(-40%); -moz-transform: translateY(-40%); -ms-transform: translateY(-40%); -o-transform: translateY(-40%); z-index: 1001;&#125;​//js部分function popShow($id) &#123; $(&apos;body&apos;).addClass(&apos;addbody&apos;); $(&apos;.layer&apos;).show(); $id.show(); &#125;​ function popHide($id) &#123; $(&apos;body&apos;).removeClass(&apos;addbody&apos;); $(&apos;.layer&apos;).hide(); $id.hide(); &#125; $(&apos;&apos;).click(function()&#123; popShow($(pop)); &#125;) $(&apos;.cha&apos;).click(function()&#123; popHide($(pop)); &#125;)//弹窗函数 封装组件的形式 $.fn.popShow = function () &#123; $(&apos;.layer&apos;).show(); $(&apos;body&apos;).addClass(&apos;addbody&apos;); $(this).show(); return this; &#125;​ $.fn.popHide = function () &#123; $(&apos;.layer&apos;).hide(); $(&apos;body&apos;).removeClass(&apos;addbody&apos;); $(this).hide(); return this; &#125;底部按钮的出现和隐藏footer &#123; display: none; opacity: 0; position: fixed; width: 100%; height: 6.5rem; bottom: 0; left: 0; padding: 0.3rem 0 0 0; background-color: #e2a35e; z-index: 1000; transition: all 700ms; -webkit-transition: all 700ms; -moz-transition: all 700ms; -ms-transition: all 700ms; -o-transition: all 700ms; &amp;.fidein &#123; opacity: 1; &#125;&#125;$(window).scroll(function () &#123; var scrollTop = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; var scrollTop = $(window).scrollTop(); var x = $(&apos;.btn&apos;).offset(); var top = x.top; if (scrollTop &gt; top) &#123; $(&apos;.footer&apos;).css(&apos;display&apos;, &apos;block&apos;); setTimeout(function () &#123; $(&apos;.footer&apos;).addClass(&apos;fadein&apos;); &#125;, 0) &#125; else &#123; $(&apos;.footer&apos;).removeClass(&apos;fadein&apos;); &#125; &#125;) 如何让移动端zepto支持动画在github中 https://github.com/madrobby/zepto，找到fx.js文件，把内容追加到zepto.min.js中， 浮动框滑动 12345678910111213141516171819202122232425var timer=null; function startMove(element, iTarget) &#123; clearInterval(timer); timer = setInterval(function () &#123; //因为速度要动态改变，所以必须放在定时器中 var iSpeed = (iTarget - element.offsetTop) / 8; //(目标值-当前值)/缩放系数=速度 iSpeed = iSpeed &gt; 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed); //速度取整 if (element.offsetTop === iTarget) &#123;//结束运动 clearInterval(timer); &#125; else &#123; element.style.top = element.offsetTop + iSpeed + &quot;px&quot;; &#125; &#125;, 30); &#125; var targetY=0; var move=document.getElementById(&quot;move&quot;); window.onscroll = function(e) &#123; var e = e || window.event; var scrolltop = document.documentElement.scrollTop || document.body.scrollTop; targetY=scrolltop+160; /*console.log(targetY);*/ startMove(move,targetY); &#125;; var scrollTop=0; var $body=$(&quot;body&quot;); 页面跳转 相对路径window.location = window.location.origin + &quot;/Html/aghd/native/6/20180927/html/goOpen.html&quot;滚动播放 function moveTop ($obj) { var $child=$obj.children().clone(); $obj.append($child); var initTop=0; var timer=null; clearInterval(timer); timer=setInterval(function () { initTop=$obj.scrollTop(); initTop++; if(initTop&gt;=$child.height()){ initTop-=$child.height(); } $obj.scrollTop(initTop); },50); } moveTop($(&quot;.content-box&quot;));九宫格效果：201810 腾讯音乐]]></content>
      <tags>
        <tag>前端</tag>
        <tag>工作总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vertical-align详解]]></title>
    <url>%2F2018%2F11%2F06%2Fvertical-align%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[vertical-align 是一个容易出bug的属性 首先，为什么有时候始终达不到对齐的效果呢来看看官方定义对不齐的原因主要是因为，父元素 如图，可能的值中，有不少是以父元素作为基准对其的，而不是与其同辈的元素，但是如果同辈元素中均有这一属性 则两者能够水平和对齐，因为他们的基准一致。&lt;p&gt;&lt;img/&gt;balabala&lt;/p&gt;在这段代码里，在img上加vertical-align希望i与文字居中对齐（或者别的）是会出问题的，因为文字不会居中对齐。（某些特定条件下是会对齐的）MDN上对vertical-align的讲解]]></content>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css性能优化]]></title>
    <url>%2F2018%2F11%2F06%2Fcss%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[css经常会要做一些调整，最后几番改动下来乱的自己都看不明白，给人感觉很糟糕，因此一开始就有一个标准并严格按照标准来写就真的非常重要了。特别是在比较忙的时候，自己看自己的代码都会觉得太乱了 很遭罪。因此就需要做出一些优化，高标准严要求哈哈 以下内容整理自稀土掘金中的奇舞周刊1.内联首屏关键css（视情况而定）适当的将渲染首屏内容所需的关键CSS内联到HTML中2.异步加载css3.文件压缩4.去除无用CSS虽然文件压缩能够降低文件大小。但CSS文件压缩通常只会去除无用的空格，这样就限制了CSS文件的压缩比例。那是否还有其他手段来精简CSS呢？答案显然是肯定的，如果压缩后的文件仍然超出了预期的大小，我们可以试着找到并删除代码中无用的CSS。 一般情况下，会存在这两种无用的CSS代码：一种是不同元素或者其他情况下的重复代码，一种是整个页面内没有生效的CSS代码。对于前者，在编写的代码时候，我们应该尽可能地提取公共类，减少重复。对于后者，在不同开发者进行代码维护的过程中，总会产生不再使用的CSS的代码，当然一个人编写时也有可能出现这一问题。而这些无用的CSS代码不仅会增加浏览器的下载量，还会增加浏览器的解析时间，这对性能来说是很大的消耗。所以我们需要找到并去除这些无用代码。 5.有选择的使用选择器 保持简单，不要使用嵌套过多过于复杂的选择器。通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。不要使用类选择器和ID选择器修饰元素标签，如h3#markdown-content，这样多此一举，还会降低效率。不要为了追求速度而放弃可读性与可维护性。BEM命名法 这个命名方式能使结构更加清晰，但是我觉得写出来看着太反人类了，可以借鉴这个思想，但是目前不会用这个方式。 5.减少使用昂贵的属性 所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价 6.优化重排和重绘]]></content>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue demo报错记录]]></title>
    <url>%2F2018%2F11%2F06%2Fvue-demo%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[引入公共scss时的报错用axios+mock造数据在vue中使用font-awesome在vue中使用swipervue-cli项目中的组件注册和引入[vue-router] Duplicate named routes definition: { name: “[object Object]”, path: “/search” }vue-router中的query和parammethod watch 和 computedexpress，10次请求之后，status就pending了]]></content>
      <tags>
        <tag>前端</tag>
        <tag>实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex学习笔记]]></title>
    <url>%2F2018%2F11%2F06%2Fvuex%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[vuex 是vue.js的状态管理模式简言之就是 整个项目多处会用到的公共数据，我们把它拎出来到另一个比较高的维度，（官方说法：把组件的共享状态抽取出来，以一个全局单例模式管理）大家都可以获取，而不需要在组件之间传来传去了。这是我的理解。 vuex 主要包括以下部分： state 由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在computed中返回某个状态 Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中 getter mutation action module参考我的同事整理的笔记]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rn报错记录]]></title>
    <url>%2F2018%2F11%2F06%2Frn%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[react native 从入门的报错记录 1.真机报错2.Could not connect to development server3.React—Native开发之 Could not connect to development server（Android）解决方法 4.启动另一个项目时失败，adb报错device still connecting5.React Native version mismatch 错误6.简化启动夜神模拟器的步骤部分错误是由于rn的版本问题。最好在初始化项目的时候指定版本号，目前0.55.4比较稳定 react-native bundle –platform android –dev false –entry-file index.android.js –bundle-output android/app/src/main/assets/index.android.bundle –assets-dest android/app/src/main/res]]></content>
      <tags>
        <tag>前端</tag>
        <tag>rn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用操作]]></title>
    <url>%2F2018%2F11%2F06%2Fgit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[git的基本操作 整理自廖雪峰的官方网站 git 1. 克隆仓库到本地 git clone 本地代码提交 git pull 更新代码（以免带来冲突） git add . /name 将本地所有改动/特定文件 添加到仓库 （可以add多次） git commit -m ‘对本次改动的说明’ git status （查看结果） git push （提交成功） 查看改动 git diff 查看历史记录 git log 回退到上一个版本 git reset –hard HEAD 回到指定的版本 git reset –hard commit_id 撤销修改 git checkout –file 删除文件 git rm name 分支管理 创建新分支 git branch newbranch 切换到新分支 git checkout newbranch 上述两行可以合并成一行 创建并切换到新分支 git checkout -b newbranch 查看当前分支 git branch 该命令会列出所有分支，当前分支前面会标一个*号。 合并分支到当前分支 git merge branchname 删除分支 git branch -d branchname 暂存当前改动 git stash 查看暂存 git stash list 用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了：]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js高级特性]]></title>
    <url>%2F2018%2F11%2F05%2Fjs%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-2%2F</url>
    <content type="text"><![CDATA[有关于js的几个高级特性 ###作用域1.JavaScript的函数定义是可以嵌套的，每层一个作用域，变量搜索顺序是从内到外2.无论函数内在什么地方定义了变量，变量都会提前到函数开始，但是直到运行到var时才会被初始化，在此之前都是undefined3.函数作用域的嵌套关系是定义时决定的，而不是运行时决定的。即 js的作用域是静态作用域 ###闭包 闭包：由函数及其封闭的自由变量组成的集合体。 特性：当一个函数返回它内部定义的一个函数时，就产生了一个闭包。闭包不但包括被返回的函数，还包括这个函数的定义函数。 作用： - 嵌套的回调函数：让变量的值始终保持在内存中 - 隐藏对象的细节（实现私有成员）：可以读取函数内部的变量 [阮一峰关于闭包的解释](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html) 1234567891011121314151617181920212223242526272829303132333435 var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125; &#125;; alert(object.getNameFunc()());//the windows//在这里首先执行object.getNameFunc() 它是作为一个返回值，返回的结果就是对象里层的function()函数,而这个函数的返回值是一个匿名函数，此时返回的this指向全局变量~var name = &quot;The Window&quot;; var object = &#123; name : &quot;My Object&quot;, getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125; &#125;; alert(object.getNameFunc()());//对象在这里首先执行object.getNameFunc() 它是作为一个返回值，返回的结果就是对象里层的function()函数,而这个返回的函数指向that是指向object对象的哈哈哈 我明白了 ###对象1.call和apply 作用是允许一个对象去调用另一个对象的成员函数 func.call(func被调用时的上下文，传入func的参数) func.apply(func被调用时的上下文，传入func的参数组) 2.bind（有待深入理解啊） 永久绑定函数的上下文 绑定参数表 3.原型 构造函数自身的属性和方法无法被共享，而原型对象的属性和方法可以被所有实例对象所共享。无法被共享带来的影响就是实例化多个对象时，构造函数中的方法就会被调用多次 原型链：js分为两种对象：function和object 在万物皆对象的情况下，函数对象也属于对象，所有对象时最终原型都是object.prototype,而function.prototype是所有函数的原型。 每一个函数都有prototype属性，prototype属性指向该函数的原型对象每一个对象都有proto属性,proto属性指向该对象的构造函数的prototype属性]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端长按弹出事件]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%95%BF%E6%8C%89%E5%BC%B9%E5%87%BA%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[这是在尝试写购物车的时候遇到的问题，长按商品弹出删除的选项框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 // 长按弹出删除弹窗 // var timeOUtEvent = 0; // $(&apos;.shops ul&apos;).on(&#123; // touchstart: function (e) &#123; // var that = $(this); // timeOUtEvent = setTimeout(function () &#123; // that.addClass(&apos;waitdel&apos;); // timeOUtEvent = 0; // pop($(&apos;#pop-del&apos;)); // &#125;, 2000); // e.preventDefault(); // &#125;, // touchmove: function () &#123; // clearTimeout(timeOUtEvent); // timeOUtEvent = 0; // &#125;, // touchend: function () &#123; // clearTimeout(timeOUtEvent); // if (timeOUtEvent != 0) &#123; // $(&apos;#cart&apos;).click( // function (e) &#123; // console.log(1); // if(e.target == $(&apos;#count&apos;))&#123; // console.log(12); // change($(this).find(&apos;#count&apos;)); // &#125; // &#125; // ) // // change($(this).find(&apos;#count&apos;)); // // console.log(timeOUtEvent) // &#125; // // return false; // &#125; // &#125;, &apos;li&apos;)// 长按弹出删除弹窗结束 var timer = null; var t = 0; $(&apos;.shops ul&apos;).on(&#123; touchstart: function (e) &#123; var that = $(this); timer = setTimeout(function () &#123; pop($(&apos;#pop-del&apos;)); that.addClass(&apos;waitdel&apos;) clearTimeout(timer); &#125;, 1000) e.preventDefault(); &#125;, touchend: function () &#123; clearTimeout(timer); &#125; &#125;, &apos;li&apos;) //模拟点击事件 //点击增加商品数量 var t = 0; $(&apos;.shops ul&apos;).on(&#123; touchstart: function () &#123; t = new Date().getTime(); console.log(t) &#125;, touchend: function () &#123; var newT = new Date().getTime(); if (newT - t &lt; 300) &#123; var count = $(this).prev().text(); count = parseInt(count) + 1; $(this).prev().text(count); totalprice(); &#125; &#125; &#125;, &apos;span.ri&apos;)两种方法，各有千秋]]></content>
      <tags>
        <tag>前端</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native]]></title>
    <url>%2F2018%2F11%2F02%2Freact-native%2F</url>
    <content type="text"><![CDATA[第一次尝试写reactnative的demo,下面是遇到的问题的记录 native module ES6，import时如何正确使用花括号’{ }’ React 中组件间通信的几种方式 react-navigation react-navigation3 容易出的bug(实在不行 换回2吧) undefined is not an object (evaluating ‘RNGestureHandlerModule.State’解决方案12345remove node_modules and package-lock.jsonnpm installnpm install --save react-navigationnpm install --save react-native-gesture-handlerreact-native link unable to load script from asset/index.android.bundle问题解决 123mkdir android\app\src\main\assetsreact-native bundle --platform android --dev false --entry-file index.js --bundle-output android/app/src/main/assets/index.android.bundle --assets-dest android/app/src/main/resreact-native run-android could not get batchedbridge, make sure your bundle is packaged correctly 查看端口和ip是否正确 端口是否被占用 react中的refs FlatList animated Warning: isMounted(…) is deprecated in plain Javascript Classes. Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks. 这是组件本身的bug 目前的解决方法是忽略 import { YellowBox } from ‘react-native’; YellowBox.ignoreWarnings([‘Warning: isMounted(…) is deprecated’, ‘Module RCTImageLoader’]); 真机报错 Could not connect to development server React—Native开发之 Could not connect to development server（Android）解决方法 启动另一个项目时失败，adb报错device still connecting React Native version mismatch 错误 简化启动夜神模拟器的步骤部分错误是由于rn的版本问题。最好在初始化项目的时候指定版本号，目前0.55.4比较稳定 react-native bundle –platform android –dev false –entry-file index.android.js –bundle-output android/app/src/main/assets/index.android.bundle –assets-dest android/app/src/main/res]]></content>
      <tags>
        <tag>前端</tag>
        <tag>rn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的this]]></title>
    <url>%2F2018%2F09%2F15%2Fjs%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[关于this的讲解 this是什么 调用对象的方法识别和引用我们当前正在使用的对象的方法 构造函数在实例化构造函数的过程中，new 函数调用如果我们只调用一个普通的日常函数而没有任何这些奇特的对象，那么 这时的this可以做最全局的事情，也就是说这时候this是指向window对象的 事件处理程序 系统的阐述this的指向this的指向只有在函数执行的时候才可以确定到底指向谁，实际上this最终指向的是最后调用它的对象 情况1：如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window，这里需要说明的是在js的严格版中this指向的不是window. 情况2：如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。 情况3：如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象在严格模式中的默认的this不再是window，而是undefined。 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。 bind/call/apply对this指向的改变call/apply是直接进行相关函数的调用,bind不会指向相关函数,而是返回一个新的函数,这个新的函数已经自动绑定了新的this指向.而call和apply的区别主要体现在,参数类型的不同,apply的参数可以是一个数组. 箭头函数中this的指向箭头函数的this 是根据外层(函数或者全局)上下文来决定的. this的显式绑定和隐式绑定通过 call、apply、bind、new 对 this 绑定的情况称为显式绑定；根据调用关系确定的 this 指向称为隐式绑定。call apply的显式绑定一般来说更加高级. 开放问题: 实现一个bind函数]]></content>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css实用代码片段]]></title>
    <url>%2F2018%2F09%2F15%2Fcss%E5%AE%9E%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[这些是常用的css代码片段，对我个人而言比较实用，可以省去很多不必要的麻烦 h3 { span { } span:before { content: “”; display: inline-block; width: ; height: ; margin: 0 0.5rem; background: url(../../resource/img/) no-repeat; background-size: 100% 100%; vertical-align: middle; } span:after { content: “”; display: inline-block; width: ; height: ; margin: 0 0.5rem; background: url(../../resource/img/) no-repeat; background-size: 100% 100%; vertical-align: middle; } }标题左右加装饰 :before,:after { position: relative; bottom: 0.4rem; content: ‘’; display: inline-block; width: 4rem; border-top: 1px solid #fff;}背景加一条线 display: -webkit-box;display: -webkit-flex;display: -ms-flexbox;display: flex; display: inline-block;-webkit-box-flex: 1;-webkit-flex: 1;-ms-flex: 1;flex: 1;flex布局的兼容性写法 box-shadow: inset 0 0 5px 3px #F86509;四边内边框 overflow: hidden;text-overflow: ellipsis;white-space: nowrap;单行内容超出宽度隐藏 background: -ms-linear-gradient(top, #ff7d08, #fee6ae);background: -moz-linear-gradient(top, #ff7d08, #fee6ae);background: -webkit-linear-gradient(top, #ff7d08, #fee6ae);background: -o-linear-gradient(top, #ff7d08, #fee6ae);背景色渐变 background: -ms-linear-gradient(top, #fff, #FFD246);background: -moz-linear-gradient(top, #fff, #FFD246);background: -webkit-linear-gradient(top, #fff, #FFD246);background: -o-linear-gradient(top, #fff, #FFD246);-webkit-background-clip: text;-webkit-text-fill-color: transparent;文字渐变 Ie8及以下浏览器兼容背景半透明的写法background: rgba(0, 0, 0, .5);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#88000000,endColorstr=#88000000);其中 样式里的 #88000000 说明：• 前两位是十六进制透明值，00 是完全透明，FF 是完全不透明。• 后六位是十六进制颜色值。 transform: rotate(-135deg);transform: rotate(-135deg);-ms-transform: rotate(-135deg);-moz-transform: rotate(-135deg);-webkit-transform: rotate(-135deg);-o-transform: rotate(-135deg);transform兼容性写法 @media screen and (max-width: 320px) { }媒体查询 特殊字体@font-face { font-family: ‘’; font-style: ; src: url();} font-family: Helvetica, Tahoma, Arial, “PingFang SC”, “Hiragino Sans GB”, “Heiti SC”, “Microsoft YaHei”, “WenQuanYi Micro Hei”, sans-serif;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pc端兼容性总结]]></title>
    <url>%2F2018%2F08%2F23%2Fpc%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[##pc端开发容易被忽略的点1.各个浏览器的兼容性，重点考虑ie兼容性2.开发过程中，尽量使用向上兼容的方式3.不同的部分需要注意cursor的值（小手）4.不同大小屏幕如何适应 ##兼容性问题1.ie浏览器中兼容背景渐变以及半透明背景 filter: progid:DXImageTransform.Microsoft.gradient (GradientType=0, startColorstr=#00000000, endColorstr=#cc000000);-ms-filter: “progid:DXImageTransform.Microsoft.gradient (GradientType=0, startColorstr=#00000000, endColorstr=#cc000000)”; ‘#00000000’：前两位代表透明度。00 是完全透明。 FF 是完全不透明。后六位代表rgb值2.display:inline-block在ie7以及以下浏览器失效 解决办法 12345display:inline-block;*display:inline;*zoom:1; 原因：ie和其他浏览器的表现形式上不一样，即使是inline-block触发了haslayout还是不具有inline-block不换行的特性 详解haslayout ie8以下布局bug基本都由haslayout引起 3.ie 6 7下js报错 缺少标识符 字符串或数字的解决 4.overflow:hidden在ie7下失效 问题原因：当父元素的直接子元素或者下级子元素的样式拥有position:relative属性时，父元素的overflow:hidden属性就会失效。 解决方法：我们在IE7内发现子元素会超出父元素设定的高度，即使父元素设置了overflow:hidden。 解决这个bug很简单，在父元素中使用position:relative;即可解决该bug，就是用到overflow的父节点中增加相对定位即可。 ie浏览器下使用另外的jquery版本和样式 1234&lt;!--[if lte IE 8]&gt;&lt;html class=&quot;ie&quot;&gt;&lt;script src=&quot;http://cdn.bootcss.com/jquery/1.9.0/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;]]></content>
      <tags>
        <tag>前端</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端兼容性问题]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[##移动端注意事项 1.移动端好用的flex布局兼容性写法 123456789101112131415161718192021222324display: -webkit-box;display: -webkit-flex;display: -ms-flexbox;display: flex;//定义布局为flex布局-webkit-box-orient: vertical;-webkit-flex-direction: column;-ms-flex-direction: column; flex-direction: column;//垂直布局-webkit-box-flex: 1;-webkit-flex: 1;-ms-flex: 1; flex: 1;//子元素占据空间-webkit-box-align: center;-webkit-align-items: center;-ms-flex-align: center; align-items: center;//子元素垂直居中-webkit-box-pack: center;-webkit-justify-content: center; -ms-flex-pack: center;justify-content: center;//子元素水平居中 2.]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端布局（一）]]></title>
    <url>%2F2018%2F05%2F15%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本来想自己写，但是别人都已经写的非常好了。。。 转载自掘金社区 //js动态计算 1234567891011121314//定义一个方法并执行(function(doc, win) &#123; var docEl = doc.documentElement; resizeEvt = &apos;orientationchange&apos; in win ? &apos;orientationchange&apos; : &apos;resize&apos;; var recalc = function() &#123; var clientWidth = docEl.clientWidth; if(!clientWidth) return; docEl.style.fontSize = 50 * ((clientWidth &gt;= 750 ? 750 : clientWidth) / 375) + &apos;px&apos;; /*docEl.style.fontSize = 50 * (clientWidth / 320) + &apos;px&apos;;*/ &#125;; if(!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);&#125;)(document, window);]]></content>
      <tags>
        <tag>前端</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp入门]]></title>
    <url>%2F2018%2F04%2F01%2Fgulp%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[gulp.js中文网gulp 基于流的自动构建工具,减少io,提高性能 browserify: 一个前端依赖的工具，可以实现js的模块化加载，主要通过commonjs来实现，]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上班后的第一篇]]></title>
    <url>%2F2018%2F04%2F01%2F%E4%B8%8A%E7%8F%AD%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[实习一个星期，最大的感受就是自己好菜还有就是下班之后好困。回头想想之前立的flag,大多数都不了了之。所以，怎么样做个自律的人呢要学的东西还有很多，在公司的开发和以前做的些东西确实有些出入。尽快成长起来才是硬道理呀~]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从乡下归来]]></title>
    <url>%2F2018%2F03%2F08%2F%E4%BB%8E%E4%B9%A1%E4%B8%8B%E5%BD%92%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[经历了一个多月没有WiFi的生活~倒也没有多么难过。各种情绪都有过，但是也想通了许多事情。博客没有写，这倒是有点遗憾了。人呐，每天都会有好多的想法，有时候把有些东西记录下来，其实也是件有意思的事情。功利点想，或许也是一件对以后的发展都很有益的事情呢最近收到了个kindle，除了压泡面之外，对于比较喜欢看书的人来说也的确是个很值得入的东西。倒不是说电子水墨屏有多么护眼，反正多年以来我眼镜的度数也没涨起来过，我觉得，kindle这种除了看书啥也不能干的设定，才是它最大的亮点，嘻嘻嘻，去看书了~]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寒假计划]]></title>
    <url>%2F2018%2F01%2F27%2F%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[人生中最后一个寒假了。在家陪陪亲人，走走亲戚，也就过去了。本想着回家之后认真学习一点东西，现实无情的打了脸，哈哈哈。也好，在适当的时间做适当的事情反而会事半功倍，这种时候，应该多看看闲书，多思考一些平日里想不明白的事情比较好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F01%2F07%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[菜鸟教程的正则表达式教程正则表达式，我实在不知道要把它归类在哪个分类里。以后肯定还会有一些不知道怎么分类的文章，索性开个新分类–杂哈哈哈 正则表达式的作用总结起来就两个字，匹配。常见匹配方式/d 匹配0到9内的任意数字 字符组的简写形式[0-9] 匹配0到9内的任意数字 字符组匹配. 可以匹配任意字符 通配符将内容放在圆括号中捕获分组和\1向后引用通常可以将简写式取反，取反的结果就是排除。如\d是匹配任意数字\D则用来匹配任意非数字字符在匹配的过程中使用量词匹配的过程离不开元字符，元字符可以说是基础了。 ###元字符###菜鸟教程中关于元字符的详细介绍 然后就是匹配规则之类的东西，看起来很复杂，但是实际上就是一个熟能生巧的过程，用多了之后就能一目了然了 以上以后补充]]></content>
      <tags>
        <tag>杂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近沉迷于模拟人生]]></title>
    <url>%2F2018%2F01%2F07%2F%E6%9C%80%E8%BF%91%E6%B2%89%E8%BF%B7%E4%BA%8E%E6%A8%A1%E6%8B%9F%E4%BA%BA%E7%94%9F%2F</url>
    <content type="text"><![CDATA[如题，最近沉迷于模拟人生这个单机游戏，熬夜玩游戏涨了两颗痘痘~不太爱玩竞技类的游戏，像解密啊养成类的游戏对我来说就比较耐玩了感觉很神奇啊 屏幕里的小人们，忙忙碌碌，有时候也会按照自己的想法产生一些行为很可爱姑且认为是他们是他们自己的想法吧]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学eslint]]></title>
    <url>%2F2018%2F01%2F02%2F%E5%88%9D%E5%AD%A6eslint%2F</url>
    <content type="text"><![CDATA[还是说，每天学习一点点~元旦浪完了滚回来继续学习。毕竟生活还有眼前的苟且和枸杞。ESLint在之前有接触过，只知道是一个es6的代码风格检查工具，所以。。。到底具体是做什么呢，走进计算机科学之——eslint JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调适。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。 ESLint 被设计成完全可配置的，开发人员可以通过自定规则来规范代码的风格。 可以直接把代码嵌入到js文件 配置文件 可以被配置的文件主要分为三类： 环境 environments 如node.js browser commonjs等 额外全局变量 globals 开启规则 rules 还是这种插件还是比较适合在用的过程中了解啊 明天有电话面试好紧脏~]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端模块化之commonJS]]></title>
    <url>%2F2017%2F12%2F22%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B9%8BcommonJS%2F</url>
    <content type="text"><![CDATA[整理自 阮一峰的《javascript标准参考教程》node.js采用的CommonJS模块规范，看别人的博客都在说之后的模块化方案会趋向于采用ES6中的模块化方案。作为一个还在学习，尚未投入到工作中的小可爱，再加上最近在学习node.js所以打算从CommonJs规范下手。 moduleCommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。require方法用于加载模块。 12345678910var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX;var example = require(&apos;./example.js&apos;);console.log(example.x); // 5console.log(example.addX(1)); // 6 CommonJS模块的特点如下: 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 每个模块内部，都有一个module对象，代表当前模块。它有以下属性: module.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回一个对象，表示调用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 module.exports 表示模块对外输出的值。 AMD规范与CommonJS规范的兼容性CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。浏览器端一般采用AMD规范。AMD规范使用define方法定义模块。AMD规范允许输出的模块兼容CommonJS规范。 require命令require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。 加载规则require命令用于加载文件，后缀名默认为.js根据参数的不同格式，require命令去不同路径寻找模块文件。 目录加载规则通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。在目录中放置一个package.json文件，并且将入口文件写入main字段。require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。 模块的缓存第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。 环境变量NODE_PATHNode执行一个脚本时，会先查看环境变量NODE_PATH。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。可以将NODE_PATH添加到.bashrc。 模块的循环加载如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。 require方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。直接执行的时候（node module.js），require.main属性指向模块本身。 模块加载机制CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记第一次使用node.js开发的过程]]></title>
    <url>%2F2017%2F12%2F19%2F%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8node-js%E5%BC%80%E5%8F%91%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[看了几天node.js的书和视频，今天终于是到了要动手写代码的时候了。模仿书上的小demo，做个微博~ 首先，安装express框架。node.js的Http模块提供的是底层的接口，虽然可以让我们对http协议有更好的理解，但是不易于实现和使用。所以我们选择了express框架。 安装express $npm install -g express 为了比较方便的在命令行中使用，所以选择了全局安装。这里我们可能会遇到一个问题。安装之后，依然提示 &#39;express&#39;不是内部或外部命令··· 这是因为：新版本将命令工具分家了，所以先另外再安装它 $npm install -g express-generator 这和一些比较老的教程之间有出入，值得初学者注意。 建立工程 $expres -t ejs microblog这行命令表示初始化一个叫microblog的项目并指定ejs模板引擎。在看不明白命令行的意思或者不知道应该用哪个命令时，express --help命令能给我们提供些许帮助。初始化后会提示我们进入项目中并执行npm install，这个命令的作用是检查当前目录下的package.json。在这里，它会自动安装ejs和express不知道为啥默认安装了jade（据说jade功能强大但是学起来会比较复杂，所以我暂时选择了比较简单一点的ejs）,所以手动去package.json中的dependencies里手动配置了ejs 当当当 当我看到项目自动配置里全都是jade的时候，我的内心是崩溃的，索性删掉整个项目重新开始 ，反正我又没开始写，万幸这次我认真看了警告并老老实实用了help命令，所以是现在新版的变动嘛 所以，一定要自己写，并老老实实一步一个坑踩过来~ 呀土豆的蜂蜜黄油味真的是一言难尽 启动服务器 $node app.js $npm start当当当~ 可以了node.js中在不重启的情况下刷新页面获得的都是第一次启动时存在内存中的数据，所以不会发生改变。ctrl+c可以关闭，要想实现监事代码和自动重启，可以安装supervisor 现在，一个项目的框架搭建好了。但是参照的教程出版于2012年，五年过去了技术也有了一些革新，对初学者来说这确实是一个问题了，这时候，万事靠自己啦~ 边对照教程边在网上查资料然后记得一定要添加注释，否则过几天之后，可能就完全不知道自己写的是什么东西了。 像下面就是踩坑记录啦~我用的是webstrom做的开发，所以遇到的坑都是在webstrom中的情况 对index.js页面做了修改之后无效，后来发现是require被提示提示 unresolved function or method解决办法：在WebStorm中的File菜单项中选择Setting–Javascript–libraries–Add添加Node.js Core Modules项 路由控制的实现是一个有点复杂的过程，但这也是node.js的亮点之一。好在express框架封装了路由，不需要我们手动去实现，但是这一部分还是很有必要去了解一下的。 写到这里又转头回去学中间件和路由去了。所以呀，对学的东西有个大致的了解之后动手，不会的再有针对性的学~ 卡在了设置路由这里好久，又回过头重新看了路由和中间件的知识，最终，在趴在桌子上睡完午觉之后喝了一瓶旺仔牛奶的中午，我终于弄出来了！！！撒花 接下来，安装MongoDB，以前没有接触过，又get了一项需要学习的新技能··· 安装之后要记得在package.json中更新模块依赖并用npm install下载。如何正确的安装和操作使用是一门大学问。折腾了好几个小时。。安装了一个gui,我对命令行一向无感，可能是没吃过用GUI的苦···]]></content>
      <tags>
        <tag>前端</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js高级特性]]></title>
    <url>%2F2017%2F12%2F18%2Fjs%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[今天看了一本书，一本专业书，丝毫不然人觉得烦躁乏味的专业书。《node.js开发指南》是我看的第一本node.js的书。作为入门来说，至少不会想让人立马从入门到放弃。很喜欢这本书的附录里总结的关于js高级特性的东西，这也是前端校招中必考问题，故而也想顺着这个思路整理一下。膜拜大神BYVoid 作用域JavaScript 的作用域完全是由函数来决定的，if、for 语句中的花括号不是独立的作用域。 在函数中引用一个变量时，JavaScript 会先搜索当前函数作用域，或者称为“局部作用域”，如果没有找到则搜索其上层作用域，一直到全局作用域。 有一点需要注意：函数作用域的嵌套关系是定义时决定的，而不是调用时决定的，也就是说，JavaScript 的作用域是静态作用域，又叫词法作用域，这是因为作用域的嵌套关系可以在语法分析时确定，而不必等到运行时确定。 满足以下条件的变量属于全局作用域： 在最外层定义的变量； 全局对象的属性； 任何地方隐式定义的变量（未定义直接赋值的变量）。node.js最后那个没有最外层定义的变量，它是以模块的形式存在，模块不是最外层的。所以在node.js中，没有最外层定义的变量。全局对象是global对象。 闭包由函数（环境）及其封闭的自由变量组成的集合体。（这个概念太难懂了…）当一个函数返回它内部定义的一个函数时，就产生了一个闭包，闭包不但包括被返回的函数，还包括这个函数的定义环境。 闭包的用途 嵌套的回调函数 实现私有成员JavaScript的对象没有私有属性，也就是说对象的每一个属性都是曝露给外部的。闭包可以让函数内部变量对外不可见。只能通过返回的函数来使用。 对象 使用关联数组访问对象成员 使用对象初始化器创建对象使用初始化器时，对象属性名称是否加引号是可选的，除非属性名称中有空格或者其他可能造成歧义的字符，否则没有必要使用引号。 1234567var foo = &#123; &apos;prop1&apos;: &apos;bar&apos;, prop2: &apos;false&apos;, prop3: function ()&#123; return &apos;hello world&apos;; &#125; &#125;; 构造函数 123456789function User(name, uri) &#123; this.name = name; this.uri = uri; this.display = function() &#123; console.log(this.name); &#125; &#125; 以上是一个简单的构造函数，接下来用 new 语句来创建对象：var someuser = new User(&apos;byvoid&apos;, &apos;http://www.byvoid.com&apos;); 上下文对象this 指针不属于某个函数，而是函数调用时所属的对象。使用不同的引用来调用同一个函数时，this 指针永远是这个引用所属的对象。在 JavaScript 中，本质上，函数类型的变量是指向这个函数实体的一个引用，在引用之间赋值不会对对象产生复制行为。我们可以通过函数的任何一个引用调用这个函数，不同之处仅仅在于上下文。 call &amp;&amp; apply &amp;&amp; bindcall 和 apply 的功能是以不同的对象作为上下文来调用某个函数。简而言之，就是允许一个对象去调用另一个对象的成员函数。call 和 apply 的功能是一致的，两者细微的差别在于 call 以参数表来接受被调用函数的参数，而apply以数组来接受被调用函数的参数。call 和 apply 的语法分别是：func.call(thisArg[, arg1[, arg2[, ...]]])func.apply(thisArg[, argsArray])通过这种方法，将func的上下文对象变成了thisArg bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。即使用bind方法来永久地绑定函数的上下文，使其无论被谁调用，上下文都是固定的。bind 语法如下：func.bind(thisArg[, arg1[, arg2[, …]]])bind方法还有一个重要的功能：绑定参数表。一篇别人的总结，附有比较详细的例子 原型通过原型和构造函数初始化对象的区别 构造函数内定义的属性继承方式与原型不同，子对象需要显式调用父对象才能继承构造函数内定义的属性。 构造函数内定义的任何属性，包括函数在内都会被重复创建，同一个构造函数产生的两个对象不共享实例。 构造函数内定义的函数有运行时闭包的开销，因为构造函数内的局部变量对其中定义的函数来说也是可见的。 两种方式分别使用的情况 除非必须用构造函数闭包，否则尽量用原型定义成员函数，因为这样可以减少开销。尽量在构造函数内定义一般成员，尤其是对象或数组，因为用原型定义的成员是多个实例共享的。 原型链JavaScript 中有两个特殊的对象： Object 与 Function，它们都是构造函数，用于生成对象。Object.prototype是所有对象的祖先，Function.prototype是所有函数的原型，包括构造函数。 把JS对象大致分为三类： 用户创建的对象：new 显式创建的对象 构造函数对象：new调用普通对象生成的函数对象 原型对象：特指构造函数 prototype 属性指向的对象 所有的对象都有proto属性，该属性对应该对象的原型. 所有的函数对象都有prototype属性，该属性的值会被赋值给该函数创建的对象的_proto_属性. 所有的原型对象都有constructor属性，该属性对应创建所有指向该原型的实例的构造函数. 函数对象和原型对象通过prototype和constructor属性进行相互关联. 对象克隆 浅克隆 深克隆]]></content>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识less预处理器]]></title>
    <url>%2F2017%2F12%2F16%2F%E5%88%9D%E8%AF%86less%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[哒哒哒~ 每天学习一点点新东西通过阅读别人的博客初识了css预处理器的强大，我选择了less预处理器作为入门，同时，我也认为利用处理器对css进行某些操作能极大地简化后期的维护和管理，在编写的时候也能带来一些便利，当然这只是我目前的认知，在系统的学习之前的认知~ 但是毫无疑问，在高速的技术迭代中，前端的发展趋于一个更加简化和智能的方向。 Less 是一门 CSS 预处理语言，它扩充了 CSS 语言，增加了诸如变量、混合（mixin）、函数等功能，让 CSS 更易维护、方便制作主题、扩充。 Less 可以运行在 Node、浏览器和 Rhino 平台上。–来自less官方中文文档。 工欲善其事，必先利其器。想要学东西，先要搭环境。less可以在多种环境中编译，我选择的是桌面客户端，下载了一个非常cute的小软件koala，在把项目拖入到koala中后，第一次手动编译之后，他就会自动将less文件自动编译成css文件。也可以直接在webstrom中配置一个编译环境出来。 接下来，就要是语法部分了lee中文文档中关于语言特性的介绍 注释 //和/* */两种注释，后者在编译的过程中是会被编译的 变量 定义变量的格式为 @变量名：设置值;使用时就直接作为一个属性值。 12345@test_width:300px;box &#123; width:@test_width;//编译出来这个width值为300px&#125; 混合（mixin) 就是一种将一系列属性从一个规则集引入(“混合”)到另一个规则集的方式。 123456789101112131415161718192021//less文件@box_width: 300px;.box &#123; width: @box_width; background: red; .border;&#125;.border &#123; border: solid 5px pink;&#125;//css文件@charset &quot;UTF-8&quot;;.box &#123; width: 300px; background: red; border: solid 5px pink;&#125;.border &#123; border: solid 5px pink;&#125; 这也是混合的一种实用的功能 123456789101112131415161718192021//less文件.border_radius(@radius:5px) &#123; -webkit-border-radius: @radius; -moz-border-radius: @radius; border-radius: @radius;&#125;.radius_test &#123; width:100px; height: 200px; background-color:green; .border_radius(10px);&#125;//css文件.radius_test &#123; width: 100px; height: 200px; background-color: green; -webkit-border-radius: 10px; -moz-border-radius: 10px; border-radius: 10px;&#125; 匹配模式相当于给一个函数设定不同的参数，如果学过java的话，参照函数的重载，他们参数不同拥有不同的功能，而在less模式匹配这里，参数不同对应不同的样式。（这样写暂时便于我自己的理解，以后理解的深一点了应该能把这部分解释的更好一些，顺便提醒：不要弄混了java的重载和重写） 运算可以对less中的变量进行 + — * / 的运算 嵌套规则就是很字面的意思呗样式集合可以嵌套在另一个样式集合里~ 1234567891011121314less文件li &#123; display:inline; a &#123; background:red; &#125;&#125;css文件li &#123; display: inline;&#125;li a &#123; background: red;&#125; arguments变量@arguments 一次性传递所有变量~ 炸了炸了，以后等我进阶了再作补充吧~最近感觉学习的很轻松，每当这种时候就觉得很惶恐，感觉是认知停留在了一个比较浅的层次，还是得抓紧时间好好学习啊~ 昨晚做梦，梦到一觉睡到了明年四月，醒过来最着急的是春招过了，而我技术还没学到家···sad,然后被自己着急醒了还好还好]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于web可访问性的思考]]></title>
    <url>%2F2017%2F12%2F15%2F%E5%85%B3%E4%BA%8Eweb%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[今天看书的时候看到了web可用性的相关问题，我一直是一个比较爱思考这类问题的人，所以打算写下我的看法~ 首先，谈谈作为一个用户的看法： 如果一个前端做的很丑的页面或者哎拍拍，我是不太愿意用的，如果这个哎拍拍是有同类型替代的，那么我大概会立马删掉转而投入别家的怀抱，根本就不会关心它是否功能比别家强大之类的东西了。作为一个比较注重功能的女生，我都已经是受不了，更别提颜控的小女生们啦（我的大胆猜测，不知道跟实际有没有出入，但是好好做外观总是没有错的）~ 然后就是容易上手。这一点很重很重要，如果一个软件或者页面使用前还要看一大堆操作说明（除了专业性很强的软件，但是最好也要符合该专业的常规使用方法），那我，除非必要，否则还是会投入别人家的怀抱。同样如果功能做的及其花哨复杂不好用，那么不好意思，下一个。 再有就是，我是一个健健康康的普通用户，但是这个东西做出来也可能会有一些特殊的用户，比如色弱色盲之类的，考虑到这种情况，我们在设计之初就应该尽量避免呢。总之，我认为应该充分考虑到我们的客户群体的情况，尽可能的满足人性化的需求，当然这并不意味着一定要为极少的个例去把东西做的繁琐，这样可能有点得不偿失了，这个问题在具体的项目中，应该会有不同的思考方向。感觉这些都比较偏向设计方面的问题了，但是我就是一个不羁的前端，作为一个和用户“面对面”的工程师，对这方面有些思考总是没有坏处。其次，我就要谈谈作为一个前端工程师的看法了： 我认为前端和美工都得考虑到上述问题，前端工程师还要另外考虑一些更专业更底层的问题。 如果是移动端的应用，那么在不同的设备上的显示问题就至关重要了，必须要考虑到常见浏览设备的显示和兼容问题。否则会非常影响用户体验，就又要面临被抛弃的悲剧了哭唧唧~~ 众所周知，前端的技术发展更新是非常快的，那么我们在写代码时就要考虑到这一点，尽可能的为以后技术的更新提供一些便利，方便以后的维护和更新，万一以后维护更新的还是你嘞~ 虽然我根本没有接触过实际的代码优化啥啥的这种大阵仗，但是······但是啥 自言自语好像这个博客有除了我自己之外的人看似的··· 暂时到这里，说不定我以后会有新的灵光一闪呢]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础之ajax]]></title>
    <url>%2F2017%2F12%2F15%2Fjs%E5%9F%BA%E7%A1%80%E4%B9%8Bajax%2F</url>
    <content type="text"><![CDATA[AJAX即异步javascript和XMLajax是一个非常基础又常见的前端技能。我认为它的核心就是实现局部刷新。这在网站中是非常有用的。下面是我整理的学习过程和心得~ 运用ajax大致是这样一个过程 创建XMLHttpRequest对象var xhr = new XMLHttpRequest();FF,Chorme,Safari,Opera,IE7及以上的浏览器都支持xhr对象，IE7以下浏览器不支持，使用的是ActiveXObject 请求XMLHttpRequest 对象用于和服务器交换数据。要将请求发送到服务器，要用到对象的open和send方法。 12xmlhttp.open(method,url,async)xmlhttp.send(); 通过 AJAX，JavaScript 无需等待服务器的响应，而是：在等待服务器响应时执行其他脚本，当响应就绪后对响应进行处理当使用 async=true 时，要规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数readyState 属性存有 XMLHttpRequest 的状态信息，每当 readyState 改变时，就会触发 onreadystatechange 事件。当使用 async=false 时，不要编写 onreadystatechange 函数，把代码放到 send() 语句后面即可 响应 要获得来自服务器的响应，使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 这个东西说简单简单说复杂复杂，但是平时自己折腾的东西里面很少会涉及到与后台有交互的东西，所以总也搞不太明白，看来还是要多找找东西写和多了解一下底层原理呀~]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm依赖管理]]></title>
    <url>%2F2017%2F12%2F14%2Fnpm%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[npm是node.js的包管理器，在前端项目中我们经常用它来加载模块，npm库有许多实用的包，使用起来也非常方便，只需要用命令行下载就行了。在项目的拷贝迁移和管理过程中，也能极大地提供方便。 npm中的–save命令行会自动将加载的依赖添加到package.json文件中。npm 目前支持以下几类依赖包管理： dependencies 应用依赖：它用于指定应用依赖的外部包，这些依赖是应用发布后正常执行时所需要的，但不包含测试时或者本地打包时所使用的包。devDependencies 开发环境依赖：它的对象定义和dependencies一样，只不过它里面的包只用于开发环境，不用于生产环境，这些包通常是单元测试或者打包工具等peerDependencies 同等依赖：或者叫同伴依赖，用于指定当前包（也就是你写的包）兼容的宿主版本。optionalDependencies 可选依赖：如果有一些依赖包即使安装失败，项目仍然能够运行或者希望npm继续运行，就可以使用optionalDependencies。另外optionalDependencies会覆盖dependencies中的同名依赖包，所以不要在两个地方都写。bundledDependencies / bundleDependencies 打包依赖：是一个包含依赖包名的数组对象，在发布时会将这个对象中的包打包到最终的发布包里。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于http协议]]></title>
    <url>%2F2017%2F12%2F13%2F%E5%85%B3%E4%BA%8Ehttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[最近看到http2协议，一直以来对网络的知识都是一知半解，现在想想，简直搞不懂以前上网络课的时候学了什么~ 看来是时候深入了解一下HTTP协议了~ http协议是基于tcp/ip协议之上的应用层协议，是一个无状态协议。 HTTP0.9 这是最早版本的http协议，这时候的协议还极其简单，只有一个get方法。服务器只能回应HTML格式的字符串，不能回应别的格式 http1.0 这时候可以发送任何格式的内容了。还引入了post 和 head 命令，http请求和响应报文的格式也发生了较大的改变，除了数据之外，额外增加了http header。也新增了许多功能包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。为了解决这个问题，有些浏览器在请求时，用了一个非标准的Connection字段。这个字段要求服务器不要关闭tcp连接，直到被主动关闭，但是它不是根本的解决办法，所以有http1.1横空出世啦~ http1.1 这一版本最大的变化是实现了持久化的连接，即tcp默认不关闭，但是这个持久化和WebSockets的持久化连接是不一样的注意区分。目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。新增管道机制，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。Content-Length 字段 一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是Content-length字段的作用，声明本次回应的数据长度。1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。但是在在一个TCP连接中，数据通信依然是按照顺序进行的，只有前一个回应传回来了才能发送下一个请求，这就可能造成对头堵塞。 HTTP2 HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。在HTTP/2中，将所有的请求或者回应的数据包，成为一个数据流，每个数据流都有独一无二的编号来指出他们属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。服务器推送 HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。划重点，这里的服务器推送和WebSockets里的推送有本质上的区别。]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全性问题]]></title>
    <url>%2F2017%2F12%2F10%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天不知道怎么突然想起来前端的安全性问题，之前遇到过这样的笔试题，了解过，但是感觉没明白，又忘记了，所以今天来做一个总结。 SQL注入：通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。防护措施：前端页面要校验用户的输入数据，后端不要使用动态SQL语句，不要直接存放机密数据。（严格说，sql注入属于后端的安全问题） XXS跨站脚本分析：攻击者将恶意脚本插入到网页中，网页会将这些恶意脚本当正常脚本来执行。所有可输入的地方没有处理输入的数据，就可能存在xxs漏洞。为了防护应该尽可能完善过滤体系。 iframe风险iframe中的内容是由第三方来提供的，默认情况下他们不受我们的控制，他们可以在iframe中运行JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端用户体验。如果iframe中的域名因为过期而被恶意攻击者抢注，或者第三方被黑客攻破，iframe中的内容被替换掉了，从而利用用户浏览器中的安全漏洞下载安装木马、恶意勒索软件，这样就会有很大的安全隐患了。 CSRF 跨站请求伪造：CSRF攻击过程的受害者用户登录网站A，输入个人信息，在本地保存服务器生成的cookie。然后在A网站点击由攻击者构建一条恶意链接跳转到B网站,然后B网站携带着的用户cookie信息去访问B网站.让A网站造成是用户自己访问的假相,从而来进行一些列的操作,常见的就是转账. emm~ 大概暂时就这些了，当然还有别的安全问题，但是我好像不太能理解，粗略的浏览了一下，然后以后弄明白点了再补充吧 补充：前端安全性问题之跨域所谓的跨域，是为了避免前端安全性问题而做的同源策略引发的问题。同域名、同端口、同协议视为同一个域，一个域内的脚本仅仅具有本域内的权限，可以理解为本域脚本只能读写本域内的资源，而无法访问其它域的资源。否则，就是跨域。在同源策略的限制下允许部分不遵循同源策略访问的方式就是跨域这里是一篇我认为总结的很好的博客这是个跟我差不多情况的博主写的博客~ 常见的跨域方式有： jsonp Jsonp(JSON with Padding)是json的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。因为通过script标签引入的js是不受同源策略的限制的。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。可以看出来JSONP跨域一般用于获取其他域的数据。 ifarme iframe跨域的原理跟script跨域一样，但是我们要注意的是标签自身功能的差异性，具体差异如下： script单纯就是引入的作用，但是iframe标签还有一个作用是显示的作用可以把远程加载的HTML代码显示出来，也就是script无法引入HTML代码文件script标签只能够从远程获取数据，无法操作远程文件执行。但是iframe可以这样 document.domain window.name cookie postMessage 还是不太明白~]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js入门(3)]]></title>
    <url>%2F2017%2F12%2F09%2Fnode-js%E5%85%A5%E9%97%A8-3%2F</url>
    <content type="text"><![CDATA[express框架中文官网基于 Node.js 平台，快速、开放、极简的 web 开发框架。express可以极大程度上简化nodejs，它由许多api非常方便使用。node.js的http封装的程度不高，路由由原生代码实现起来比较复杂。在我目前的感知里，我认为框架最主要就是实现了比较方便的路由的架构。 12345678var express = require(&apos;express&apos;);var app = express();app.get(&apos;/&apos;, function(req, res)&#123; res.send(&apos;hello world&apos;);&#125;);app.listen(3000); 路由 app.method常用method有post和get。还有很多，官方文档都有介绍。 123app.get(&apos;网址&apos;, function()&#123;&#125;);app.post(&apos;网址&apos;, function()&#123;&#125;);app.all(&apos;网址&apos;, function()&#123;&#125;); 它的作用是对于一个路径上的所有请求加载中间件。 路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。路由句柄 可以为请求处理提供多个回调函数，其行为类似 中间件。唯一的区别是这些回调函数有可能调用 next(‘route’) 方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。 响应方法响应方法 可使用 app.route() 创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。 可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统，因此常称其为一个 “mini-app”。 中间件依旧是官网的解释在get和post回调函数中，如果没有next参数，那么就 匹配第一个路由，不会继续往下匹配。应用级中间件应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()app.use()的网址不是精确匹配的。 路由级中间件和应用级中间件一样，只是它绑定的对象为 express.Router()。 错误处理中间件错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 内置中间件express.static(root, [options])]]></content>
      <tags>
        <tag>前端</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js入门(2)]]></title>
    <url>%2F2017%2F12%2F07%2Fnode-js%E5%85%A5%E9%97%A8-2%2F</url>
    <content type="text"><![CDATA[node.js中模块的概念前端开发中中js和js文件之间不能相互关联，但是在nodejs中exports和require可以将他们相互关联起来。 概念 狭义的说，每一个JavaScript文件都是一个模块；而多个JavaScript文件之间可以相互require，他们共同实现了一个功能，他们整体对外，又称为一个广义上的模块。Node.js中，一个JavaScript文件中定义的变量、函数，都只在这个文件内部有效。当需要从模块外部引用这些变量、函数时，必须使用exports对象进行暴露。使用者要用require()命令引用这个JS文件。一个JavaScript文件，可以向外exports无数个变量、函数。但是require的时候，仅仅需要require这个JS文件一次。使用的它保罗的变量、函数的时候，用点语法即可。所以，无形之中，增加了一个顶层命名空间。js文件和js文件之间有两种合作的模式：1） 某一个js文件中，提供了函数，供别人使用。 只需要暴露函数就行了； exports.msg=msg;2） 某一个js文件，描述了一个类。 module.exports = People; 123456789101112131415161718192021./text/people.jsfunction people(name, sex, age) &#123; this.name = name; this.sex = sex; this.age = age;&#125;people.prototype = &#123; sayHello: function () &#123; console.log(this.name + this.sex + this.age); &#125;&#125;module.exports = people;js.jsvar people = require(&quot;./text/people.js&quot;);var xiaoming = new people(&quot;小明&quot;,&quot;男&quot;,&quot;18&quot;);xiaoming.sayHello(); 如果在require命令中，这么写:1var foo = require(“foo.js”); //没有写./， 所以不是一个相对路径。是一个特殊的路径那么Node.js将该文件视为node_modules目录下的一个文件 我们可以使用文件夹来管理模块，比如1var bar = require(“bar”);那么Node.js将会去寻找node_modules目录下的bar文件夹中的index.js去执行。 每一个模块文件夹中，推荐都写一个package.json文件，这个文件的名字不能改。node将自动读取里面的配置。有一个main项，就是入口文件： 123451&#123;2 &quot;name&quot;: &quot;kaoladebar&quot;,3 &quot;version&quot;: &quot;1.0.1&quot;,4 &quot;main&quot; : &quot;app.js&quot;5&#125; package.json文件，要放到模块文件夹的根目录去。 require()中的路径，是从当前这个js文件出发，找到别人。而fs是从命令提示符找到别人。 post请求 node.js追求一种极致，它认为post请求数据量会很大，所以会将数据拆分成很对小数据块chunk,然后通过特定的时间，将小数据块一个个传回来。 原生写POST处理，比较复杂，要写两个监听。文件上传业务比较难写。所以，用第三方模块。formidable。formidable是一个强大的封装模块，可以帮助实现文件上传的功能。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js入门(1)]]></title>
    <url>%2F2017%2F12%2F06%2Fnode-js%E5%85%A5%E9%97%A8-1%2F</url>
    <content type="text"><![CDATA[之前只用过nodejs的npm工具，现在打算来深入了解一下个人感觉入门的话，有点无从学起，官方文档看的一脸懵，比较片面的博客教程拿来入门的话也不太够，我看的是邵山欢老师的视频，一个蛮可爱的老师，讲的也很好懂。视频资源 链接：https://pan.baidu.com/s/1qXTQ7BA 密码：xjqi nodejs用javascript编程，运行在Chrome的V8内核上。它没有服务器这个部分， nodejs的特点： 单线程：单线程可以让所有用户共用一个线程，节省服务器内存。但是可以实现宏观上的多线程。而且避免了操作系统多次创建，销毁进程的开销。弊端就是，一旦线程崩溃，那么服务器就无法访问。非阻塞IO：nodejs运用了非阻塞IO，传统单线程采用的阻塞IO，极大降低了程序效率。http://qindongliang.iteye.com/blog/2018539事件驱动：用事件驱动来完成服务器的调度 因此，nodejs 比较适合需要大量IO处理的情况，而不适合需要大量计算的情况。适合做长连接的，比如跟WebSockets配合做长连接的实时交流的应用 node.js其实是比较像一个虚拟机的，它也是跨平台的。它的程序运行在服务器端，然后将计算结构返回到客户端。如果想修改程序，必须要先中断当前运行的服务器，改动后，重新node，运行服务器 Ctrl+C 就可以打断挂起的服务程序，此时按上箭头，能够快速调用最近的node命令简化来想，nodejs 就相当于一个js执行环境. node.js没有根目录的概念，它没有web容器。在启动之后，无法直接根据相应的文件路径文件名进入到相应的页面。但是它可以通过读取文件，这样一个路由设计，实现比较方便的读取页面之类的工作。 1234fs.readFile(&apos;/etc/passwd&apos;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;); ###http模块###node.js中将很多功能划分为一个个的muddule,即模块。 12345678910//引用模块var http = require(&quot;http&quot;);//创建一个服务器，回调函数表示接收到请求之后做的事情var server = http.createServer(function(req, res) &#123; console.log(&quot;服务器接受到了请求&quot; + req.url); res.end();//这个方法在回调函数中是必须的，否则浏览器会一直处于等待状态&#125;); server.listen(3000, &quot;localhost&quot;); 下面是一个将helloWord呈现到页面的一段代码，算是一个完整的请求过程 123456http = require(&quot;http&quot;);http.createServer( function(req, res) &#123; res.writeHead(200, &#123;&quot;Content-type&quot;:&quot;text/html;charset=UTF-8&quot;&#125;); res.end(&quot;&lt;h1&gt;hello world&lt;/h1&gt;&quot;);&#125;).listen(3000, &quot;localhost&quot;); node.js中一个要点就是用户请求url，所有的路由设计，都是通过req.url来完成的。由于node.js中与众不同的路由机制，我们更侧重于关心如何识别url而不是拿到url 要识别url，用到两个新的模块，一个是url模块，另一个就是querystring（查询字符串） 事件轮询机制自己尝试把之前写的前端的demo挂在node.js上运行，结果只能运行HTML页面，相应的css和js页面加载不上来，报错 get不到~~原因应该是之前提到的，nodejs没有web容器所以要用到url和path这个API了]]></content>
      <tags>
        <tag>前端</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe]]></title>
    <url>%2F2017%2F12%2F06%2Fiframe%2F</url>
    <content type="text"><![CDATA[哒哒哒~我要来了解一下这个不知道是什么东西的东西了iframe iframe 元素会创建包含另外一个文档的内联框架（即行内框架） 1234&lt;iframe width=420 height=330 frameborder=0 scrolling=auto src=URL&gt;&lt;/iframe&gt;scrolling表示是否显示页面滚动条，可选的参数为auto、yes、no，如果省略这个参数，则默认为auto。注意：URL建议用绝对路径 文档没看明白，可能是没有怎么应用的原因，也可能是我现在好困精神没法集中。 知乎上大佬关于iframe的讨论https://www.zhihu.com/question/20653055先这样吧]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js模板引擎]]></title>
    <url>%2F2017%2F12%2F02%2Fjs%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[其实我对js模板引擎一点都不了解，昨天听一个前端小哥的建议，决定稍微了解一下~ 哒哒哒 又要开始学习新技能了呢 juicer （淘宝）是一个高效、轻量的前端 (Javascript) 模板引擎，效率和易用是它追求的目标。 除此之外，它还可以运行在 Node.js 环境中。 artTemplate（腾讯） BaiduTemplate（百度）]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局]]></title>
    <url>%2F2017%2F12%2F01%2F%E8%B4%9F%E8%BE%B9%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[normal flow、containing block、bfc、margin collapse、 Negative margin position absolute生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位。fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。relative 生成相对定位的元素，相对于其正常位置进行定位。inherit 规定应该从父元素继承 position 属性的值。 float 属性定义元素在哪个方向浮动。以往这个属性总应用于图像，使文本围绕在图像周围，不过在 CSS中，任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。如果浮动非替换元素，则要指定一个明确的宽度；否则，它们会尽可能地窄。 外边距合并指的是，当两个元素都没有边框属性和内边距属性，，他们的外边距想接触时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 当一个元素出现在另一个元素上面时，第一个元素的下外边距与第二个元素的上外边距会发生合并。当一个元素包含在另一个元素中时（假设没有内边距或边框把外边距分隔开），它们的上和/或下外边距也会发生合并。假设有一个空元素，它有外边距，但是没有边框或填充。在这种情况下，上外边距与下外边距就碰到了一起，它们会发生合并.如果这个外边距遇到另一个元素的外边距，它还会发生合并 负边距当margin-top、margin-left为负值的时候，会把元素上移、左移，同时文档流中的位置也发生相应变化,这点与position:relative的元素设置top、left后元素还占据原来位置不同当margin-bottom、margin-right设为负值的时候，元素本身没有位置变化，后面的元素会下移、右移 BFC(块级格式化上下文)就是用来格式化块级盒子，同样管理inline类型的盒子还有IFC http://www.cnblogs.com/dojo-lzz/p/3999013.html#undefined我是真的没有懂···]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圣杯布局和双飞翼布局]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[写过几次圣杯布局和双飞翼布局，但是老是忘记，还是自己总结一篇博客来梳理一遍~圣杯布局其实和双飞翼布局是一回事。它们实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应，它们实现的效果是一样的，差别在于其实现的思想。 圣杯布局： 首先写这样三个div` main left right ` 注意要优先渲染中间栏，所以要写在最上面。并且要设置自适应width：100%; 给出每个盒子的样式，都设置左浮动。 ; 这时候就要使用负边距了。 #main{ background:red; height:100px; width:100%; float:left; } #left{ width:100px; height:100px; margin-left:-100%; background:yellow; float:left; } #right{ width:100px; height:100px; background:grey; float:left; margin-left:-100px; } 但是现在中间栏的内容会被左右两个div遮挡，所以 在最外层边框设置内边距，然后将左右两个盒子position：relative; 然后再设置定位~~ #main{ background:red; height:100px; width:100%; float:left; } #left{ width:100px; height:100px; margin-left:-100%; background:yellow; float:left; position:relative; left:-100px; } #right{ width:100px; height:100px; background:grey; float:left; margin-left:-100px; position:relative; left:100px; } #container{ padding: 0 100px; }; 双飞翼布局：不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。 main left right #mini{ margin-left:100px; margin-right:100px; }顺便，就看看负边距的内容]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[数据结构的基本考点，给自己做备忘，老是学了忘忘了学有一个很不错的网站，可以演示各种数据结构运行的过程https://www.cs.usfca.edu/~galles/visualization/Algorithms.html 1.链表的倒数第K个查找 12345678910111213141516171819202122void search(LinkList &amp;L, ElemType k)&#123; LNode *p,*q; p = L-&gt;next; q = L-&gt;next; int count = 0; while(p != nill)&#123; if(count &lt; k)&#123; count++; &#125; else&#123; q = q-&gt;next; &#125; p = p-&gt;next; &#125; if(count &lt; k) return 0; else&#123; print(p-&gt;data); return 1 &#125; &#125;&#125; 2.手写遍历算法 递归先序遍历 1234567void preOrder(BiTree T)&#123; if(T != null)&#123; visit(T); preOrder(T-&gt;lchild); preOrder(T-&gt;rchild); &#125;&#125; 非递归先序遍历 12345678910111213141516void preOrder(BiTree T)&#123; InitStack(S); BiTree p = T; while(p||isEmpty(s)) &#123; if(p)&#123; push(S, p); visit(p); p = p-&gt;lchild; &#125; else&#123; pop(S, p); p = p-&gt;rchild; &#125; &#125;&#125; 层次遍历 12345678910111213void levelOrder(BiTree T)&#123; InitQueue(Q); BiTree q = T; EnQueue(q); while(!isEmpty(Q))&#123; DeQueue(Q,q); visit(q); if(q-&gt;lchild != null) EnQueue(Q, q-&gt;lchild); if(q-&gt;rchild != null) EnQueue(Q, q-&gt;rchild); &#125;&#125; 3.字符串匹配算法 普通匹配 kmp算法4.逆波兰表达式中缀表达式转成后缀表达式（如（a+b）*（c+d）转换为 ab+cd+*）转换规则：当前字符为变量或者数字，则存入后缀表达式；如果是运算符op,op比操作符栈顶优先级高则压入，否则将栈中操作符不断弹出，直到op的优先级高于栈顶。 5.二叉搜索树它或者是一棵空树；或者是具有下列性质的二叉树：若左子树不空，则左子树上所有结点的值均小于它的根结点的值；若右子树不空，则右子树上所有结点的值均大于它的根结点的值；左、右子树也分别为二叉排序树。若子树为空，查找不成功。可以显著的改进查找的效率，查找一个数据的了路径最长不超过树的深度。 1234567//递归实现 Tree_Search(x, k): if x == NIL or x.key == k : return x if k &lt; x.key return Tree_Search(x.left, k) else return Tree_Search(x.right, k) 6.平衡二叉搜索树（红黑树）就是若一棵二叉树的每个左右节点的高度差最多相差1，此二叉树即是平衡二叉树。把二叉树的每个节点的左子树减去右子树定义为该节点的平衡因子。二叉平衡树的平衡因子只能是1、0或者-1。在二叉搜索树的插入和删除运算中，采用平衡树的优点是：使树的结构较好，从而提高查找运算的速度。缺点是：是插入和删除运算变得复杂化，从而降低了他们的运算速度。 7.散列 散列函数 平方取中法 除留余数法 折叠法 数字分析法 解决冲突 开放定址法 拉链法 7.排序算法 插入排序 直接插入排序 折半插入排序 希尔排序 交换排序 起泡排序 快速排序 选择排序 直接选择排序 堆排序 竞标赛排序 归并排序 归并 迭代归并 基数排序]]></content>
      <tags>
        <tag>面试</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2017%2F11%2F29%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[数据库增删改查 增 insert into &lt;表名&gt; (列名) values (列值) 删 delete from &lt;表名&gt; where 删除条件 改 update &lt;表名&gt; set &lt;列名=更新值&gt; [where &lt;更新条件&gt;] 查 select &lt;列名&gt; from &lt;表名&gt; [where &lt;查询条件表达试&gt;] [order by &lt;排序的列名&gt;[asc或desc]] 外联结left outer join on 左联结A、B表的意思就是将表A中的全部记录和表B中联结的字段与表A的联结字段符合联结条件的那些记录形成的记录集的联结，这里注意的是最后出来的记录集会包括表A的全部记录。right outer join on 三级加锁协议一级封锁协议:事务T在修改数据R之前必须对其加X锁，直到事务结束才释放。以及封锁协议可以防止修改丢失，并保证事务T是可恢复的。在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。 二级封锁协议是:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。二级封锁协议除防止丢失修改，还可进一步防止读“脏”数据。在二级封锁协议中，由于读完数据即可释放S锁，所以它不能保证可重复读。 三级封锁协议:一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。三级封锁协议可以防止丢失修改，读“脏”数据和不可重复读。 sql执行顺序及优化 http://m.blog.csdn.net/u010379807/article/details/10741805 mysql的四个事务隔离级别http://www.jb51.net/article/96179.htm 事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。 1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 索引类型以及原理http://blog.csdn.net/lqadam/article/details/78572365 mysql的各个引擎http://blog.csdn.net/hxwjd110/article/details/52685551 数据库三大范式http://blog.csdn.net/w__yi/article/details/19934319]]></content>
      <tags>
        <tag>面试</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络]]></title>
    <url>%2F2017%2F11%2F29%2F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[以下是我整理的作为一个前端，面试常考的网络部分的内容，方便自己查看，也当做一个知识储备。 1.OSI七层协议 物理层（中继器、集线器） 数据链路层（网桥、交换机、PPP、MAC） 网络层（路由器、IP、ICMP、ARP、RARP、） 传输层（TCP、UDP） 会话层 表示层 应用层（FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS） 2.各种协议的意义和功能 ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术， DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用UDP协议工作。具体用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。 3.TCP和UDP的区别 TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。 TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。 TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 TCP对应的协议： FTP：定义了文件传输协议，使用21端口。 Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。 HTTP：是从Web服务器传输超文本到本地浏览器的传送协议 UDP对应的协议： DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 4.三次握手和四次挥手过程分析 1.三次握手 客户端发送syn包到服务器，并进入syn-send状态，等待服务器确认 seq=1 服务器收到syn包，必须确认客户的SYN（ack=x+1）同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 客户端收到服务器发送的syn+ack包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 2.四次挥手 主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，但是，此时主动关闭方还可 以接受数据。 被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 5.HTTP协议和HTTPS协议的区别 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 6.请求报文和响应报文 请求报文（请求行、首部行、实体主体） 请求行：方法 url 版本 CRLF 首部行：请求头部通知服务器有关于客户端请求的信息，典型的请求头有：User-Agent：产生请求的浏览器类型。 Accept：客户端可识别的内容类型列表。Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机。 实体主体 2.响应报文（状态行、消息报头、响应正文） 状态行：版本 状态码 短语 CRLF 消息报头 响应正文 7.get 和 post 的区别 GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变 GET提交时，传输数据就会受到URL长度的限制。 POST:由于不是通过URL传值，理论上数据不受限 POST的安全性要比GET的安全性高。 8.浏览器输入一个请求到页面相应的过程 1、客户端浏览器通过DNS解析到www.baidu.com 的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.181.27.48，然后通过TCP进行封装数据包，输入到网络层。2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 9.IP地址与子网掩码相与得到网络号： ip : 192.168.2.110&amp;Submask : 255.255.255.0网络号 ：192.168.2 .0主机号全为0的是网络号（例如：192.168.2.0），主机号全为1的为广播地址（192.168.2.255） 10.ARP地址解析协议 1.首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。2.当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。3.当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。4.源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。 11.RARP逆地址解析协议 RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。 12.TCP流量控制和拥塞控制流量控制和拥塞控制的针对对象不同流量控制是TCP连接的两端通过协商窗口值来控制，是网络中两个链接的点对点通信的对象，拥塞控制是是控制数据流量过多导致网络拥塞，控制的对象是整个网络的通信，拥塞控制的算法为：即慢开始（Slow-start)，拥塞避免（Congestion Avoidance)快重传（Fast Restrangsmit)和快回复（Fast Recovery）接收端窗口（Reciver Window)又称通知窗口（Advertised Window),是接收端根据目前的接收缓存大小所许诺的最新窗口值，是来自接收端的流量控制。拥塞窗口cwnd（Congestion Window)是发送端根据自己估计的网络拥塞程度而设置的窗口值，是来自发送端的流量控制。 13.cookie和session的区别 两者都可以用来跟踪和保存客户端的状态信息 Cookie是在服务器端创建,在客户端保存， session是在服务器端创建,在服务端保存 Cookie中只能存放String类型,而session中可以存放Object类型。 session是依赖于Cookie的,sessionid还是存放在Cookie中并保存在客户端的浏览器中 14.TCP粘包和拆包出现粘包跟拆包的根本原因大于服务器每次接收的字节数是不确定的粘包/拆包的解决之道消息定长，如固定协议包长度是100字节，如果不够，包尾空格补位；包尾增加换行符或者其它符号进行分割，如FTP协议；将消息分为消息头和消息体，在消息头固定的位置增加一个字段，表示消息的总长度(或消息的长度)，参照TCP协议；使用更复杂的应用层协议； 15.tcp/ip协议和http协议 关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍： “我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容.” http://blog.csdn.net/Pk_zsq/article/details/6087367]]></content>
      <tags>
        <tag>面试</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令行]]></title>
    <url>%2F2017%2F11%2F29%2Flinux%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[ctrl+C 让当前的程序停掉Ctrl+D 可以取代exittab 命令补齐 man 通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息。chgrp 改变文件的所属群组chown 改变文件拥有者chmod 改变文件权限cd 变换目录pwd 显示当前所在目录mkdir 建立新目录rmdir 删除空目录ls 档案与目录的显示gzip，zcat 压缩文件和读取压缩文件]]></content>
      <tags>
        <tag>面试</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js中的操作符问题]]></title>
    <url>%2F2017%2F11%2F26%2Fjs%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天群里的小伙伴讨论了一个问题var x = 5; if(x += 1 &amp;&amp; x++) console.log(x)//10反正我开始看到这个是一脸懵逼的 这个问题涉及到了一个基本上都会被忽略掉的操作符优先级问题和一些js中的操作符问题 首先，运算符优先级！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符接下来，系统的回顾一下js操作符吧+ 会将各种类型自动转换成number类型~ 按位非AND 按位与OR 按位或XOR 按位异或&lt;&lt; 左移&gt;&gt; 有符号的右移 符号位不动 以符号位填充空位&gt;&gt;&gt; 无符号的右移 符号位不动 以0填充空位 ###布尔操作符### 逻辑非 逻辑非操作符由一个叹号表示(!),可以应用于ECMAScript中的任何值。无论这个值是什么数据类型，这个操作符都会返回一个布尔值。 逻辑与 逻辑与属于短路操作，即如果第一个操作数求值结果是false，那么就不会对第二个操作数求值。其中一个值不是布尔值时：遵循下列规则 第一个操作数为假，返回第一个； 第一个操作数为真的时候，返回第二个。 如果第一个操作数是对象，则返回第二个操作数 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象 如果两个操作数都是对象，则返回第二操作数 （1）如果有一个操作数是null，则返回null （2）如果有一个操作数是NaN,则返回NaN （3）如果有一个操作数是undefined，则返回undefinded 逻辑或 逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。（1）第一个操作数为真，返回第一个（2）第一个操作数为假，返回第二个 ###关系操作符###如果两个操作数都是数值，则执行数值比较如果两个操作数都是字符串，则比较两个字符串对应的字符编码值如果一个操作数是数值，则将另一个操作数转换为数值，然后执行数值比较 ###相等操作符###1.相等和不相等先转换再比较（1）如果有一个操作数是布尔值，则在比较相等性之前，先将其转换为数值（2）如果有一个操作数是字符串，另一个操作数是数值，先将其转换为数值（3）如果有一个操作数是对象，另一个不是，则调用对象的valueOf()方法，用得到的基本类型值按前面的基本规则进行比较null和undefined是相等的要比较相等性之前不能将null和undefined转换为任何其他值如果两个操作数都是NaN，相等操作符也返回false，按规则，NaN不等于NaN2.全等和不全等仅比较而不转换 未经转换就相等则返回true]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6]]></title>
    <url>%2F2017%2F11%2F18%2Fes6%2F</url>
    <content type="text"><![CDATA[node.js对ES6的支持度较高，在这个环境下可以更好的体验Babel转码器参考最喜欢的作者阮一峰写的ES6入门参考淘宝前端团队 let和const命令 let命令只在所在的代码块内有效 不存在变量提升，使用一定要在声明之后 暂时性死区 如果区块内存在const或者let这个区块对命令声明的变量形成封闭作用域，不受作用域之外的变量影响 var temp = “123”； if(true){temp=”abc”； let temp；}//报错虽然在代码块中声明了全局变量temp，但是在判断区块内无效，let声明的temp变量在声明前调用，所以报错 在相同的作用域内不能重复声明同一个变量 块级作用域外部无法访问内部函数和变量（引入闭包）const 的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性。所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以const做定义。反之就 let 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。猜想：就执行效率而言，const 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。所以上面代码中，所有使用 let 的部分，其实都应该是用 const 的。 变量的解构赋值数组的解构赋值: 模式匹配。如果结构不成功，变量值为undefined 不完全解构只匹配等号右边一部分，如果右边不是数组就会报错实际上，只要某种数据结构具有iterator接口，都可以采用数组形式的解构赋值。 对象的结构赋值：区别（数组的变量取值是由位置决定的，对象的属性没有次序，变量必须与属性同名才行，如果变量名与属性名不一致，则 var{foo:baz}={foo:”aaa”};baz//aaa 解构赋值允许使用默认值，但数组成员不严格等于undefined的话则默认值不生效字符串解构和数值布尔型解构赋值，会首先转换成对象解构赋值中应该尽量避免圆括号，否则可能导致解构歧义，赋值语句的非模式部分可以使用圆括号主要用途： 变换变量的值 从函数返回多个值 函数参数的定义 提起json数据 函数参数的默认值 遍历map解构 输入模块的指定方法 symbol是ES6引入的新的数据类型，表示独一无二的值symbol有symbol函数生成 let s = new symbol();可以接受一个参数，表示对symbol实例的描述symbol不能与其他类型进行运算，但是可以转换成布尔值 作为属性名的symbol：1不能使用点运算符，必须放在方括号中，否则会被解析成一个字符串2作为属性上symbol是公有属性 魔术字符串（没弄懂） Object.getOwnPropertySymbol方法可以获取指定对象的所有symbol属性名新的api reflect.ownkeys方法可以返回所有类型的键名 symbol.for() 接受一个字符串作为参数，搜索有没有以该参数作为名称的symbol值，有则返回，没有就新建一个以该字符串为名称的symbol值 Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。 Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 Set和Map数据结构 Set 它类似于数组，但是成员的值都是唯一的，没有重复的值。内部查重的机制相它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 属性：Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 操作方法：add(value) delete(value) has(value) clear() Array.from方法可以将 Set 结构转为数组。 遍历操作：keys() values() entries() forEach() Set的遍历顺序就是插入顺序。Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。这意味着，可以省略values方法，直接用for…of循环遍历 Set。扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。数组的map和filter方法也可以间接用于 Set 了。因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 WeakSet结构与 Set 类似，也是不重复的值的集合。但是：WeakSet 的成员只能是对象，而不能是其他类型的值。WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，所以用它保存某些数据可以避免内存泄漏 map JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。Map 数据结构类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。实际上是跟内存地址绑定的，只要内存地址不一样就视为两个键，如果map的键是简单类型的值如数字、字符串、布尔值，只要严格相等就视为一个键，NaN在这里可以相等 属性：size 方法：set(key,value) get(key) has(key) clear() 遍历方法：keys() values() entries() forEach() Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。 将数组传入 Map 构造函数，就可以转为 Map。 结合数组的map方法、filter方法，可以实现 Map 的遍历和过滤（Map 本身没有map和filter方法）。 forEach方法还可以接受第二个参数，用来绑定this。 WeakMap结构与Map结构类似，也是用于生成键值对的集合。WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。WeakMap的键名所指向的对象，不计入垃圾回收机制。 ###箭头函数###箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。箭头函数不但没有独立 this，他也没有独立的 arguments，所以如果需要取不定参的时候，要么使用 function，要么用 ES6 的另一个新特性 rest（具体在 rest 中会有详解）。箭头函数语法很灵活，在只有一个参数或者只有一句表达式做方法体时，可以省略相应括号。 ###promise###promise对象代表一个异步操作，有三种状态：pending resolved/fullfilled rejected promise.then接收两个方法作为参数，第一个resolved调用，第二个reject调用。 1promise.then(function(value),funtion(error)); 但是这种写法不太好，有点类似于同步中的try/catch下面的写法比较好。 12promise.then()//成功 .catch()//失败 promise对象的错误会一直向后传递，直到被捕获。done()方法处于回调链的尾端，保证捕捉最后一个方法抛的错误。还有一个附加的API finally() 用于指定无论promise对象状态如何都会执行的操作。Node.js有一个unhandledRejection事件专门监听未捕获的rejected错误 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用Promise.all（）用于将多个promise实例包装成一个新的promise实例。 1234567891011Promise .all([jsBuildPromise, cssBuildPromise])//all内的实例均为reject时promise状态为reject，其中一个为resolved师promise的状态就是resolve .then(() =&gt; &#123; ... &#125;);jsBuildPromise .then(() =&gt; cssBuildPromise) .then(() =&gt; &#123; ... &#125;); Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行 Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行new Promise(() =&gt; {f; // not define error !}).catch((err) =&gt; {console.log(err) // show ‘f is not define’});console.log(‘error test’); // 此行可以被正常执行 promise.race()与all()的作用一样，不同的是它的promise状态只要参数的任意一个改变就会随之改变promise.resolve（）将现有对象转换为promise对象promise.reject（）返回状态为rejected的新实例。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2017%2F11%2F18%2Fwebpack%2F</url>
    <content type="text"><![CDATA[菜鸟教程中文官方文档慕课网视频教程 webpack是将js文件进行打包的工具webpack 根据模块的依赖关系进行静态分析，这些文件(模块)会被包含到 bundle.js 文件中。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 配置文件:我们可以将一些编译选项放在配置文件中，以便于统一管理。插件：在 webpack 的配置信息 plugins 选项中指定，用于完成一些 loader 不能完成的工。webpack 自带一些插件，你可以通过 cnpm 安装一些插件。‘cnpm install webpack –save-dev’开发环境当项目逐渐变大，webpack 的编译时间会变长，可以通过参数让编译的输出内容带有进度和颜色。‘webpack –progress –colors’如果不想每次修改模块后都重新编译，那么可以启动监听模式。开启监听模式后，没有变化的模块会在编译后缓存到内存中，而不会每次都被重新编译，所以监听模式的整体速度是很快的。‘webpack –progress –colors –watch’当然，我们可以使用 webpack-dev-server 开发服务，这样我们就能通过 localhost:8080 启动一个 express 静态资源 web 服务器，并且会以监听模式自动运行 webpack，在浏览器打开 http://localhost:8080/ 或 http://localhost:8080/webpack-dev-server/ 可以浏览项目中的页面和编译后的资源输出，并且通过一个 socket.io 服务实时监听它们的变化并自动刷新页面。安装 ‘cnpm install webpack-dev-server -g’运行 ‘webpack-dev-server –progress –colors’(利用webpack实现热响应？？) webpack核心概念 entry单个入口对象入口（多个） output filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 将filename 输出到path的路径中 如果有多个入口起点则应该使用占位符来确保每个文件具有唯一的名称。 loader 使用 Loader：在你的应用程序中，有三种使用 loader 的方式：配置（推荐）：在 webpack.config.js 文件中指定 loader。 内联：在每个 import 语句中显式指定 loader。 CLI：在 shell 命令中指定它们。 plugins 插件目的在于解决 loader 无法实现的其他事。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5(表单)]]></title>
    <url>%2F2017%2F11%2F16%2FHTML5-%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[新增表单元素与属性： form属性 可以书写在页面中的任何部分，然后为该元素指定一个form属性，属性值为该表单的id，这样就可以声明该元素从属于指定表单 id123 &lt;input type = &quot;text&quot;&gt; &lt;/form&gt;&lt;textarea form=&quot;textform&quot;&gt;&lt;/textarea&gt; formaction元素 formmethod元素 formtarget元素 HTML4中只能通过form的属性提交表单，在html5中每个都可以单独设置 action123456 &lt;input type=&quot;submit&quot; name=&quot;s1&quot; value=&quot;s1&quot; formaction=&quot;s1.jsp&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;s2&quot; value=&quot;s2&quot; formaction=&quot;s2.jsp&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;post方式提交&quot; formmethod=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;get方式提交&quot; formmethod=&quot;get&quot;&gt;&lt;/form&gt; autofocus属性 页面打开时自动获得光标焦点，一个页面最多只能设置一个,通过js实现 required属性 提交时如果元素中内容为空，则不允许提交，同时显示提示文字 labels属性 control属性 placeholder属性 表单处于未输入状态时显示的内容 list属性 datalist属性 autocomplete属性 type 12345&lt;datalist id=&quot;greeting&quot; style=&quot;display:none;&quot;&gt; &lt;option value=&quot;123&quot;&gt;123&lt;/option&gt; &lt;option value=&quot;234&quot;&gt;234&lt;/option&gt; &lt;option value=&quot;345&quot;&gt;345&lt;/option&gt;&lt;/datalist&gt; pattern属性 可以进行输入值的正则检查 image提交按钮的height和width属性 textarea元素的maxlength和wrap属性 改良的input元素，部分实现了只有js才能实现的功能search url tel email number range与text外观一样，但是仅能输入特定的内容date month week time datetime-local 目前只有Chrome10和Opera10以上版本的浏览器支持color用于选择颜色以上的属性大多数浏览器都不支持，还是要用js实现 增强的页面元素 figure和figcaption元素 details和summary元素 Mark元素 meter元素 dialog元素]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSockets]]></title>
    <url>%2F2017%2F11%2F16%2FWebSockets%2F</url>
    <content type="text"><![CDATA[实现了用http不容易实现的服务器端与客户端之间进行的非http的通信机制,建立一个非http的双向连接（全双工通信），这个连接是实时的永久的，除非被显式关闭。这意味着当服务器想向客户端发送消息时，可以立即将消息推送到客户端的浏览器，无需重新建立连接。比如用来实现聊天室，实时的接收传递消息。 使用WebSockets API(算了api还是要用的时候查吧 太容易忘记了) 123456789101112var ws = new WebSocket(wss://);ws.onopen() = function(e) &#123; console.log(&quot;连接建立，可以开始发消息啦&quot;); ws.send();&#125;;ws.onmessage() = function(e) &#123; ws.onclose();&#125;ws.onclose = function(e) &#123; console.log(&quot;大家注意了，连接关了啊&quot;);&#125; readyState的属性值获取WebSocket对象的状态connecting 0 表示正在连接open 1 表示已经建立连接closing 2 表示正在关闭连接closed 3 表示连接已经关闭 WebSocket和http协议有区别也有联系。首先http协议中请求和响应是成对存在严格对应的，在http1.1中的keep-alive实现可将多个http请求合并成一个，但是它和WebSocket还是不一样，它依然是请求和响应一一对应的。WebSocket是一个新的协议，借助于http协议完成握手。WebSocket的连接请求跟http请求相似，但是多出了这么两行upgrade:wesocket connection:upgrade这两行告诉服务器，我是一个WebSocket协议。 传统的技术当然也可以实现信息的即时发送和获取，依赖于ajax轮询和long poll。 轮询，顾名思义就是隔一会查看一下是否有新的消息,需要服务器有很快的处理速度。 long poll 就是相当于发起请求后没收到消息就赖着不走了这么个样子。需要有很高的并发。 当然以上两种对我来说都是停留在了理论层面，我并没有真正去实践过。有错误的地方，日后改正。]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5(canvas)]]></title>
    <url>%2F2017%2F11%2F15%2Fhtml5-canvas%2F</url>
    <content type="text"><![CDATA[参考：HTML5与CSS3权威指南或者W3Cschool 菜鸟教程之类的 都有详细的用法 canvas相当于设置了一块透明画布 用canvas绘制图形的步骤： > 获取canvas元素 > 取得图形上下文 > 填充(fill)与绘制边框(stroke) > 设定绘图样式 > 指定线宽 > 指定颜色值 > 绘制图形 function draw(id){ var canvas = document.getElementById(id); if(canvas == null) return false; var context = canvas.getContext('2d'); context.fillStyle = "#999999"; context.fillRect(0,0,400,400); context.fillStyle = "red"; context.strokeStyle = "blue"; context.lineWidth = 1; context.fillRect(50,50,100,100); context.strokeRect(50,50,100,100); } 用canvas绘制圆形的步骤： 获取canvas元素 取得图形上下文 开始创建路径 创建图形的路径context.arc(x,y,radius,startAngle,endAngle,anticlockwise) 关闭路径 设定绘制样式，调用绘制方法，绘制路径 function draw(id){ var canvas = document.getElementById(id); if(canvas == null) return false; var context = canvas.getContext('2d'); context.fillStyle = "#999999"; context.fillRect(0,0,400,400); context.beginPath(); context.arc(200,200,150,0,Math.PI*2,true); context.closePath(); context.fillStyle=’rgba(255,255,255,0.7)’; context.fill();} 绘制直线 moveTo 将光标移动到指定坐标点 该坐标点设置为起点 lineTo 表示直线终点 lineCap butt默认不添加线帽 round添加圆形线帽 square添加正方形线帽 绘制曲线： arcTo(x1,y1,x2,y2,radiusX[,radiusY,rotation])[]中的内容是可以不写的 贝塞尔曲线 bezierCurveTo（cp1x,cp1y,cp2x,cp2y,x,y) 用path2D对象绘制路径：（支持chorme37、Firefox31、Opera23、Safari7及以上版本）： path.moveTo(x,y) 将光标移动到指定坐标点 path.lineTo(x,y) 绘制直线 path.rect(x,y,w,h) 绘制矩形 path.arc(x,y,radius,startAngle,endAngle,anticlockwise)绘制圆形或圆弧 path.ellipse(x,y,radiusx,radiuy,rotation,startAngel,endAngel)绘制椭圆或者椭圆弧 Canvas - 文本使用 canvas 绘制文本，重要的属性和方法如下：font - 定义字体fillText(text,x,y) - 在 canvas 上绘制实心的文本strokeText(text,x,y) - 在 canvas 上绘制空心的文本 createLinearGradient(x,y,x1,y1) - 创建线条渐变createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变当我们使用渐变对象，必须使用两种或两种以上的停止颜色。addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1. drawImage(image,x,y) canvas.save() canvas.restore() 作用是两个相互匹配出现的，作用是用来保存画布的状态和取出保存的状态的。rotate() 旋转transplate() 平移 用canvas绘制一个可以展现实时时间的时钟 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;画时钟&lt;/title&gt; &lt;/head&gt; &lt;body onload=&quot;draw(&apos;canvas&apos;)&quot;&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400px&quot; height=&quot;400px&quot; border:&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; var dom=document.getElementById(&apos;canvas&apos;); var cxt=dom.getContext(&quot;2d&quot;); var width=cxt.canvas.width; var height=cxt.canvas.height; var r=width/2; function drawBackground(){ cxt.save(); cxt.translate(r,r); cxt.beginPath(); cxt.lineWidth=10; cxt.arc(0,0,r-5,0,2*Math.PI,false); cxt.stroke(); cxt.font=&quot;18px Arial&quot;; cxt.textAlign=&apos;center&apos; cxt.textBaseline=&apos;middle&apos; var hourNums=[3,4,5,6,7,8,9,10,11,12,1,2]; hourNums.forEach(function(number,i){ var rad=2*Math.PI/12*i; var x=Math.cos(rad)*(r-30); var y=Math.sin(rad)*(r-30); cxt.fillText(number,x,y); }); for(var i=0;i&lt;60;i++){ var rad=2*Math.PI/60*i; var x=Math.cos(rad)*(r-18); var y=Math.sin(rad)*(r-18); cxt.beginPath(); if(i % 5===0){ cxt.fillStyle=&quot;#000&quot; cxt.arc(x,y,2,0,2*Math.PI,false); } else{ cxt.fillStyle=&quot;#ccc&quot; cxt.arc(x,y,2,0,2*Math.PI,false); } cxt.fill(); } } function drawHour(hour,minute){ cxt.save(); cxt.beginPath(); var rad=2*Math.PI/12*hour; var mrad=2*Math.PI/12/60*minute cxt.rotate(rad+mrad); cxt.lineWidth=6; cxt.lineCap=&apos;round&apos; cxt.moveTo(0,10); cxt.lineTo(0,-r/2); cxt.stroke(); cxt.restore(); } function drawMinute(minute){ cxt.save(); cxt.beginPath(); var rad=2*Math.PI/60*minute; cxt.rotate(rad); cxt.lineWidth=3; cxt.lineCap=&apos;round&apos; cxt.moveTo(0,10); cxt.lineTo(0,-r+30); cxt.stroke(); cxt.restore(); } function drawSecond(second){ cxt.save(); cxt.beginPath(); cxt.fillStyle=&apos;#c14543&apos; var rad=2*Math.PI/60*second; cxt.rotate(rad); cxt.moveTo(-2,20); cxt.lineTo(2,20); cxt.lineTo(1,-r+18); cxt.lineTo(-1,-r+18); cxt.fill(); cxt.restore(); } function drawDot(){ cxt.beginPath(); cxt.fillStyle=&apos;#fff&apos; cxt.arc(0,0,3,0,2*Math.PI,false); cxt.fill(); } function draw(){ cxt.clearRect(0,0,width,height); var now=new Date(); var hour=now.getHours(); var minute=now.getMinutes(); var second=now.getSeconds(); drawBackground(); drawHour(hour,minute); drawMinute(minute); drawSecond(second); drawDot(); cxt.restore(); } draw(); setInterval(draw,1000); &lt;/script&gt; &lt;/html&gt;]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5（新增元素）]]></title>
    <url>%2F2017%2F11%2F15%2Fhtml5-%E6%96%B0%E5%A2%9E%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[html5要解决的问题： web浏览器之家的兼容性很低 文档结构不够明确 （语义化） web应用程序的功能受到了限制 HTML5中的DOCTYPE声明 ‘&lt;！DOCTYPE html&gt;’’ 新增的结构元素： section 表示页面中的内容区块，比如章节、页眉、页脚 article 表示与页面上下文无关的独立内容 aside 侧边栏 header 页面中一个内容区块或整个页面的标题 footer 整个页面或者页面中一个内容区块的脚注 nav 页面中导航链接的部分 替换ul figure 表示文档主体流内容中的一个独立单元 figcaption 为figure元素添加标题 替换dl main 网页中的主要内容 新增的其他元素: > vedio 用于定义视频 > audio 用于定义音频 > embed 用来插入各种多媒体 > mark 高亮显示 > progress 表示运行中的进程，可以用来显示js中耗费时间函数的进程 > time 用来表示日期或时间 > ruby 表示ruby注释 > canvas 表示图形，仅提供一个画布 > command 表示命令按钮 > details 细节 summary提供标题或图例 点击标题是可以展示细节内容 > datalist 表示可选数据的列表 datagrid 以树形列表显示 > Keygen 表示生成秘钥 > output 表示不同类型的输出 > menu 表示菜单列表 > source 为媒介元素定义媒介资源 新增input元素类型： email、url、number、range、Date（功能强大，但是很多浏览器不支持） 废除的元素： > 能使用css替代的元素 如center、font、big > 不再使用frame框架 > 只有部分浏览器支持的元素 如applet、blink、bgsound 新增的事件： > beforeprint 即将开始打印前触发 > afterprint 打印完毕后触发 > resize 窗口大小改变时触发 > error 页面出错是触发 > offline 离线是触发 > online 在线时触发 > pageshow 页面加载时触发 > beforeunload 页面被关闭时触发 > hashchange 页面url地址字符串中的hash部分发送改变时触发 > mousewheel > scroll > input 用户修改文本框中的内容时触发 > reset]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿淘宝商城前端开发]]></title>
    <url>%2F2017%2F11%2F14%2F%E4%BB%BF%E6%B7%98%E5%AE%9D%E5%95%86%E5%9F%8E%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[我遇到了一个很烦人的问题，就是font awesome的图标老是只显示一个框，没有内容。查了半天没改好，一怒之下换成了把下载下来本地引入的方法换成了在线引入，OK解决了。偷了个懒]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js学习笔记(1)]]></title>
    <url>%2F2017%2F11%2F13%2Fjs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%2F</url>
    <content type="text"><![CDATA[基本数据类型undefined、null、Boolean、number、string、objectasync和defer区别 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 ~~~&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt; 有 async，&lt;mark&gt;加载和渲染&lt;/mark&gt;后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 ~~~ &lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt; 有 defer，&lt;mark&gt;加载&lt;/mark&gt;后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的&lt;mark&gt;执行&lt;/mark&gt;要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 &lt;!-- more --&gt; **严格模式** 将&quot;use strict&quot;放在脚本文件的第一行，则整个脚本都将以&quot;严格模式&quot;运行。如果这行语句不在第一行，则无效，整个脚本以&quot;正常模式&quot;运行。 - 全局变量显式声明 - 禁止使用with语句 - 禁止创设eval作用域 - 禁止this关键字指向全局对象 - 禁止在函数内部遍历调用栈 - 严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除 - 对象不能有重名的属性、函数不能有重名的参数 - 禁止八进制表示法 - 不允许对arguments赋值、arguments不再追踪参数的变化、禁止使用arguments.callee - 函数必须声明在顶层 **typeof和instanceof** typeof的返回值类型有undefined、Boolean、string、number、object、function 对于未初始化的变量和没有定义的变量都会返回undefined null表示一个空对象指针 instanceof运算符可以用来判断某个构造函数的prototype属性是否存在于另外一个要检测对象的原型链上。 语法：object instanceof constructor 参数：object（要检测的对象.）constructor（某个构造函数） **JS全局函数** - decodeURI() 解码某个编码的 URI。 - decodeURIComponent() 解码一个编码的 URI 组件。 - encodeURI() 把字符串编码为 URI。 - encodeURIComponent() 把字符串编码为 URI 组件。 - escape() 对字符串进行编码。 - eval() 计算 JavaScript 字符串，并把它作为脚本代码来执行。 - isFinite() 检查某个值是否为有穷大的数。 - isNaN() 检查某个值是否是数字。 - Number() 把对象的值转换为数字。 - parseFloat() 解析一个字符串并返回一个浮点数。 - parseInt() 解析一个字符串并返回一个整数。默认解析成十进制数 - String() 把对象的值转换为字符串。 - unescape() 对由 escape() 编码的字符串进行解码。 **object类型的属性和方法** - Constructor:对创建对象的函数的引用（指针）。对于Object类，该指针指向原始的object()函数。 - Prototype:对该对象的对象原型的引用。对于所有的类，它默认返回Object对象的一个实例。 方法： - hasOwnProperty(property):判断对象是否有某个特定的属性。必须用字符串指定该属性（例如，o.hasOwnProperty(”name”)）。 - isPrototypeOf(object):判断该对象是否为另一个对象的原型。 - propertyIsEnumerable(property):判断给定的属性是否可以用for…in语句进行枚举。 - toString():返回对象的原始字符串表示。对于Object类，ECMA－262没有定义这个值，所以不同的ECMAScriipt实现具有不同的值。 - valueOf():返回最适合该对象的原值。对于许多类，该方法返回的值都与toString()的返回值相同。 **操作符** https://www.cnblogs.com/Peng2014/p/4707324.html 偷个懒，转载别人总结的博客 forin with 函数 return语句 参数 作用域 没有重载 声明提升]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头条项目]]></title>
    <url>%2F2017%2F11%2F12%2F%E5%A4%B4%E6%9D%A1%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[这个实战项目是一个不错的面试拿来讲的项目，牛客网购买的，如果有缘看到这个博客，喏，拿去好了 链接：http://pan.baidu.com/s/1nv86TVN 密码：pj06 该项目实现的功能：数据交互iBatis集成用户注册登录管理资讯发布 图像上传评论中心基于Redis点赞的功能异步设计 站内邮件多种资讯的排布算法 Spring boot注解@Controller定义Controller控制器，用它标记的类就是一个SpringMVC Controller对象用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。@RequestMapping来映射request请求与处理器（url到Controller）@RequestBody在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。@RequestParam绑定HttpServletRequest请求参数到控制器方法参数@CookieValue绑定cookie的值到Controller方法参数@RequestHeader绑定HttpServletRequest头信息到Controller方法参数附一位博主的总结 AOP 面向切面编程在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。一般而言，我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。 IOC 依赖注入 控制反转让调用类对某一接口实现类的依赖关系由第三方（容器或协作类）注入，以移除调用类对某一接口实现类的依赖。 velocity是一个java模板引擎，可以直接引用定义在java代码中的对象 基本语法 ‘ # ‘用来标识velocity的脚本语言 包括’ #set、#if 、#else、#end、#foreach、#end、#iinclude、#parse、#macro ‘等‘ $ ‘ 用来标识对象或者说变量‘ {} ‘ 用来明确标识velocity变量‘ ! ‘ 用来强制将不存在的变量显示为空白实践‘ $!obj ‘直接返回对象中的结果‘ #if($!obj) #else #end ‘判断语句‘ #foreach($info in $list) $info.someList #end ‘ 循环读取集合list中的对象，并做处理‘ #macro(macroName)#end ‘ 脚本函数(宏)调用，不推荐在界面模板中大量使用包含文件’ #inclue(“模板文件名”)或#parse(“模板文件名”) ‘ parse与include的区别在于，若包含的文件中有Velocity脚本标签，将会进一步解析，而include将原样显示。‘ #set ‘声明在万不得已的时候，不要在页面视图自己声明Velocity脚本变量，也就是尽量少使用’ #set ‘。附一位博友的文章链接 数据库部分 业务字段的设计数据的创建及增删改查的操作myBatis集成数据库环境整体框架的搭建 model controller service dao database 注册 登录 浏览 功能的实现 注册 用户合法性检验（长度，敏感词，重复，特殊字符）密码长度要求密码salt加密，密码长度检测（基于MD5加密）用户邮件 短信激活]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于vue的饿了吗项目总结]]></title>
    <url>%2F2017%2F11%2F08%2F%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E9%A5%BF%E4%BA%86%E5%90%97%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这是基于vue.js开发的一个仿饿了么外卖的前端APP 开发过程： 1. 需求分析 2. 脚手架工具 3. 数据mock 4. 架构设计 5. 代码编写 6. 自测 7. 编译打包功能技术分析:后端 vue-resource 前端 vue-router 第三方js库better-scrollhtml5的localstorage做本地存储 各种样式和布局flex布局组件化和模块化的思想 webpack打包构建工具商家页面： 顶部：商家基本信息 中间部分：商品区 评论区 商家 底部：购物车商品详情页 vue.js是一个基于MVVM的前端框架M model 模块 V view 视图 VM viewmodel 实现一个双向绑定数据驱动和组件化的开发模式组件化：模块封装 vue-cli是vue的脚手架工具,功能是搭建一些基本的代码和模块可以帮助我们完成目录结构、本地调试、热加载、单元测试npm install -g vue-cli 初始化项目vue init webpack name]]></content>
      <tags>
        <tag>前端</tag>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web前端基础知识点整理]]></title>
    <url>%2F2017%2F11%2F07%2Fweb%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[这篇文章是系统性的知识点的整理，并不详细，只是做个总结的作用 HTML&amp;CSS对web标准的理解 web标准是对web的结构，表现，行为的规范。 标签小写，标签闭合，不乱嵌套。 使用外css和js脚本，提高渲染速度 尽量避免使用行内样式，标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版。 标签规范可以提高搜索引擎对页面的抓取效率，对SEO很有帮助。 浏览器内核差异 Trident内核(window)IE 浏览器使用的内核 WebKit内核（NB 的内核，跨平台）chrome，Safari，塞班手机浏览器，安卓手机浏览器。 gecko内核 Firefox内核 浏览器渲染原理1.当用户在地址栏里面输入网址并敲下回车的时候，浏览器开始向服务器发出请求；2.当浏览器拿到html页面的时候，开始从上而下进行解释；3.当遇到link标签的时候，浏览器会再次向页面进行请求，并根据请求得到的css来重绘页面；4.当遇到script标签的时候，浏览器再次请求服务器，并执行得到的js对页面进行重绘；5.当遇到图片等其他文件的时候，浏览器也会再次发起请求并根据拿到的文件来对页面进行重绘；6.当进行上面这些步骤时，浏览器的重绘回流等是无法避免的，即需要进一步的优化，比如制作雪碧图，避免反复请求，给图片固定宽高等等；上面的内容也可以解释为： 浏览器拿到html、css、js,开始构建一个dom树，页面要显示的各元素都会创建到这个dom树当中，每当一个新元素加入到这个dom树当中，浏览器便会通过css引擎查询css样式表，找到符合该元素的样式规则应用到这个元素上，每一次应用新规则都可能引起重绘回流； css文件在加载的时候回阻塞页面渲染，但是并不会阻止dom解析，而js文件加载的时候会阻塞dom解析，所以通常把css文件放在页面头部而把脚本放在页面底部 ####浏览器兼容性问题 不同浏览器的标签默认的外边距和内边距不同*{margin:0;padding:0} 据说是一种不好的写法。有个初始化css的插件叫什么来着忘了 块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大在float的标签样式控制中加入 display:inline;将其转化为行内属性 设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。http://blog.csdn.net/chuyuqing/article/details/37561313/(附上别人总结的博客链接)hack[csshack]（http://www.duitang.com/static/csshack.html）CSS基本布局盒模型选择器优先级HTML5 CSS3data-* 属性用于存储页面或应用程序的私有自定义数据。data-* 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。data- 浏览器兼容性 Internet Explorer 11+ Chrome 8+ Firefox 6.0+ Opera 11.10+ Safari 6+ http://www.w3school.com.cn/html5/html_5_intro.asp FLEXBOX flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性 nowrap 不换行 wrap 换行 第一行在上方 wrap-reverse 换行 第一行在下方 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 justify-content属性 定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 align-items属性定义项目在交叉轴上如何对齐 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 http://www.jianshu.com/p/f9bcddb0e8b4 圣杯布局 优先渲染中间栏 中间栏宽度为100% 左右栏左外边距设为负百分比 圣杯布局和双飞翼布局解决问题的方案在前一半是相同的，也就是三栏全部float浮动，但左右两栏加上负margin让其跟中间栏div并排，以形成三栏布局。不同在于解决”中间栏div内容不被遮挡“问题的思路不一样：圣杯布局，为了中间div内容不被遮挡，将中间div设置了左右padding-left和padding-right后，将左右两个div用相对布局position: relative并分别配合right和left属性，以便左右两栏div移动后不遮挡中间div。双飞翼布局，为了中间div内容不被遮挡，直接在中间div内部创建子div用于放置内容，在该子div里用margin-left和margin-right为左右两栏div留出位置。多了1个div，少用大致4个css属性。JavaScriptmap和set map set() has() get() delete() set 重复元素在Set中自动被过滤 add() delete()数据类型number boolean string undefined null object运算this的指向问题http://www.jb51.net/article/42257.htm对象 数组对象 方法 join（[分隔符]） reverse()数组翻转 valueOf()返回数组值 字符串对象 方法 toUpperCase() 大写 toLowerCase() 小写 charAt（索引） indexOf（“字串”） replace(“字串1”,”字串2”) 字串2替换字串1 slice(索引i[,索引j]) 返回索引i倒索引j-1的子串 substr(start[,length]) 返回特定长度的字串 match（/匹配字符/） toString() 返回字符串 valueOf()返回字符串 数学对象 Math ceil(数值) 大于等于该数值的最小整数 floor(数值) 小于等于该数值的最小整数 random()0到1的随机数 round（数值）最接近该数值的整数 sqrt(数值) 开平方根 定时器用以指定在一段特定的时间后执行某段程序。 setTimeout()： 格式： [定时器对象名=] setTimeout(“&lt;表达式&gt;”，毫秒) 功能：执行&lt;表达式&gt;一次。 clearTimeout()：终止定时器 格式： clearTimeout(定时器对象名) 窗口名称.方法（参数）function 函数声明提前 函数构造器继承 使用对象冒充实现继承 采用call方法改变函数上下文实现继承 改变函数内部的函数上下文this，使它指向传入函数的具体对象闭包 外部函数不是必需的。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出；但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据。作用域在函数中使用var关键字进行显式申明的变量是做为局部变量，而没有用var关键字，使用直接赋值方式声明的是全局变量。 当我们使用访问一个没有声明的变量时，JS会报错。而当我们给一个没有声明的变量赋值时，JS不会报错，相反它会认为我们是要隐式申明一个全局变量，这一点一定要注意。原型链函数的原型对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针proto，该指针指向上一层的原型对象，而上一层的原型对象的结构依然类似，这样利用proto一直指向Object的原型对象上，而Object的原型对象用Object.prototype.proto = null表示原型链的最顶端，如此变形成了javascript的原型链继承，同时也解释了为什么所有的javascript对象都具有Object的基本方法。事件 JavaScript事件代理（委托）一般用于以下情况：1. 事件注册在祖先级元素上，代理其子级元素。可以减少事件注册数量，节约内存开销，提高性能。2. 对js动态添加的子元素可自动绑定事件。 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。 DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。####RegExpnew RegExp(pattern, attributes);参数 attributes 是一个可选的字符串，包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。 Jsonhttp://www.cnblogs.com/fanshaokun/p/6272850.htmlJSON有两种表示结构，对象和数组。字符串：这个很好解释，指使用“”双引号或’’单引号包括的字符。例如：var comStr = ‘this is string’;json字符串：指的是符合json格式要求的js字符串。例如：var jsonStr = “{StudentID:’100’,Name:’tmac’,Hometown:’usa’}”;json对象：指符合json格式要求的js对象。例如：var jsonObj = { StudentID: “100”, Name: “tmac”, Hometown: “usa” }; Ajax1.建立xmlHttpRequest对象2.设置回调函数3.使用OPEN方法与服务器建立连接 xmlHttp.open(“get”,”ajax?name=”+ name,true) 此步注意设置http的请求方式（post/get）,如果是POST方式，注意设置请求头信息xmlHttp.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”)4.向服务器端发送数据5.在回调函数中针对不同的响应状态进行处理 DOMBOM内存泄漏程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。垃圾回收机制怎么知道，哪些内存不再需要呢？最常使用的方法叫做”引用计数”（reference counting）：语言引擎有一张”引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。 跨域只要协议、域名、端口有任何一个不同，都被当作是不同的域。 通过jsonp跨域 通过修改document.domain来跨子域 使用window.name来进行跨域 异步装载 对于支持HTML5的浏览器，实现JS的异步加载只需要在script元素中加上async属性，为了兼容老版本的IE还需加上defer属性；对于不支持HTML5的浏览器(IE可以用defer实现)，可以采用以上几种方法实现。原理基本上都是向DOM中写入script或者通过eval函数执行JS代码，你可以把它放在匿名函数中执行，也可以在onload中执行，也可以通过XHR注入实现，也可以创建一个iframe元素，然后在iframe中执行插入JS代码。 模板引擎模板引擎分为java模板引擎和js模板引擎常用的java引擎有velocity （还有我就不晓得了，就接触过这一个）常用的javascript模板引擎有 ejs jade 还有互联网三巨头开发的模板引擎。。。 前端MVCMVC是一种设计模式，它将应用划分为3个部分：数据（模型）、展现层（视图）和用户交互（控制器）。换句话说，一个事件的发生是这样的过程： 1. 用户和应用产生交互。 2. 控制器的事件处理器被触发。 3. 控制器从模型中请求数据，并将其交给视图。 4. 视图将数据呈现给用户。（1）MVC： 模型－视图－控制器(Model View Controller)（2）MVP： 模型－视图－表现类（Model-View-Presenter）（3）MVVM：模型－视图－视图模型（Model-View-ViewModel） 路由 init 监听浏览器 url hash 更新事件 route 存储路由更新时的回调到回调数组routes中，回调函数将负责对页面的更新 refresh 执行当前url对应的回调函数，更新页面以上，以前写的，没怎么了解前端路由之前写的，我也不知道写的是个啥。以下，有点了解之后写的。前端的js页面在es6之前都模块化这样一个概念，自然也无法实现多个js页面的相互关联，这样的相互关联的过程就是前端路由。虽然在es6之前没有模块化，但是可以用第三方提供的一些模块化的方法，如AMD COMMONJS 在node.js中，已经有了模块化的方法。node.js可以很优雅的实现前端路由~~ 模块化 函数封装 这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。 对象 为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中 这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系 看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员 立即执行函数 放大模式 如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。 宽放大模式 与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。 输入全局变量 独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。为了在模块内部调用全局变量，必须显式地将其他变量输入模块。 CanvasHTML5中的一个画布，功能强大，详情参考html5的内容 ES6 let var const let是块级作用域，跟var不同的是，let没有前置功能，不能重复声明 const定义的变量不可以修改，而且必须初始化。 var分为两种：局部作用域和函数作用域 let是块级作用域，函数内部使用let定义后，对函数外部无影响。 箭头函数 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return 箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 promise pending进行中 fullfilled已成功/resolved rejected已失败 then 只有异步操作的结果能决定当前是哪种状态 map 和set set() get() has() delete()专门整理了一篇关于es6新特性的博客，还有部分内容在图书馆看书的时候记在了小本子上，择日整理上传 Nodejs详情参考node.js入门篇]]></content>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内心煎熬]]></title>
    <url>%2F2017%2F11%2F07%2F%E5%86%85%E5%BF%83%E7%85%8E%E7%86%AC%2F</url>
    <content type="text"><![CDATA[开始秋招的第不知道多少天不觉得自己努力比别人少，可能方向和方法上真的有很大的问题。一度怀疑自己，是不是真的太没用，什么都做不了。还从来都没有好运气。真的觉得很难过。加上整体的氛围，整个人真的，很乱。写下来是希望无论以后是个什么要的结果，不要好了伤疤忘了疼，决定做什么事的时候，一定要未雨绸缪，做好万全的准备。希望能够有个比较好的结局。坚持做该做的事吧。 所以如果有正处于大学迷茫期的小伙伴们，一定不能眼高手低，一定要多写代码。多关注实习信息。争取早点去公司实习。不然永远不知道，在学校学的东西跟企业有多大差距。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2017%2F11%2F06%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[三大特性五大基本原则继承 封装 多态封装：把客观事物封装成抽象的类继承：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。多态：指一个类实例在不同的情形下可以有不同的表现形式，可以通过接口的形式实现。参考 Java中修饰符private：该类；default：同包访问，且为默认值；protected：同包及继承子类可访问；public：均可访问 Java的四类八种数据类型整数类型 byte 1字节 short 2字节 int 4字节 long 8字节浮点型 float 4字节 double 8字节布尔型 Boolean字符型 char引用数据类型：类class 接口interface 数组 注：String不属于八种的一种，String是一个对象。 ArrayList和LinkedList区别ArrayList和LinkedList都实现了List接口，他们有以下的不同点：ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。 collection和collections1、java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作list queue 等2、java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。 集合Java集合类框架的基本接口Collection：代表一组对象，每一个对象都是它的子元素。Set：不包含重复元素的Collection。List：有顺序的collection，并且可以包含重复元素。Map：可以把键(key)映射到值(value)的对象，键不能重复。 String VS StringBuilder VS StringBufferString是不可变对象(final修饰)，一旦创建，那么整个对象就不可改变。即使新手觉得String引用变了，实际上只是（指针）引用指向了另一个（新的）对象。StringBuilder 是可变的,因此可以在创建以后修改内部的值.StringBuffer 是同步的,因此是线程安全的,但效率相对更低.通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的。StringBuilder和StringBuffer类拥有的成员属性以及成员方法基本相同，区别是StringBuffer类的成员方法前面多了一个关键字：synchronized，不用多说，这个关键字是在多线程访问时起到安全保护作用的,也就是说StringBuffer是线程安全的。参考 hashmap和hashtable concurrentHashMapJava中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。 继承类不同： A.HashMap继承AbstractMap B.Hashtable继承Dictionary 执行效率不同： A.HashMap是非线程安全的，是Hashtable的轻量级实现，效率较高 B.Hashtable是线程安全的，效率较低 put方法对key和value的要求不同 A.HashMap允许Entry的key或value为null B.Hashtable不允许Entry的key或value为null，否则出现NullPointerException 有无contains方法 A.HashMap没有contains方法 B.Hashtable有contains方法从ConcurrentHashMap代码中可以看出，它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。转载自某总结的很全面的文章 hashset和treesetHashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。 无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。 方法覆盖和方法重载Java中的方法重载发生在同一个 类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。 相同点：都要求方法同名。都可以用于抽象方法和非抽象方法之间。 不同点：方法覆盖要求参数签名必须一致，而方法重载要求参数签名必须不一致。方法覆盖要求返回类型必须一致，而方法重载对此不做限制。方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类的所有方法（包括从父类中继承而来的方法）。方法覆盖对方法的访问权限和抛出的异常有特殊的要求，而方法重载在这方面没有限制。父类的一个方法只能被子类覆盖一次，而一个方法在所在的类中可以被重载多次。 线程一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 并行与并发：并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果， 同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。BIO NIO AIO的区别 java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。applet可以经历下面的状态：Init：每次被载入的时候都会被初始化。Start：开始执行applet。Stop：结束执行applet。Destroy：卸载applet之前，做最后的清理工作。 连接池像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。 Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。生命周期：对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet的destroy()方法把Servlet删除掉。 Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。 sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。 JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：jsp:include-当JSP页面被请求的时候包含一个文件。jsp:useBean-找出或者是初始化Javabean。jsp:setProperty-设置JavaBean的属性。jsp:getProperty-获取JavaBean的属性。jsp:forward-把请求转发到新的页面。jsp:plugin-产生特定浏览器的代码。 jsp隐含对象：applicationpagerequestresponsesessionexceptionoutconfigpageContext 抽象抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。 常见软件设计模式 单例模式： 单例模式有以下特点： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。 每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。 简单工厂： 工厂方法和抽象工厂： Springhttp://www.cnblogs.com/wmbg/p/6972194.htmlSpring七个模块Spring contextSpring AOPSpring DAOSpring ORMSpring WebSpring MVCSpring CoreAOP和IOC aop允许程序通过分离的应用业务逻辑与系统级别服务。程序员只需专注自己的业务逻辑，而不需要管系统级服务。容器中的对象能享有容器中的公共服务（日志、安全）. 原理通过动态代理做到这一点。用到了代理模式，代理模式是一种静态代理，而动态代理就是利用反射和动态编译将代理模式变成动态的。得知被代理类后通过反射得知他的一切信息，然后动态编译成代理类的class文件（动态组装成代理类，生成java文件，再编译成class文件）。 优点提供另外一种编程思路，可以把类似的行为抽离出来统一处理。 ioc依赖注入（DI）和控制反转（Inversion of Control）是同一个概念。控制权的反转，在程序中对象的控制权转到容器而不是程序员自己控制，促进了松耦合。依赖注入，将相互依赖的对象分离，在Spring配置文件中，描述他们的依赖关系，用到一个对象时注入，而不需要New一个对象。 原理通过工厂+反射将我们的bean放到容器中，当我们想用某个bean的时候，只需要调用getBean(“beanID”)方法。 优点解耦、统一管理bean，缺点占用内存多、构造对象慢 参考：某博主总结的面试知识点，很全面http://www.cnblogs.com/lanhj/p/4672735.html]]></content>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今日随笔“]]></title>
    <url>%2F2017%2F11%2F06%2F%E4%BB%8A%E6%97%A5%E9%9A%8F%E7%AC%94%E2%80%9C%2F</url>
    <content type="text"><![CDATA[anyway 今天也算是有了许多收获。从今以后，正式在github写博客啦~反应有点慢，加强锻炼啊]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
